// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.6.1
//   protoc               unknown
// source: ethermint/evm/v1/evm.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";

export const protobufPackage = "ethermint.evm.v1";

/**
 * Copyright Tharsis Labs Ltd.(Evmos)
 * SPDX-License-Identifier:ENCL-1.0(https://github.com/evmos/evmos/blob/main/LICENSE)
 */

/** AccessType defines the types of permissions for the operations */
export enum AccessType {
  /** ACCESS_TYPE_PERMISSIONLESS - ACCESS_TYPE_PERMISSIONLESS does not restrict the operation to anyone */
  ACCESS_TYPE_PERMISSIONLESS = 0,
  /** ACCESS_TYPE_RESTRICTED - ACCESS_TYPE_RESTRICTED restrict the operation to anyone */
  ACCESS_TYPE_RESTRICTED = 1,
  /** ACCESS_TYPE_PERMISSIONED - ACCESS_TYPE_PERMISSIONED only allows the operation for specific addresses */
  ACCESS_TYPE_PERMISSIONED = 2,
  UNRECOGNIZED = -1,
}

export function accessTypeFromJSON(object: any): AccessType {
  switch (object) {
    case 0:
    case "ACCESS_TYPE_PERMISSIONLESS":
      return AccessType.ACCESS_TYPE_PERMISSIONLESS;
    case 1:
    case "ACCESS_TYPE_RESTRICTED":
      return AccessType.ACCESS_TYPE_RESTRICTED;
    case 2:
    case "ACCESS_TYPE_PERMISSIONED":
      return AccessType.ACCESS_TYPE_PERMISSIONED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return AccessType.UNRECOGNIZED;
  }
}

export function accessTypeToJSON(object: AccessType): string {
  switch (object) {
    case AccessType.ACCESS_TYPE_PERMISSIONLESS:
      return "ACCESS_TYPE_PERMISSIONLESS";
    case AccessType.ACCESS_TYPE_RESTRICTED:
      return "ACCESS_TYPE_RESTRICTED";
    case AccessType.ACCESS_TYPE_PERMISSIONED:
      return "ACCESS_TYPE_PERMISSIONED";
    case AccessType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Params defines the EVM module parameters */
export interface Params {
  /**
   * evm_denom represents the token denomination used to run the EVM state
   * transitions.
   */
  evmDenom: string;
  /** extra_eips defines the additional EIPs for the vm.Config */
  extraEips: number[];
  /** chain_config defines the EVM chain configuration parameters */
  chainConfig:
    | ChainConfig
    | undefined;
  /**
   * allow_unprotected_txs defines if replay-protected (i.e non EIP155
   * signed) transactions can be executed on the state machine.
   */
  allowUnprotectedTxs: boolean;
  /** evm_channels is the list of channel identifiers from EVM compatible chains */
  evmChannels: string[];
  /** access_control defines the permission policy of the EVM */
  accessControl:
    | AccessControl
    | undefined;
  /**
   * active_static_precompiles defines the slice of hex addresses of the precompiled
   * contracts that are active
   */
  activeStaticPrecompiles: string[];
}

/**
 * AccessControl defines the permission policy of the EVM
 * for creating and calling contracts
 */
export interface AccessControl {
  /** create defines the permission policy for creating contracts */
  create:
    | AccessControlType
    | undefined;
  /** call defines the permission policy for calling contracts */
  call: AccessControlType | undefined;
}

/** AccessControlType defines the permission type for policies */
export interface AccessControlType {
  /** access_type defines which type of permission is required for the operation */
  accessType: AccessType;
  /**
   * access_control_list defines defines different things depending on the AccessType:
   * - ACCESS_TYPE_PERMISSIONLESS: list of addresses that are blocked from performing the operation
   * - ACCESS_TYPE_RESTRICTED: ignored
   * - ACCESS_TYPE_PERMISSIONED: list of addresses that are allowed to perform the operation
   */
  accessControlList: string[];
}

/**
 * ChainConfig defines the Ethereum ChainConfig parameters using *sdk.Int values
 * instead of *big.Int.
 */
export interface ChainConfig {
  /** homestead_block switch (nil no fork, 0 = already homestead) */
  homesteadBlock: string;
  /** dao_fork_block corresponds to TheDAO hard-fork switch block (nil no fork) */
  daoForkBlock: string;
  /** dao_fork_support defines whether the nodes supports or opposes the DAO hard-fork */
  daoForkSupport: boolean;
  /**
   * eip150_block: EIP150 implements the Gas price changes
   * (https://github.com/ethereum/EIPs/issues/150) EIP150 HF block (nil no fork)
   */
  eip150Block: string;
  /** eip150_hash: EIP150 HF hash (needed for header only clients as only gas pricing changed) */
  eip150Hash: string;
  /** eip155_block: EIP155Block HF block */
  eip155Block: string;
  /** eip158_block: EIP158 HF block */
  eip158Block: string;
  /** byzantium_block: Byzantium switch block (nil no fork, 0 = already on byzantium) */
  byzantiumBlock: string;
  /** constantinople_block: Constantinople switch block (nil no fork, 0 = already activated) */
  constantinopleBlock: string;
  /** petersburg_block: Petersburg switch block (nil same as Constantinople) */
  petersburgBlock: string;
  /** istanbul_block: Istanbul switch block (nil no fork, 0 = already on istanbul) */
  istanbulBlock: string;
  /** muir_glacier_block: Eip-2384 (bomb delay) switch block (nil no fork, 0 = already activated) */
  muirGlacierBlock: string;
  /** berlin_block: Berlin switch block (nil = no fork, 0 = already on berlin) */
  berlinBlock: string;
  /** london_block: London switch block (nil = no fork, 0 = already on london) */
  londonBlock: string;
  /** arrow_glacier_block: Eip-4345 (bomb delay) switch block (nil = no fork, 0 = already activated) */
  arrowGlacierBlock: string;
  /** gray_glacier_block: EIP-5133 (bomb delay) switch block (nil = no fork, 0 = already activated) */
  grayGlacierBlock: string;
  /** merge_netsplit_block: Virtual fork after The Merge to use as a network splitter */
  mergeNetsplitBlock: string;
  /** shanghai switch time (nil = no fork, 0 = already on shanghai) */
  shanghaiTime: string;
  /** cancun switch time (nil = no fork, 0 = already on cancun) */
  cancunTime: string;
  /** prague switch time (nil = no fork, 0 = already on prague) */
  pragueTime: string;
  verkleTime: string;
}

/** State represents a single Storage key value pair item. */
export interface State {
  /** key is the stored key */
  key: string;
  /** value is the stored value for the given key */
  value: string;
}

/**
 * TransactionLogs define the logs generated from a transaction execution
 * with a given hash. It it used for import/export data as transactions are not
 * persisted on blockchain state after an upgrade.
 */
export interface TransactionLogs {
  /** hash of the transaction */
  hash: string;
  /** logs is an array of Logs for the given transaction hash */
  logs: Log[];
}

/**
 * Log represents an protobuf compatible Ethereum Log that defines a contract
 * log event. These events are generated by the LOG opcode and stored/indexed by
 * the node.
 *
 * NOTE: address, topics and data are consensus fields. The rest of the fields
 * are derived, i.e. filled in by the nodes, but not secured by consensus.
 */
export interface Log {
  /** address of the contract that generated the event */
  address: string;
  /** topics is a list of topics provided by the contract. */
  topics: string[];
  /** data which is supplied by the contract, usually ABI-encoded */
  data: Uint8Array;
  /** block_number of the block in which the transaction was included */
  blockNumber: number;
  /** tx_hash is the transaction hash */
  txHash: string;
  /** tx_index of the transaction in the block */
  txIndex: number;
  /** block_hash of the block in which the transaction was included */
  blockHash: string;
  /** index of the log in the block */
  index: number;
  /**
   * removed is true if this log was reverted due to a chain
   * reorganisation. You must pay attention to this field if you receive logs
   * through a filter query.
   */
  removed: boolean;
}

/** TxResult stores results of Tx execution. */
export interface TxResult {
  /**
   * contract_address contains the ethereum address of the created contract (if
   * any). If the state transition is an evm.Call, the contract address will be
   * empty.
   */
  contractAddress: string;
  /** bloom represents the bloom filter bytes */
  bloom: Uint8Array;
  /**
   * tx_logs contains the transaction hash and the proto-compatible ethereum
   * logs.
   */
  txLogs:
    | TransactionLogs
    | undefined;
  /** ret defines the bytes from the execution. */
  ret: Uint8Array;
  /** reverted flag is set to true when the call has been reverted */
  reverted: boolean;
  /** gas_used notes the amount of gas consumed while execution */
  gasUsed: number;
}

/** AccessTuple is the element type of an access list. */
export interface AccessTuple {
  /** address is a hex formatted ethereum address */
  address: string;
  /** storage_keys are hex formatted hashes of the storage keys */
  storageKeys: string[];
}

/** TraceConfig holds extra parameters to trace functions. */
export interface TraceConfig {
  /** tracer is a custom javascript tracer */
  tracer: string;
  /**
   * timeout overrides the default timeout of 5 seconds for JavaScript-based tracing
   * calls
   */
  timeout: string;
  /** reexec defines the number of blocks the tracer is willing to go back */
  reexec: number;
  /** disable_stack switches stack capture */
  disableStack: boolean;
  /** disable_storage switches storage capture */
  disableStorage: boolean;
  /** debug can be used to print output during capture end */
  debug: boolean;
  /** limit defines the maximum length of output, but zero means unlimited */
  limit: number;
  /** overrides can be used to execute a trace using future fork rules */
  overrides:
    | ChainConfig
    | undefined;
  /** enable_memory switches memory capture */
  enableMemory: boolean;
  /** enable_return_data switches the capture of return data */
  enableReturnData: boolean;
  /** tracer_json_config configures the tracer using a JSON string */
  tracerJsonConfig: string;
}

function createBaseParams(): Params {
  return {
    evmDenom: "",
    extraEips: [],
    chainConfig: undefined,
    allowUnprotectedTxs: false,
    evmChannels: [],
    accessControl: undefined,
    activeStaticPrecompiles: [],
  };
}

export const Params: MessageFns<Params> = {
  encode(message: Params, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.evmDenom !== "") {
      writer.uint32(10).string(message.evmDenom);
    }
    writer.uint32(34).fork();
    for (const v of message.extraEips) {
      writer.int32(v);
    }
    writer.join();
    if (message.chainConfig !== undefined) {
      ChainConfig.encode(message.chainConfig, writer.uint32(42).fork()).join();
    }
    if (message.allowUnprotectedTxs !== false) {
      writer.uint32(48).bool(message.allowUnprotectedTxs);
    }
    for (const v of message.evmChannels) {
      writer.uint32(66).string(v!);
    }
    if (message.accessControl !== undefined) {
      AccessControl.encode(message.accessControl, writer.uint32(74).fork()).join();
    }
    for (const v of message.activeStaticPrecompiles) {
      writer.uint32(82).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Params {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseParams();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.evmDenom = reader.string();
          continue;
        }
        case 4: {
          if (tag === 32) {
            message.extraEips.push(reader.int32());

            continue;
          }

          if (tag === 34) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.extraEips.push(reader.int32());
            }

            continue;
          }

          break;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.chainConfig = ChainConfig.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.allowUnprotectedTxs = reader.bool();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.evmChannels.push(reader.string());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.accessControl = AccessControl.decode(reader, reader.uint32());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.activeStaticPrecompiles.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Params {
    return {
      evmDenom: isSet(object.evmDenom) ? globalThis.String(object.evmDenom) : "",
      extraEips: globalThis.Array.isArray(object?.extraEips)
        ? object.extraEips.map((e: any) => globalThis.Number(e))
        : [],
      chainConfig: isSet(object.chainConfig) ? ChainConfig.fromJSON(object.chainConfig) : undefined,
      allowUnprotectedTxs: isSet(object.allowUnprotectedTxs) ? globalThis.Boolean(object.allowUnprotectedTxs) : false,
      evmChannels: globalThis.Array.isArray(object?.evmChannels)
        ? object.evmChannels.map((e: any) => globalThis.String(e))
        : [],
      accessControl: isSet(object.accessControl) ? AccessControl.fromJSON(object.accessControl) : undefined,
      activeStaticPrecompiles: globalThis.Array.isArray(object?.activeStaticPrecompiles)
        ? object.activeStaticPrecompiles.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: Params): unknown {
    const obj: any = {};
    if (message.evmDenom !== "") {
      obj.evmDenom = message.evmDenom;
    }
    if (message.extraEips?.length) {
      obj.extraEips = message.extraEips.map((e) => Math.round(e));
    }
    if (message.chainConfig !== undefined) {
      obj.chainConfig = ChainConfig.toJSON(message.chainConfig);
    }
    if (message.allowUnprotectedTxs !== false) {
      obj.allowUnprotectedTxs = message.allowUnprotectedTxs;
    }
    if (message.evmChannels?.length) {
      obj.evmChannels = message.evmChannels;
    }
    if (message.accessControl !== undefined) {
      obj.accessControl = AccessControl.toJSON(message.accessControl);
    }
    if (message.activeStaticPrecompiles?.length) {
      obj.activeStaticPrecompiles = message.activeStaticPrecompiles;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Params>, I>>(base?: I): Params {
    return Params.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Params>, I>>(object: I): Params {
    const message = createBaseParams();
    message.evmDenom = object.evmDenom ?? "";
    message.extraEips = object.extraEips?.map((e) => e) || [];
    message.chainConfig = (object.chainConfig !== undefined && object.chainConfig !== null)
      ? ChainConfig.fromPartial(object.chainConfig)
      : undefined;
    message.allowUnprotectedTxs = object.allowUnprotectedTxs ?? false;
    message.evmChannels = object.evmChannels?.map((e) => e) || [];
    message.accessControl = (object.accessControl !== undefined && object.accessControl !== null)
      ? AccessControl.fromPartial(object.accessControl)
      : undefined;
    message.activeStaticPrecompiles = object.activeStaticPrecompiles?.map((e) => e) || [];
    return message;
  },
};

function createBaseAccessControl(): AccessControl {
  return { create: undefined, call: undefined };
}

export const AccessControl: MessageFns<AccessControl> = {
  encode(message: AccessControl, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.create !== undefined) {
      AccessControlType.encode(message.create, writer.uint32(10).fork()).join();
    }
    if (message.call !== undefined) {
      AccessControlType.encode(message.call, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AccessControl {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAccessControl();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.create = AccessControlType.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.call = AccessControlType.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AccessControl {
    return {
      create: isSet(object.create) ? AccessControlType.fromJSON(object.create) : undefined,
      call: isSet(object.call) ? AccessControlType.fromJSON(object.call) : undefined,
    };
  },

  toJSON(message: AccessControl): unknown {
    const obj: any = {};
    if (message.create !== undefined) {
      obj.create = AccessControlType.toJSON(message.create);
    }
    if (message.call !== undefined) {
      obj.call = AccessControlType.toJSON(message.call);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AccessControl>, I>>(base?: I): AccessControl {
    return AccessControl.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AccessControl>, I>>(object: I): AccessControl {
    const message = createBaseAccessControl();
    message.create = (object.create !== undefined && object.create !== null)
      ? AccessControlType.fromPartial(object.create)
      : undefined;
    message.call = (object.call !== undefined && object.call !== null)
      ? AccessControlType.fromPartial(object.call)
      : undefined;
    return message;
  },
};

function createBaseAccessControlType(): AccessControlType {
  return { accessType: 0, accessControlList: [] };
}

export const AccessControlType: MessageFns<AccessControlType> = {
  encode(message: AccessControlType, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.accessType !== 0) {
      writer.uint32(8).int32(message.accessType);
    }
    for (const v of message.accessControlList) {
      writer.uint32(18).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AccessControlType {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAccessControlType();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.accessType = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.accessControlList.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AccessControlType {
    return {
      accessType: isSet(object.accessType) ? accessTypeFromJSON(object.accessType) : 0,
      accessControlList: globalThis.Array.isArray(object?.accessControlList)
        ? object.accessControlList.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: AccessControlType): unknown {
    const obj: any = {};
    if (message.accessType !== 0) {
      obj.accessType = accessTypeToJSON(message.accessType);
    }
    if (message.accessControlList?.length) {
      obj.accessControlList = message.accessControlList;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AccessControlType>, I>>(base?: I): AccessControlType {
    return AccessControlType.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AccessControlType>, I>>(object: I): AccessControlType {
    const message = createBaseAccessControlType();
    message.accessType = object.accessType ?? 0;
    message.accessControlList = object.accessControlList?.map((e) => e) || [];
    return message;
  },
};

function createBaseChainConfig(): ChainConfig {
  return {
    homesteadBlock: "",
    daoForkBlock: "",
    daoForkSupport: false,
    eip150Block: "",
    eip150Hash: "",
    eip155Block: "",
    eip158Block: "",
    byzantiumBlock: "",
    constantinopleBlock: "",
    petersburgBlock: "",
    istanbulBlock: "",
    muirGlacierBlock: "",
    berlinBlock: "",
    londonBlock: "",
    arrowGlacierBlock: "",
    grayGlacierBlock: "",
    mergeNetsplitBlock: "",
    shanghaiTime: "",
    cancunTime: "",
    pragueTime: "",
    verkleTime: "",
  };
}

export const ChainConfig: MessageFns<ChainConfig> = {
  encode(message: ChainConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.homesteadBlock !== "") {
      writer.uint32(10).string(message.homesteadBlock);
    }
    if (message.daoForkBlock !== "") {
      writer.uint32(18).string(message.daoForkBlock);
    }
    if (message.daoForkSupport !== false) {
      writer.uint32(24).bool(message.daoForkSupport);
    }
    if (message.eip150Block !== "") {
      writer.uint32(34).string(message.eip150Block);
    }
    if (message.eip150Hash !== "") {
      writer.uint32(42).string(message.eip150Hash);
    }
    if (message.eip155Block !== "") {
      writer.uint32(50).string(message.eip155Block);
    }
    if (message.eip158Block !== "") {
      writer.uint32(58).string(message.eip158Block);
    }
    if (message.byzantiumBlock !== "") {
      writer.uint32(66).string(message.byzantiumBlock);
    }
    if (message.constantinopleBlock !== "") {
      writer.uint32(74).string(message.constantinopleBlock);
    }
    if (message.petersburgBlock !== "") {
      writer.uint32(82).string(message.petersburgBlock);
    }
    if (message.istanbulBlock !== "") {
      writer.uint32(90).string(message.istanbulBlock);
    }
    if (message.muirGlacierBlock !== "") {
      writer.uint32(98).string(message.muirGlacierBlock);
    }
    if (message.berlinBlock !== "") {
      writer.uint32(106).string(message.berlinBlock);
    }
    if (message.londonBlock !== "") {
      writer.uint32(138).string(message.londonBlock);
    }
    if (message.arrowGlacierBlock !== "") {
      writer.uint32(146).string(message.arrowGlacierBlock);
    }
    if (message.grayGlacierBlock !== "") {
      writer.uint32(162).string(message.grayGlacierBlock);
    }
    if (message.mergeNetsplitBlock !== "") {
      writer.uint32(170).string(message.mergeNetsplitBlock);
    }
    if (message.shanghaiTime !== "") {
      writer.uint32(178).string(message.shanghaiTime);
    }
    if (message.cancunTime !== "") {
      writer.uint32(186).string(message.cancunTime);
    }
    if (message.pragueTime !== "") {
      writer.uint32(194).string(message.pragueTime);
    }
    if (message.verkleTime !== "") {
      writer.uint32(202).string(message.verkleTime);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ChainConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChainConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.homesteadBlock = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.daoForkBlock = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.daoForkSupport = reader.bool();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.eip150Block = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.eip150Hash = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.eip155Block = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.eip158Block = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.byzantiumBlock = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.constantinopleBlock = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.petersburgBlock = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.istanbulBlock = reader.string();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.muirGlacierBlock = reader.string();
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.berlinBlock = reader.string();
          continue;
        }
        case 17: {
          if (tag !== 138) {
            break;
          }

          message.londonBlock = reader.string();
          continue;
        }
        case 18: {
          if (tag !== 146) {
            break;
          }

          message.arrowGlacierBlock = reader.string();
          continue;
        }
        case 20: {
          if (tag !== 162) {
            break;
          }

          message.grayGlacierBlock = reader.string();
          continue;
        }
        case 21: {
          if (tag !== 170) {
            break;
          }

          message.mergeNetsplitBlock = reader.string();
          continue;
        }
        case 22: {
          if (tag !== 178) {
            break;
          }

          message.shanghaiTime = reader.string();
          continue;
        }
        case 23: {
          if (tag !== 186) {
            break;
          }

          message.cancunTime = reader.string();
          continue;
        }
        case 24: {
          if (tag !== 194) {
            break;
          }

          message.pragueTime = reader.string();
          continue;
        }
        case 25: {
          if (tag !== 202) {
            break;
          }

          message.verkleTime = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ChainConfig {
    return {
      homesteadBlock: isSet(object.homesteadBlock) ? globalThis.String(object.homesteadBlock) : "",
      daoForkBlock: isSet(object.daoForkBlock) ? globalThis.String(object.daoForkBlock) : "",
      daoForkSupport: isSet(object.daoForkSupport) ? globalThis.Boolean(object.daoForkSupport) : false,
      eip150Block: isSet(object.eip150Block) ? globalThis.String(object.eip150Block) : "",
      eip150Hash: isSet(object.eip150Hash) ? globalThis.String(object.eip150Hash) : "",
      eip155Block: isSet(object.eip155Block) ? globalThis.String(object.eip155Block) : "",
      eip158Block: isSet(object.eip158Block) ? globalThis.String(object.eip158Block) : "",
      byzantiumBlock: isSet(object.byzantiumBlock) ? globalThis.String(object.byzantiumBlock) : "",
      constantinopleBlock: isSet(object.constantinopleBlock) ? globalThis.String(object.constantinopleBlock) : "",
      petersburgBlock: isSet(object.petersburgBlock) ? globalThis.String(object.petersburgBlock) : "",
      istanbulBlock: isSet(object.istanbulBlock) ? globalThis.String(object.istanbulBlock) : "",
      muirGlacierBlock: isSet(object.muirGlacierBlock) ? globalThis.String(object.muirGlacierBlock) : "",
      berlinBlock: isSet(object.berlinBlock) ? globalThis.String(object.berlinBlock) : "",
      londonBlock: isSet(object.londonBlock) ? globalThis.String(object.londonBlock) : "",
      arrowGlacierBlock: isSet(object.arrowGlacierBlock) ? globalThis.String(object.arrowGlacierBlock) : "",
      grayGlacierBlock: isSet(object.grayGlacierBlock) ? globalThis.String(object.grayGlacierBlock) : "",
      mergeNetsplitBlock: isSet(object.mergeNetsplitBlock) ? globalThis.String(object.mergeNetsplitBlock) : "",
      shanghaiTime: isSet(object.shanghaiTime) ? globalThis.String(object.shanghaiTime) : "",
      cancunTime: isSet(object.cancunTime) ? globalThis.String(object.cancunTime) : "",
      pragueTime: isSet(object.pragueTime) ? globalThis.String(object.pragueTime) : "",
      verkleTime: isSet(object.verkleTime) ? globalThis.String(object.verkleTime) : "",
    };
  },

  toJSON(message: ChainConfig): unknown {
    const obj: any = {};
    if (message.homesteadBlock !== "") {
      obj.homesteadBlock = message.homesteadBlock;
    }
    if (message.daoForkBlock !== "") {
      obj.daoForkBlock = message.daoForkBlock;
    }
    if (message.daoForkSupport !== false) {
      obj.daoForkSupport = message.daoForkSupport;
    }
    if (message.eip150Block !== "") {
      obj.eip150Block = message.eip150Block;
    }
    if (message.eip150Hash !== "") {
      obj.eip150Hash = message.eip150Hash;
    }
    if (message.eip155Block !== "") {
      obj.eip155Block = message.eip155Block;
    }
    if (message.eip158Block !== "") {
      obj.eip158Block = message.eip158Block;
    }
    if (message.byzantiumBlock !== "") {
      obj.byzantiumBlock = message.byzantiumBlock;
    }
    if (message.constantinopleBlock !== "") {
      obj.constantinopleBlock = message.constantinopleBlock;
    }
    if (message.petersburgBlock !== "") {
      obj.petersburgBlock = message.petersburgBlock;
    }
    if (message.istanbulBlock !== "") {
      obj.istanbulBlock = message.istanbulBlock;
    }
    if (message.muirGlacierBlock !== "") {
      obj.muirGlacierBlock = message.muirGlacierBlock;
    }
    if (message.berlinBlock !== "") {
      obj.berlinBlock = message.berlinBlock;
    }
    if (message.londonBlock !== "") {
      obj.londonBlock = message.londonBlock;
    }
    if (message.arrowGlacierBlock !== "") {
      obj.arrowGlacierBlock = message.arrowGlacierBlock;
    }
    if (message.grayGlacierBlock !== "") {
      obj.grayGlacierBlock = message.grayGlacierBlock;
    }
    if (message.mergeNetsplitBlock !== "") {
      obj.mergeNetsplitBlock = message.mergeNetsplitBlock;
    }
    if (message.shanghaiTime !== "") {
      obj.shanghaiTime = message.shanghaiTime;
    }
    if (message.cancunTime !== "") {
      obj.cancunTime = message.cancunTime;
    }
    if (message.pragueTime !== "") {
      obj.pragueTime = message.pragueTime;
    }
    if (message.verkleTime !== "") {
      obj.verkleTime = message.verkleTime;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ChainConfig>, I>>(base?: I): ChainConfig {
    return ChainConfig.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ChainConfig>, I>>(object: I): ChainConfig {
    const message = createBaseChainConfig();
    message.homesteadBlock = object.homesteadBlock ?? "";
    message.daoForkBlock = object.daoForkBlock ?? "";
    message.daoForkSupport = object.daoForkSupport ?? false;
    message.eip150Block = object.eip150Block ?? "";
    message.eip150Hash = object.eip150Hash ?? "";
    message.eip155Block = object.eip155Block ?? "";
    message.eip158Block = object.eip158Block ?? "";
    message.byzantiumBlock = object.byzantiumBlock ?? "";
    message.constantinopleBlock = object.constantinopleBlock ?? "";
    message.petersburgBlock = object.petersburgBlock ?? "";
    message.istanbulBlock = object.istanbulBlock ?? "";
    message.muirGlacierBlock = object.muirGlacierBlock ?? "";
    message.berlinBlock = object.berlinBlock ?? "";
    message.londonBlock = object.londonBlock ?? "";
    message.arrowGlacierBlock = object.arrowGlacierBlock ?? "";
    message.grayGlacierBlock = object.grayGlacierBlock ?? "";
    message.mergeNetsplitBlock = object.mergeNetsplitBlock ?? "";
    message.shanghaiTime = object.shanghaiTime ?? "";
    message.cancunTime = object.cancunTime ?? "";
    message.pragueTime = object.pragueTime ?? "";
    message.verkleTime = object.verkleTime ?? "";
    return message;
  },
};

function createBaseState(): State {
  return { key: "", value: "" };
}

export const State: MessageFns<State> = {
  encode(message: State, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): State {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseState();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): State {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: State): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<State>, I>>(base?: I): State {
    return State.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<State>, I>>(object: I): State {
    const message = createBaseState();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseTransactionLogs(): TransactionLogs {
  return { hash: "", logs: [] };
}

export const TransactionLogs: MessageFns<TransactionLogs> = {
  encode(message: TransactionLogs, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.hash !== "") {
      writer.uint32(10).string(message.hash);
    }
    for (const v of message.logs) {
      Log.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TransactionLogs {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTransactionLogs();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.hash = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.logs.push(Log.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TransactionLogs {
    return {
      hash: isSet(object.hash) ? globalThis.String(object.hash) : "",
      logs: globalThis.Array.isArray(object?.logs) ? object.logs.map((e: any) => Log.fromJSON(e)) : [],
    };
  },

  toJSON(message: TransactionLogs): unknown {
    const obj: any = {};
    if (message.hash !== "") {
      obj.hash = message.hash;
    }
    if (message.logs?.length) {
      obj.logs = message.logs.map((e) => Log.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TransactionLogs>, I>>(base?: I): TransactionLogs {
    return TransactionLogs.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TransactionLogs>, I>>(object: I): TransactionLogs {
    const message = createBaseTransactionLogs();
    message.hash = object.hash ?? "";
    message.logs = object.logs?.map((e) => Log.fromPartial(e)) || [];
    return message;
  },
};

function createBaseLog(): Log {
  return {
    address: "",
    topics: [],
    data: new Uint8Array(0),
    blockNumber: 0,
    txHash: "",
    txIndex: 0,
    blockHash: "",
    index: 0,
    removed: false,
  };
}

export const Log: MessageFns<Log> = {
  encode(message: Log, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.address !== "") {
      writer.uint32(10).string(message.address);
    }
    for (const v of message.topics) {
      writer.uint32(18).string(v!);
    }
    if (message.data.length !== 0) {
      writer.uint32(26).bytes(message.data);
    }
    if (message.blockNumber !== 0) {
      writer.uint32(32).uint64(message.blockNumber);
    }
    if (message.txHash !== "") {
      writer.uint32(42).string(message.txHash);
    }
    if (message.txIndex !== 0) {
      writer.uint32(48).uint64(message.txIndex);
    }
    if (message.blockHash !== "") {
      writer.uint32(58).string(message.blockHash);
    }
    if (message.index !== 0) {
      writer.uint32(64).uint64(message.index);
    }
    if (message.removed !== false) {
      writer.uint32(72).bool(message.removed);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Log {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLog();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.address = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.topics.push(reader.string());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.data = reader.bytes();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.blockNumber = longToNumber(reader.uint64());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.txHash = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.txIndex = longToNumber(reader.uint64());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.blockHash = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.index = longToNumber(reader.uint64());
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.removed = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Log {
    return {
      address: isSet(object.address) ? globalThis.String(object.address) : "",
      topics: globalThis.Array.isArray(object?.topics) ? object.topics.map((e: any) => globalThis.String(e)) : [],
      data: isSet(object.data) ? bytesFromBase64(object.data) : new Uint8Array(0),
      blockNumber: isSet(object.blockNumber) ? globalThis.Number(object.blockNumber) : 0,
      txHash: isSet(object.txHash) ? globalThis.String(object.txHash) : "",
      txIndex: isSet(object.txIndex) ? globalThis.Number(object.txIndex) : 0,
      blockHash: isSet(object.blockHash) ? globalThis.String(object.blockHash) : "",
      index: isSet(object.index) ? globalThis.Number(object.index) : 0,
      removed: isSet(object.removed) ? globalThis.Boolean(object.removed) : false,
    };
  },

  toJSON(message: Log): unknown {
    const obj: any = {};
    if (message.address !== "") {
      obj.address = message.address;
    }
    if (message.topics?.length) {
      obj.topics = message.topics;
    }
    if (message.data.length !== 0) {
      obj.data = base64FromBytes(message.data);
    }
    if (message.blockNumber !== 0) {
      obj.blockNumber = Math.round(message.blockNumber);
    }
    if (message.txHash !== "") {
      obj.txHash = message.txHash;
    }
    if (message.txIndex !== 0) {
      obj.txIndex = Math.round(message.txIndex);
    }
    if (message.blockHash !== "") {
      obj.blockHash = message.blockHash;
    }
    if (message.index !== 0) {
      obj.index = Math.round(message.index);
    }
    if (message.removed !== false) {
      obj.removed = message.removed;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Log>, I>>(base?: I): Log {
    return Log.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Log>, I>>(object: I): Log {
    const message = createBaseLog();
    message.address = object.address ?? "";
    message.topics = object.topics?.map((e) => e) || [];
    message.data = object.data ?? new Uint8Array(0);
    message.blockNumber = object.blockNumber ?? 0;
    message.txHash = object.txHash ?? "";
    message.txIndex = object.txIndex ?? 0;
    message.blockHash = object.blockHash ?? "";
    message.index = object.index ?? 0;
    message.removed = object.removed ?? false;
    return message;
  },
};

function createBaseTxResult(): TxResult {
  return {
    contractAddress: "",
    bloom: new Uint8Array(0),
    txLogs: undefined,
    ret: new Uint8Array(0),
    reverted: false,
    gasUsed: 0,
  };
}

export const TxResult: MessageFns<TxResult> = {
  encode(message: TxResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.contractAddress !== "") {
      writer.uint32(10).string(message.contractAddress);
    }
    if (message.bloom.length !== 0) {
      writer.uint32(18).bytes(message.bloom);
    }
    if (message.txLogs !== undefined) {
      TransactionLogs.encode(message.txLogs, writer.uint32(26).fork()).join();
    }
    if (message.ret.length !== 0) {
      writer.uint32(34).bytes(message.ret);
    }
    if (message.reverted !== false) {
      writer.uint32(40).bool(message.reverted);
    }
    if (message.gasUsed !== 0) {
      writer.uint32(48).uint64(message.gasUsed);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TxResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTxResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.contractAddress = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.bloom = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.txLogs = TransactionLogs.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.ret = reader.bytes();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.reverted = reader.bool();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.gasUsed = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TxResult {
    return {
      contractAddress: isSet(object.contractAddress) ? globalThis.String(object.contractAddress) : "",
      bloom: isSet(object.bloom) ? bytesFromBase64(object.bloom) : new Uint8Array(0),
      txLogs: isSet(object.txLogs) ? TransactionLogs.fromJSON(object.txLogs) : undefined,
      ret: isSet(object.ret) ? bytesFromBase64(object.ret) : new Uint8Array(0),
      reverted: isSet(object.reverted) ? globalThis.Boolean(object.reverted) : false,
      gasUsed: isSet(object.gasUsed) ? globalThis.Number(object.gasUsed) : 0,
    };
  },

  toJSON(message: TxResult): unknown {
    const obj: any = {};
    if (message.contractAddress !== "") {
      obj.contractAddress = message.contractAddress;
    }
    if (message.bloom.length !== 0) {
      obj.bloom = base64FromBytes(message.bloom);
    }
    if (message.txLogs !== undefined) {
      obj.txLogs = TransactionLogs.toJSON(message.txLogs);
    }
    if (message.ret.length !== 0) {
      obj.ret = base64FromBytes(message.ret);
    }
    if (message.reverted !== false) {
      obj.reverted = message.reverted;
    }
    if (message.gasUsed !== 0) {
      obj.gasUsed = Math.round(message.gasUsed);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TxResult>, I>>(base?: I): TxResult {
    return TxResult.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TxResult>, I>>(object: I): TxResult {
    const message = createBaseTxResult();
    message.contractAddress = object.contractAddress ?? "";
    message.bloom = object.bloom ?? new Uint8Array(0);
    message.txLogs = (object.txLogs !== undefined && object.txLogs !== null)
      ? TransactionLogs.fromPartial(object.txLogs)
      : undefined;
    message.ret = object.ret ?? new Uint8Array(0);
    message.reverted = object.reverted ?? false;
    message.gasUsed = object.gasUsed ?? 0;
    return message;
  },
};

function createBaseAccessTuple(): AccessTuple {
  return { address: "", storageKeys: [] };
}

export const AccessTuple: MessageFns<AccessTuple> = {
  encode(message: AccessTuple, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.address !== "") {
      writer.uint32(10).string(message.address);
    }
    for (const v of message.storageKeys) {
      writer.uint32(18).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AccessTuple {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAccessTuple();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.address = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.storageKeys.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AccessTuple {
    return {
      address: isSet(object.address) ? globalThis.String(object.address) : "",
      storageKeys: globalThis.Array.isArray(object?.storageKeys)
        ? object.storageKeys.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: AccessTuple): unknown {
    const obj: any = {};
    if (message.address !== "") {
      obj.address = message.address;
    }
    if (message.storageKeys?.length) {
      obj.storageKeys = message.storageKeys;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AccessTuple>, I>>(base?: I): AccessTuple {
    return AccessTuple.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AccessTuple>, I>>(object: I): AccessTuple {
    const message = createBaseAccessTuple();
    message.address = object.address ?? "";
    message.storageKeys = object.storageKeys?.map((e) => e) || [];
    return message;
  },
};

function createBaseTraceConfig(): TraceConfig {
  return {
    tracer: "",
    timeout: "",
    reexec: 0,
    disableStack: false,
    disableStorage: false,
    debug: false,
    limit: 0,
    overrides: undefined,
    enableMemory: false,
    enableReturnData: false,
    tracerJsonConfig: "",
  };
}

export const TraceConfig: MessageFns<TraceConfig> = {
  encode(message: TraceConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.tracer !== "") {
      writer.uint32(10).string(message.tracer);
    }
    if (message.timeout !== "") {
      writer.uint32(18).string(message.timeout);
    }
    if (message.reexec !== 0) {
      writer.uint32(24).uint64(message.reexec);
    }
    if (message.disableStack !== false) {
      writer.uint32(40).bool(message.disableStack);
    }
    if (message.disableStorage !== false) {
      writer.uint32(48).bool(message.disableStorage);
    }
    if (message.debug !== false) {
      writer.uint32(64).bool(message.debug);
    }
    if (message.limit !== 0) {
      writer.uint32(72).int32(message.limit);
    }
    if (message.overrides !== undefined) {
      ChainConfig.encode(message.overrides, writer.uint32(82).fork()).join();
    }
    if (message.enableMemory !== false) {
      writer.uint32(88).bool(message.enableMemory);
    }
    if (message.enableReturnData !== false) {
      writer.uint32(96).bool(message.enableReturnData);
    }
    if (message.tracerJsonConfig !== "") {
      writer.uint32(106).string(message.tracerJsonConfig);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TraceConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTraceConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.tracer = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.timeout = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.reexec = longToNumber(reader.uint64());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.disableStack = reader.bool();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.disableStorage = reader.bool();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.debug = reader.bool();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.limit = reader.int32();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.overrides = ChainConfig.decode(reader, reader.uint32());
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.enableMemory = reader.bool();
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.enableReturnData = reader.bool();
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.tracerJsonConfig = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TraceConfig {
    return {
      tracer: isSet(object.tracer) ? globalThis.String(object.tracer) : "",
      timeout: isSet(object.timeout) ? globalThis.String(object.timeout) : "",
      reexec: isSet(object.reexec) ? globalThis.Number(object.reexec) : 0,
      disableStack: isSet(object.disableStack) ? globalThis.Boolean(object.disableStack) : false,
      disableStorage: isSet(object.disableStorage) ? globalThis.Boolean(object.disableStorage) : false,
      debug: isSet(object.debug) ? globalThis.Boolean(object.debug) : false,
      limit: isSet(object.limit) ? globalThis.Number(object.limit) : 0,
      overrides: isSet(object.overrides) ? ChainConfig.fromJSON(object.overrides) : undefined,
      enableMemory: isSet(object.enableMemory) ? globalThis.Boolean(object.enableMemory) : false,
      enableReturnData: isSet(object.enableReturnData) ? globalThis.Boolean(object.enableReturnData) : false,
      tracerJsonConfig: isSet(object.tracerJsonConfig) ? globalThis.String(object.tracerJsonConfig) : "",
    };
  },

  toJSON(message: TraceConfig): unknown {
    const obj: any = {};
    if (message.tracer !== "") {
      obj.tracer = message.tracer;
    }
    if (message.timeout !== "") {
      obj.timeout = message.timeout;
    }
    if (message.reexec !== 0) {
      obj.reexec = Math.round(message.reexec);
    }
    if (message.disableStack !== false) {
      obj.disableStack = message.disableStack;
    }
    if (message.disableStorage !== false) {
      obj.disableStorage = message.disableStorage;
    }
    if (message.debug !== false) {
      obj.debug = message.debug;
    }
    if (message.limit !== 0) {
      obj.limit = Math.round(message.limit);
    }
    if (message.overrides !== undefined) {
      obj.overrides = ChainConfig.toJSON(message.overrides);
    }
    if (message.enableMemory !== false) {
      obj.enableMemory = message.enableMemory;
    }
    if (message.enableReturnData !== false) {
      obj.enableReturnData = message.enableReturnData;
    }
    if (message.tracerJsonConfig !== "") {
      obj.tracerJsonConfig = message.tracerJsonConfig;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TraceConfig>, I>>(base?: I): TraceConfig {
    return TraceConfig.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TraceConfig>, I>>(object: I): TraceConfig {
    const message = createBaseTraceConfig();
    message.tracer = object.tracer ?? "";
    message.timeout = object.timeout ?? "";
    message.reexec = object.reexec ?? 0;
    message.disableStack = object.disableStack ?? false;
    message.disableStorage = object.disableStorage ?? false;
    message.debug = object.debug ?? false;
    message.limit = object.limit ?? 0;
    message.overrides = (object.overrides !== undefined && object.overrides !== null)
      ? ChainConfig.fromPartial(object.overrides)
      : undefined;
    message.enableMemory = object.enableMemory ?? false;
    message.enableReturnData = object.enableReturnData ?? false;
    message.tracerJsonConfig = object.tracerJsonConfig ?? "";
    return message;
  },
};

function bytesFromBase64(b64: string): Uint8Array {
  if ((globalThis as any).Buffer) {
    return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
  } else {
    const bin = globalThis.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}

function base64FromBytes(arr: Uint8Array): string {
  if ((globalThis as any).Buffer) {
    return globalThis.Buffer.from(arr).toString("base64");
  } else {
    const bin: string[] = [];
    arr.forEach((byte) => {
      bin.push(globalThis.String.fromCharCode(byte));
    });
    return globalThis.btoa(bin.join(""));
  }
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function longToNumber(int64: { toString(): string }): number {
  const num = globalThis.Number(int64.toString());
  if (num > globalThis.Number.MAX_SAFE_INTEGER) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (num < globalThis.Number.MIN_SAFE_INTEGER) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return num;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
