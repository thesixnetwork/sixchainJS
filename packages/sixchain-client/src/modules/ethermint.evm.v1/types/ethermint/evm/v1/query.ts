// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.6.1
//   protoc               unknown
// source: ethermint/evm/v1/query.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { PageRequest, PageResponse } from "../../../cosmos/base/query/v1beta1/pagination";
import { Timestamp } from "../../../google/protobuf/timestamp";
import { Log, Params, TraceConfig } from "./evm";
import { MsgEthereumTx, MsgEthereumTxResponse } from "./tx";

export const protobufPackage = "ethermint.evm.v1";

/**
 * Copyright Tharsis Labs Ltd.(Evmos)
 * SPDX-License-Identifier:ENCL-1.0(https://github.com/evmos/evmos/blob/main/LICENSE)
 */

/** QueryAccountRequest is the request type for the Query/Account RPC method. */
export interface QueryAccountRequest {
  /** address is the ethereum hex address to query the account for. */
  address: string;
}

/** QueryAccountResponse is the response type for the Query/Account RPC method. */
export interface QueryAccountResponse {
  /** balance is the balance of the EVM denomination. */
  balance: string;
  /** code_hash is the hex-formatted code bytes from the EOA. */
  codeHash: string;
  /** nonce is the account's sequence number. */
  nonce: number;
}

/**
 * QueryCosmosAccountRequest is the request type for the Query/CosmosAccount RPC
 * method.
 */
export interface QueryCosmosAccountRequest {
  /** address is the ethereum hex address to query the account for. */
  address: string;
}

/**
 * QueryCosmosAccountResponse is the response type for the Query/CosmosAccount
 * RPC method.
 */
export interface QueryCosmosAccountResponse {
  /** cosmos_address is the cosmos address of the account. */
  cosmosAddress: string;
  /** sequence is the account's sequence number. */
  sequence: number;
  /** account_number is the account number */
  accountNumber: number;
}

/**
 * QueryValidatorAccountRequest is the request type for the
 * Query/ValidatorAccount RPC method.
 */
export interface QueryValidatorAccountRequest {
  /** cons_address is the validator cons address to query the account for. */
  consAddress: string;
}

/**
 * QueryValidatorAccountResponse is the response type for the
 * Query/ValidatorAccount RPC method.
 */
export interface QueryValidatorAccountResponse {
  /** account_address is the cosmos address of the account in bech32 format. */
  accountAddress: string;
  /** sequence is the account's sequence number. */
  sequence: number;
  /** account_number is the account number */
  accountNumber: number;
}

/** QueryBalanceRequest is the request type for the Query/Balance RPC method. */
export interface QueryBalanceRequest {
  /** address is the ethereum hex address to query the balance for. */
  address: string;
}

/** QueryBalanceResponse is the response type for the Query/Balance RPC method. */
export interface QueryBalanceResponse {
  /** balance is the balance of the EVM denomination. */
  balance: string;
}

/** QueryStorageRequest is the request type for the Query/Storage RPC method. */
export interface QueryStorageRequest {
  /** address is the ethereum hex address to query the storage state for. */
  address: string;
  /** key defines the key of the storage state */
  key: string;
}

/**
 * QueryStorageResponse is the response type for the Query/Storage RPC
 * method.
 */
export interface QueryStorageResponse {
  /** value defines the storage state value hash associated with the given key. */
  value: string;
}

/** QueryCodeRequest is the request type for the Query/Code RPC method. */
export interface QueryCodeRequest {
  /** address is the ethereum hex address to query the code for. */
  address: string;
}

/**
 * QueryCodeResponse is the response type for the Query/Code RPC
 * method.
 */
export interface QueryCodeResponse {
  /** code represents the code bytes from an ethereum address. */
  code: Uint8Array;
}

/** QueryTxLogsRequest is the request type for the Query/TxLogs RPC method. */
export interface QueryTxLogsRequest {
  /** hash is the ethereum transaction hex hash to query the logs for. */
  hash: string;
  /** pagination defines an optional pagination for the request. */
  pagination: PageRequest | undefined;
}

/** QueryTxLogsResponse is the response type for the Query/TxLogs RPC method. */
export interface QueryTxLogsResponse {
  /** logs represents the ethereum logs generated from the given transaction. */
  logs: Log[];
  /** pagination defines the pagination in the response. */
  pagination: PageResponse | undefined;
}

/** QueryParamsRequest defines the request type for querying x/evm parameters. */
export interface QueryParamsRequest {
}

/** QueryParamsResponse defines the response type for querying x/evm parameters. */
export interface QueryParamsResponse {
  /** params define the evm module parameters. */
  params: Params | undefined;
}

/** EthCallRequest defines EthCall request */
export interface EthCallRequest {
  /** args uses the same json format as the json rpc api. */
  args: Uint8Array;
  /** gas_cap defines the default gas cap to be used */
  gasCap: number;
  /** proposer_address of the requested block in hex format */
  proposerAddress: Uint8Array;
  /** chain_id is the eip155 chain id parsed from the requested block header */
  chainId: number;
}

/** EthCallWithOverrideRequest defines EthCall request */
export interface EthCallWithOverrideRequest {
  /** args uses the same json format as the json rpc api. */
  args: Uint8Array;
  /** gas_cap defines the default gas cap to be used */
  gasCap: number;
  /** proposer_address of the requested block in hex format */
  proposerAddress: Uint8Array;
  /** chain_id is the eip155 chain id parsed from the requested block header */
  chainId: number;
  overrides: StateOverride | undefined;
}

/** EstimateGasResponse defines EstimateGas response */
export interface EstimateGasResponse {
  /** gas returns the estimated gas */
  gas: number;
  /**
   * ret is the returned data from evm function (result or data supplied with revert
   * opcode)
   */
  ret: Uint8Array;
  /** vm_error is the error returned by vm execution */
  vmError: string;
}

/** QueryTraceTxRequest defines TraceTx request */
export interface QueryTraceTxRequest {
  /** msg is the MsgEthereumTx for the requested transaction */
  msg:
    | MsgEthereumTx
    | undefined;
  /** trace_config holds extra parameters to trace functions. */
  traceConfig:
    | TraceConfig
    | undefined;
  /**
   * predecessors is an array of transactions included in the same block
   * need to be replayed first to get correct context for tracing.
   */
  predecessors: MsgEthereumTx[];
  /** block_number of requested transaction */
  blockNumber: number;
  /** block_hash of requested transaction */
  blockHash: string;
  /** block_time of requested transaction */
  blockTime:
    | Date
    | undefined;
  /** proposer_address is the proposer of the requested block */
  proposerAddress: Uint8Array;
  /** chain_id is the eip155 chain id parsed from the requested block header */
  chainId: number;
  /** block_max_gas of the block of the requested transaction */
  blockMaxGas: number;
}

/** QueryTraceTxResponse defines TraceTx response */
export interface QueryTraceTxResponse {
  /** data is the response serialized in bytes */
  data: Uint8Array;
}

/** QueryTraceBlockRequest defines TraceTx request */
export interface QueryTraceBlockRequest {
  /** txs is an array of messages in the block */
  txs: MsgEthereumTx[];
  /** trace_config holds extra parameters to trace functions. */
  traceConfig:
    | TraceConfig
    | undefined;
  /** block_number of the traced block */
  blockNumber: number;
  /** block_hash (hex) of the traced block */
  blockHash: string;
  /** block_time of the traced block */
  blockTime:
    | Date
    | undefined;
  /** proposer_address is the address of the requested block */
  proposerAddress: Uint8Array;
  /** chain_id is the eip155 chain id parsed from the requested block header */
  chainId: number;
  /** block_max_gas of the traced block */
  blockMaxGas: number;
}

/** QueryTraceBlockResponse defines TraceBlock response */
export interface QueryTraceBlockResponse {
  /** data is the response serialized in bytes */
  data: Uint8Array;
}

/**
 * QueryBaseFeeRequest defines the request type for querying the EIP1559 base
 * fee.
 */
export interface QueryBaseFeeRequest {
}

/** QueryBaseFeeResponse returns the EIP1559 base fee. */
export interface QueryBaseFeeResponse {
  /** base_fee is the EIP1559 base fee */
  baseFee: string;
}

export interface OverrideAccount {
  nonce: number;
  code: Uint8Array;
  balance: string;
  state: { [key: string]: string };
  stateDiff: { [key: string]: string };
}

export interface OverrideAccount_StateEntry {
  key: string;
  value: string;
}

export interface OverrideAccount_StateDiffEntry {
  key: string;
  value: string;
}

/** StateOverride is a map of addresses to OverrideAccount. */
export interface StateOverride {
  accounts: { [key: string]: OverrideAccount };
}

export interface StateOverride_AccountsEntry {
  key: string;
  value: OverrideAccount | undefined;
}

export interface BlockOverrides {
  number: string;
  defficulty: string;
  time: number;
  gasLimit: number;
  coinbase: string;
  random: string;
  baseFee: string;
  blobBaseFee: string;
}

export interface TraceCallConfig {
  traceConfig: TraceConfig | undefined;
  stateOverrides: StateOverride | undefined;
  blockOverrieds: BlockOverrides | undefined;
}

function createBaseQueryAccountRequest(): QueryAccountRequest {
  return { address: "" };
}

export const QueryAccountRequest: MessageFns<QueryAccountRequest> = {
  encode(message: QueryAccountRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.address !== "") {
      writer.uint32(10).string(message.address);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryAccountRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryAccountRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.address = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryAccountRequest {
    return { address: isSet(object.address) ? globalThis.String(object.address) : "" };
  },

  toJSON(message: QueryAccountRequest): unknown {
    const obj: any = {};
    if (message.address !== "") {
      obj.address = message.address;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryAccountRequest>, I>>(base?: I): QueryAccountRequest {
    return QueryAccountRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryAccountRequest>, I>>(object: I): QueryAccountRequest {
    const message = createBaseQueryAccountRequest();
    message.address = object.address ?? "";
    return message;
  },
};

function createBaseQueryAccountResponse(): QueryAccountResponse {
  return { balance: "", codeHash: "", nonce: 0 };
}

export const QueryAccountResponse: MessageFns<QueryAccountResponse> = {
  encode(message: QueryAccountResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.balance !== "") {
      writer.uint32(10).string(message.balance);
    }
    if (message.codeHash !== "") {
      writer.uint32(18).string(message.codeHash);
    }
    if (message.nonce !== 0) {
      writer.uint32(24).uint64(message.nonce);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryAccountResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryAccountResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.balance = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.codeHash = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.nonce = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryAccountResponse {
    return {
      balance: isSet(object.balance) ? globalThis.String(object.balance) : "",
      codeHash: isSet(object.codeHash) ? globalThis.String(object.codeHash) : "",
      nonce: isSet(object.nonce) ? globalThis.Number(object.nonce) : 0,
    };
  },

  toJSON(message: QueryAccountResponse): unknown {
    const obj: any = {};
    if (message.balance !== "") {
      obj.balance = message.balance;
    }
    if (message.codeHash !== "") {
      obj.codeHash = message.codeHash;
    }
    if (message.nonce !== 0) {
      obj.nonce = Math.round(message.nonce);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryAccountResponse>, I>>(base?: I): QueryAccountResponse {
    return QueryAccountResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryAccountResponse>, I>>(object: I): QueryAccountResponse {
    const message = createBaseQueryAccountResponse();
    message.balance = object.balance ?? "";
    message.codeHash = object.codeHash ?? "";
    message.nonce = object.nonce ?? 0;
    return message;
  },
};

function createBaseQueryCosmosAccountRequest(): QueryCosmosAccountRequest {
  return { address: "" };
}

export const QueryCosmosAccountRequest: MessageFns<QueryCosmosAccountRequest> = {
  encode(message: QueryCosmosAccountRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.address !== "") {
      writer.uint32(10).string(message.address);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryCosmosAccountRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryCosmosAccountRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.address = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryCosmosAccountRequest {
    return { address: isSet(object.address) ? globalThis.String(object.address) : "" };
  },

  toJSON(message: QueryCosmosAccountRequest): unknown {
    const obj: any = {};
    if (message.address !== "") {
      obj.address = message.address;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryCosmosAccountRequest>, I>>(base?: I): QueryCosmosAccountRequest {
    return QueryCosmosAccountRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryCosmosAccountRequest>, I>>(object: I): QueryCosmosAccountRequest {
    const message = createBaseQueryCosmosAccountRequest();
    message.address = object.address ?? "";
    return message;
  },
};

function createBaseQueryCosmosAccountResponse(): QueryCosmosAccountResponse {
  return { cosmosAddress: "", sequence: 0, accountNumber: 0 };
}

export const QueryCosmosAccountResponse: MessageFns<QueryCosmosAccountResponse> = {
  encode(message: QueryCosmosAccountResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.cosmosAddress !== "") {
      writer.uint32(10).string(message.cosmosAddress);
    }
    if (message.sequence !== 0) {
      writer.uint32(16).uint64(message.sequence);
    }
    if (message.accountNumber !== 0) {
      writer.uint32(24).uint64(message.accountNumber);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryCosmosAccountResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryCosmosAccountResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.cosmosAddress = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.sequence = longToNumber(reader.uint64());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.accountNumber = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryCosmosAccountResponse {
    return {
      cosmosAddress: isSet(object.cosmosAddress) ? globalThis.String(object.cosmosAddress) : "",
      sequence: isSet(object.sequence) ? globalThis.Number(object.sequence) : 0,
      accountNumber: isSet(object.accountNumber) ? globalThis.Number(object.accountNumber) : 0,
    };
  },

  toJSON(message: QueryCosmosAccountResponse): unknown {
    const obj: any = {};
    if (message.cosmosAddress !== "") {
      obj.cosmosAddress = message.cosmosAddress;
    }
    if (message.sequence !== 0) {
      obj.sequence = Math.round(message.sequence);
    }
    if (message.accountNumber !== 0) {
      obj.accountNumber = Math.round(message.accountNumber);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryCosmosAccountResponse>, I>>(base?: I): QueryCosmosAccountResponse {
    return QueryCosmosAccountResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryCosmosAccountResponse>, I>>(object: I): QueryCosmosAccountResponse {
    const message = createBaseQueryCosmosAccountResponse();
    message.cosmosAddress = object.cosmosAddress ?? "";
    message.sequence = object.sequence ?? 0;
    message.accountNumber = object.accountNumber ?? 0;
    return message;
  },
};

function createBaseQueryValidatorAccountRequest(): QueryValidatorAccountRequest {
  return { consAddress: "" };
}

export const QueryValidatorAccountRequest: MessageFns<QueryValidatorAccountRequest> = {
  encode(message: QueryValidatorAccountRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.consAddress !== "") {
      writer.uint32(10).string(message.consAddress);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryValidatorAccountRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryValidatorAccountRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.consAddress = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryValidatorAccountRequest {
    return { consAddress: isSet(object.consAddress) ? globalThis.String(object.consAddress) : "" };
  },

  toJSON(message: QueryValidatorAccountRequest): unknown {
    const obj: any = {};
    if (message.consAddress !== "") {
      obj.consAddress = message.consAddress;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryValidatorAccountRequest>, I>>(base?: I): QueryValidatorAccountRequest {
    return QueryValidatorAccountRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryValidatorAccountRequest>, I>>(object: I): QueryValidatorAccountRequest {
    const message = createBaseQueryValidatorAccountRequest();
    message.consAddress = object.consAddress ?? "";
    return message;
  },
};

function createBaseQueryValidatorAccountResponse(): QueryValidatorAccountResponse {
  return { accountAddress: "", sequence: 0, accountNumber: 0 };
}

export const QueryValidatorAccountResponse: MessageFns<QueryValidatorAccountResponse> = {
  encode(message: QueryValidatorAccountResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.accountAddress !== "") {
      writer.uint32(10).string(message.accountAddress);
    }
    if (message.sequence !== 0) {
      writer.uint32(16).uint64(message.sequence);
    }
    if (message.accountNumber !== 0) {
      writer.uint32(24).uint64(message.accountNumber);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryValidatorAccountResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryValidatorAccountResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.accountAddress = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.sequence = longToNumber(reader.uint64());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.accountNumber = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryValidatorAccountResponse {
    return {
      accountAddress: isSet(object.accountAddress) ? globalThis.String(object.accountAddress) : "",
      sequence: isSet(object.sequence) ? globalThis.Number(object.sequence) : 0,
      accountNumber: isSet(object.accountNumber) ? globalThis.Number(object.accountNumber) : 0,
    };
  },

  toJSON(message: QueryValidatorAccountResponse): unknown {
    const obj: any = {};
    if (message.accountAddress !== "") {
      obj.accountAddress = message.accountAddress;
    }
    if (message.sequence !== 0) {
      obj.sequence = Math.round(message.sequence);
    }
    if (message.accountNumber !== 0) {
      obj.accountNumber = Math.round(message.accountNumber);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryValidatorAccountResponse>, I>>(base?: I): QueryValidatorAccountResponse {
    return QueryValidatorAccountResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryValidatorAccountResponse>, I>>(
    object: I,
  ): QueryValidatorAccountResponse {
    const message = createBaseQueryValidatorAccountResponse();
    message.accountAddress = object.accountAddress ?? "";
    message.sequence = object.sequence ?? 0;
    message.accountNumber = object.accountNumber ?? 0;
    return message;
  },
};

function createBaseQueryBalanceRequest(): QueryBalanceRequest {
  return { address: "" };
}

export const QueryBalanceRequest: MessageFns<QueryBalanceRequest> = {
  encode(message: QueryBalanceRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.address !== "") {
      writer.uint32(10).string(message.address);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryBalanceRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryBalanceRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.address = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryBalanceRequest {
    return { address: isSet(object.address) ? globalThis.String(object.address) : "" };
  },

  toJSON(message: QueryBalanceRequest): unknown {
    const obj: any = {};
    if (message.address !== "") {
      obj.address = message.address;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryBalanceRequest>, I>>(base?: I): QueryBalanceRequest {
    return QueryBalanceRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryBalanceRequest>, I>>(object: I): QueryBalanceRequest {
    const message = createBaseQueryBalanceRequest();
    message.address = object.address ?? "";
    return message;
  },
};

function createBaseQueryBalanceResponse(): QueryBalanceResponse {
  return { balance: "" };
}

export const QueryBalanceResponse: MessageFns<QueryBalanceResponse> = {
  encode(message: QueryBalanceResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.balance !== "") {
      writer.uint32(10).string(message.balance);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryBalanceResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryBalanceResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.balance = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryBalanceResponse {
    return { balance: isSet(object.balance) ? globalThis.String(object.balance) : "" };
  },

  toJSON(message: QueryBalanceResponse): unknown {
    const obj: any = {};
    if (message.balance !== "") {
      obj.balance = message.balance;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryBalanceResponse>, I>>(base?: I): QueryBalanceResponse {
    return QueryBalanceResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryBalanceResponse>, I>>(object: I): QueryBalanceResponse {
    const message = createBaseQueryBalanceResponse();
    message.balance = object.balance ?? "";
    return message;
  },
};

function createBaseQueryStorageRequest(): QueryStorageRequest {
  return { address: "", key: "" };
}

export const QueryStorageRequest: MessageFns<QueryStorageRequest> = {
  encode(message: QueryStorageRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.address !== "") {
      writer.uint32(10).string(message.address);
    }
    if (message.key !== "") {
      writer.uint32(18).string(message.key);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryStorageRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryStorageRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.address = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.key = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryStorageRequest {
    return {
      address: isSet(object.address) ? globalThis.String(object.address) : "",
      key: isSet(object.key) ? globalThis.String(object.key) : "",
    };
  },

  toJSON(message: QueryStorageRequest): unknown {
    const obj: any = {};
    if (message.address !== "") {
      obj.address = message.address;
    }
    if (message.key !== "") {
      obj.key = message.key;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryStorageRequest>, I>>(base?: I): QueryStorageRequest {
    return QueryStorageRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryStorageRequest>, I>>(object: I): QueryStorageRequest {
    const message = createBaseQueryStorageRequest();
    message.address = object.address ?? "";
    message.key = object.key ?? "";
    return message;
  },
};

function createBaseQueryStorageResponse(): QueryStorageResponse {
  return { value: "" };
}

export const QueryStorageResponse: MessageFns<QueryStorageResponse> = {
  encode(message: QueryStorageResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.value !== "") {
      writer.uint32(10).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryStorageResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryStorageResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryStorageResponse {
    return { value: isSet(object.value) ? globalThis.String(object.value) : "" };
  },

  toJSON(message: QueryStorageResponse): unknown {
    const obj: any = {};
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryStorageResponse>, I>>(base?: I): QueryStorageResponse {
    return QueryStorageResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryStorageResponse>, I>>(object: I): QueryStorageResponse {
    const message = createBaseQueryStorageResponse();
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseQueryCodeRequest(): QueryCodeRequest {
  return { address: "" };
}

export const QueryCodeRequest: MessageFns<QueryCodeRequest> = {
  encode(message: QueryCodeRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.address !== "") {
      writer.uint32(10).string(message.address);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryCodeRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryCodeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.address = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryCodeRequest {
    return { address: isSet(object.address) ? globalThis.String(object.address) : "" };
  },

  toJSON(message: QueryCodeRequest): unknown {
    const obj: any = {};
    if (message.address !== "") {
      obj.address = message.address;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryCodeRequest>, I>>(base?: I): QueryCodeRequest {
    return QueryCodeRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryCodeRequest>, I>>(object: I): QueryCodeRequest {
    const message = createBaseQueryCodeRequest();
    message.address = object.address ?? "";
    return message;
  },
};

function createBaseQueryCodeResponse(): QueryCodeResponse {
  return { code: new Uint8Array(0) };
}

export const QueryCodeResponse: MessageFns<QueryCodeResponse> = {
  encode(message: QueryCodeResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.code.length !== 0) {
      writer.uint32(10).bytes(message.code);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryCodeResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryCodeResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.code = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryCodeResponse {
    return { code: isSet(object.code) ? bytesFromBase64(object.code) : new Uint8Array(0) };
  },

  toJSON(message: QueryCodeResponse): unknown {
    const obj: any = {};
    if (message.code.length !== 0) {
      obj.code = base64FromBytes(message.code);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryCodeResponse>, I>>(base?: I): QueryCodeResponse {
    return QueryCodeResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryCodeResponse>, I>>(object: I): QueryCodeResponse {
    const message = createBaseQueryCodeResponse();
    message.code = object.code ?? new Uint8Array(0);
    return message;
  },
};

function createBaseQueryTxLogsRequest(): QueryTxLogsRequest {
  return { hash: "", pagination: undefined };
}

export const QueryTxLogsRequest: MessageFns<QueryTxLogsRequest> = {
  encode(message: QueryTxLogsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.hash !== "") {
      writer.uint32(10).string(message.hash);
    }
    if (message.pagination !== undefined) {
      PageRequest.encode(message.pagination, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryTxLogsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryTxLogsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.hash = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pagination = PageRequest.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryTxLogsRequest {
    return {
      hash: isSet(object.hash) ? globalThis.String(object.hash) : "",
      pagination: isSet(object.pagination) ? PageRequest.fromJSON(object.pagination) : undefined,
    };
  },

  toJSON(message: QueryTxLogsRequest): unknown {
    const obj: any = {};
    if (message.hash !== "") {
      obj.hash = message.hash;
    }
    if (message.pagination !== undefined) {
      obj.pagination = PageRequest.toJSON(message.pagination);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryTxLogsRequest>, I>>(base?: I): QueryTxLogsRequest {
    return QueryTxLogsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryTxLogsRequest>, I>>(object: I): QueryTxLogsRequest {
    const message = createBaseQueryTxLogsRequest();
    message.hash = object.hash ?? "";
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? PageRequest.fromPartial(object.pagination)
      : undefined;
    return message;
  },
};

function createBaseQueryTxLogsResponse(): QueryTxLogsResponse {
  return { logs: [], pagination: undefined };
}

export const QueryTxLogsResponse: MessageFns<QueryTxLogsResponse> = {
  encode(message: QueryTxLogsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.logs) {
      Log.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.pagination !== undefined) {
      PageResponse.encode(message.pagination, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryTxLogsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryTxLogsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.logs.push(Log.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pagination = PageResponse.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryTxLogsResponse {
    return {
      logs: globalThis.Array.isArray(object?.logs) ? object.logs.map((e: any) => Log.fromJSON(e)) : [],
      pagination: isSet(object.pagination) ? PageResponse.fromJSON(object.pagination) : undefined,
    };
  },

  toJSON(message: QueryTxLogsResponse): unknown {
    const obj: any = {};
    if (message.logs?.length) {
      obj.logs = message.logs.map((e) => Log.toJSON(e));
    }
    if (message.pagination !== undefined) {
      obj.pagination = PageResponse.toJSON(message.pagination);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryTxLogsResponse>, I>>(base?: I): QueryTxLogsResponse {
    return QueryTxLogsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryTxLogsResponse>, I>>(object: I): QueryTxLogsResponse {
    const message = createBaseQueryTxLogsResponse();
    message.logs = object.logs?.map((e) => Log.fromPartial(e)) || [];
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? PageResponse.fromPartial(object.pagination)
      : undefined;
    return message;
  },
};

function createBaseQueryParamsRequest(): QueryParamsRequest {
  return {};
}

export const QueryParamsRequest: MessageFns<QueryParamsRequest> = {
  encode(_: QueryParamsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryParamsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryParamsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): QueryParamsRequest {
    return {};
  },

  toJSON(_: QueryParamsRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryParamsRequest>, I>>(base?: I): QueryParamsRequest {
    return QueryParamsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryParamsRequest>, I>>(_: I): QueryParamsRequest {
    const message = createBaseQueryParamsRequest();
    return message;
  },
};

function createBaseQueryParamsResponse(): QueryParamsResponse {
  return { params: undefined };
}

export const QueryParamsResponse: MessageFns<QueryParamsResponse> = {
  encode(message: QueryParamsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.params !== undefined) {
      Params.encode(message.params, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryParamsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryParamsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.params = Params.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryParamsResponse {
    return { params: isSet(object.params) ? Params.fromJSON(object.params) : undefined };
  },

  toJSON(message: QueryParamsResponse): unknown {
    const obj: any = {};
    if (message.params !== undefined) {
      obj.params = Params.toJSON(message.params);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryParamsResponse>, I>>(base?: I): QueryParamsResponse {
    return QueryParamsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryParamsResponse>, I>>(object: I): QueryParamsResponse {
    const message = createBaseQueryParamsResponse();
    message.params = (object.params !== undefined && object.params !== null)
      ? Params.fromPartial(object.params)
      : undefined;
    return message;
  },
};

function createBaseEthCallRequest(): EthCallRequest {
  return { args: new Uint8Array(0), gasCap: 0, proposerAddress: new Uint8Array(0), chainId: 0 };
}

export const EthCallRequest: MessageFns<EthCallRequest> = {
  encode(message: EthCallRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.args.length !== 0) {
      writer.uint32(10).bytes(message.args);
    }
    if (message.gasCap !== 0) {
      writer.uint32(16).uint64(message.gasCap);
    }
    if (message.proposerAddress.length !== 0) {
      writer.uint32(26).bytes(message.proposerAddress);
    }
    if (message.chainId !== 0) {
      writer.uint32(32).int64(message.chainId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EthCallRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEthCallRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.args = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.gasCap = longToNumber(reader.uint64());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.proposerAddress = reader.bytes();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.chainId = longToNumber(reader.int64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EthCallRequest {
    return {
      args: isSet(object.args) ? bytesFromBase64(object.args) : new Uint8Array(0),
      gasCap: isSet(object.gasCap) ? globalThis.Number(object.gasCap) : 0,
      proposerAddress: isSet(object.proposerAddress) ? bytesFromBase64(object.proposerAddress) : new Uint8Array(0),
      chainId: isSet(object.chainId) ? globalThis.Number(object.chainId) : 0,
    };
  },

  toJSON(message: EthCallRequest): unknown {
    const obj: any = {};
    if (message.args.length !== 0) {
      obj.args = base64FromBytes(message.args);
    }
    if (message.gasCap !== 0) {
      obj.gasCap = Math.round(message.gasCap);
    }
    if (message.proposerAddress.length !== 0) {
      obj.proposerAddress = base64FromBytes(message.proposerAddress);
    }
    if (message.chainId !== 0) {
      obj.chainId = Math.round(message.chainId);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EthCallRequest>, I>>(base?: I): EthCallRequest {
    return EthCallRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EthCallRequest>, I>>(object: I): EthCallRequest {
    const message = createBaseEthCallRequest();
    message.args = object.args ?? new Uint8Array(0);
    message.gasCap = object.gasCap ?? 0;
    message.proposerAddress = object.proposerAddress ?? new Uint8Array(0);
    message.chainId = object.chainId ?? 0;
    return message;
  },
};

function createBaseEthCallWithOverrideRequest(): EthCallWithOverrideRequest {
  return { args: new Uint8Array(0), gasCap: 0, proposerAddress: new Uint8Array(0), chainId: 0, overrides: undefined };
}

export const EthCallWithOverrideRequest: MessageFns<EthCallWithOverrideRequest> = {
  encode(message: EthCallWithOverrideRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.args.length !== 0) {
      writer.uint32(10).bytes(message.args);
    }
    if (message.gasCap !== 0) {
      writer.uint32(16).uint64(message.gasCap);
    }
    if (message.proposerAddress.length !== 0) {
      writer.uint32(26).bytes(message.proposerAddress);
    }
    if (message.chainId !== 0) {
      writer.uint32(32).int64(message.chainId);
    }
    if (message.overrides !== undefined) {
      StateOverride.encode(message.overrides, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EthCallWithOverrideRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEthCallWithOverrideRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.args = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.gasCap = longToNumber(reader.uint64());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.proposerAddress = reader.bytes();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.chainId = longToNumber(reader.int64());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.overrides = StateOverride.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EthCallWithOverrideRequest {
    return {
      args: isSet(object.args) ? bytesFromBase64(object.args) : new Uint8Array(0),
      gasCap: isSet(object.gasCap) ? globalThis.Number(object.gasCap) : 0,
      proposerAddress: isSet(object.proposerAddress) ? bytesFromBase64(object.proposerAddress) : new Uint8Array(0),
      chainId: isSet(object.chainId) ? globalThis.Number(object.chainId) : 0,
      overrides: isSet(object.overrides) ? StateOverride.fromJSON(object.overrides) : undefined,
    };
  },

  toJSON(message: EthCallWithOverrideRequest): unknown {
    const obj: any = {};
    if (message.args.length !== 0) {
      obj.args = base64FromBytes(message.args);
    }
    if (message.gasCap !== 0) {
      obj.gasCap = Math.round(message.gasCap);
    }
    if (message.proposerAddress.length !== 0) {
      obj.proposerAddress = base64FromBytes(message.proposerAddress);
    }
    if (message.chainId !== 0) {
      obj.chainId = Math.round(message.chainId);
    }
    if (message.overrides !== undefined) {
      obj.overrides = StateOverride.toJSON(message.overrides);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EthCallWithOverrideRequest>, I>>(base?: I): EthCallWithOverrideRequest {
    return EthCallWithOverrideRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EthCallWithOverrideRequest>, I>>(object: I): EthCallWithOverrideRequest {
    const message = createBaseEthCallWithOverrideRequest();
    message.args = object.args ?? new Uint8Array(0);
    message.gasCap = object.gasCap ?? 0;
    message.proposerAddress = object.proposerAddress ?? new Uint8Array(0);
    message.chainId = object.chainId ?? 0;
    message.overrides = (object.overrides !== undefined && object.overrides !== null)
      ? StateOverride.fromPartial(object.overrides)
      : undefined;
    return message;
  },
};

function createBaseEstimateGasResponse(): EstimateGasResponse {
  return { gas: 0, ret: new Uint8Array(0), vmError: "" };
}

export const EstimateGasResponse: MessageFns<EstimateGasResponse> = {
  encode(message: EstimateGasResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.gas !== 0) {
      writer.uint32(8).uint64(message.gas);
    }
    if (message.ret.length !== 0) {
      writer.uint32(18).bytes(message.ret);
    }
    if (message.vmError !== "") {
      writer.uint32(26).string(message.vmError);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EstimateGasResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEstimateGasResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.gas = longToNumber(reader.uint64());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.ret = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.vmError = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EstimateGasResponse {
    return {
      gas: isSet(object.gas) ? globalThis.Number(object.gas) : 0,
      ret: isSet(object.ret) ? bytesFromBase64(object.ret) : new Uint8Array(0),
      vmError: isSet(object.vmError) ? globalThis.String(object.vmError) : "",
    };
  },

  toJSON(message: EstimateGasResponse): unknown {
    const obj: any = {};
    if (message.gas !== 0) {
      obj.gas = Math.round(message.gas);
    }
    if (message.ret.length !== 0) {
      obj.ret = base64FromBytes(message.ret);
    }
    if (message.vmError !== "") {
      obj.vmError = message.vmError;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EstimateGasResponse>, I>>(base?: I): EstimateGasResponse {
    return EstimateGasResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EstimateGasResponse>, I>>(object: I): EstimateGasResponse {
    const message = createBaseEstimateGasResponse();
    message.gas = object.gas ?? 0;
    message.ret = object.ret ?? new Uint8Array(0);
    message.vmError = object.vmError ?? "";
    return message;
  },
};

function createBaseQueryTraceTxRequest(): QueryTraceTxRequest {
  return {
    msg: undefined,
    traceConfig: undefined,
    predecessors: [],
    blockNumber: 0,
    blockHash: "",
    blockTime: undefined,
    proposerAddress: new Uint8Array(0),
    chainId: 0,
    blockMaxGas: 0,
  };
}

export const QueryTraceTxRequest: MessageFns<QueryTraceTxRequest> = {
  encode(message: QueryTraceTxRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.msg !== undefined) {
      MsgEthereumTx.encode(message.msg, writer.uint32(10).fork()).join();
    }
    if (message.traceConfig !== undefined) {
      TraceConfig.encode(message.traceConfig, writer.uint32(26).fork()).join();
    }
    for (const v of message.predecessors) {
      MsgEthereumTx.encode(v!, writer.uint32(34).fork()).join();
    }
    if (message.blockNumber !== 0) {
      writer.uint32(40).int64(message.blockNumber);
    }
    if (message.blockHash !== "") {
      writer.uint32(50).string(message.blockHash);
    }
    if (message.blockTime !== undefined) {
      Timestamp.encode(toTimestamp(message.blockTime), writer.uint32(58).fork()).join();
    }
    if (message.proposerAddress.length !== 0) {
      writer.uint32(66).bytes(message.proposerAddress);
    }
    if (message.chainId !== 0) {
      writer.uint32(72).int64(message.chainId);
    }
    if (message.blockMaxGas !== 0) {
      writer.uint32(80).int64(message.blockMaxGas);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryTraceTxRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryTraceTxRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.msg = MsgEthereumTx.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.traceConfig = TraceConfig.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.predecessors.push(MsgEthereumTx.decode(reader, reader.uint32()));
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.blockNumber = longToNumber(reader.int64());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.blockHash = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.blockTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.proposerAddress = reader.bytes();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.chainId = longToNumber(reader.int64());
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.blockMaxGas = longToNumber(reader.int64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryTraceTxRequest {
    return {
      msg: isSet(object.msg) ? MsgEthereumTx.fromJSON(object.msg) : undefined,
      traceConfig: isSet(object.traceConfig) ? TraceConfig.fromJSON(object.traceConfig) : undefined,
      predecessors: globalThis.Array.isArray(object?.predecessors)
        ? object.predecessors.map((e: any) => MsgEthereumTx.fromJSON(e))
        : [],
      blockNumber: isSet(object.blockNumber) ? globalThis.Number(object.blockNumber) : 0,
      blockHash: isSet(object.blockHash) ? globalThis.String(object.blockHash) : "",
      blockTime: isSet(object.blockTime) ? fromJsonTimestamp(object.blockTime) : undefined,
      proposerAddress: isSet(object.proposerAddress) ? bytesFromBase64(object.proposerAddress) : new Uint8Array(0),
      chainId: isSet(object.chainId) ? globalThis.Number(object.chainId) : 0,
      blockMaxGas: isSet(object.blockMaxGas) ? globalThis.Number(object.blockMaxGas) : 0,
    };
  },

  toJSON(message: QueryTraceTxRequest): unknown {
    const obj: any = {};
    if (message.msg !== undefined) {
      obj.msg = MsgEthereumTx.toJSON(message.msg);
    }
    if (message.traceConfig !== undefined) {
      obj.traceConfig = TraceConfig.toJSON(message.traceConfig);
    }
    if (message.predecessors?.length) {
      obj.predecessors = message.predecessors.map((e) => MsgEthereumTx.toJSON(e));
    }
    if (message.blockNumber !== 0) {
      obj.blockNumber = Math.round(message.blockNumber);
    }
    if (message.blockHash !== "") {
      obj.blockHash = message.blockHash;
    }
    if (message.blockTime !== undefined) {
      obj.blockTime = message.blockTime.toISOString();
    }
    if (message.proposerAddress.length !== 0) {
      obj.proposerAddress = base64FromBytes(message.proposerAddress);
    }
    if (message.chainId !== 0) {
      obj.chainId = Math.round(message.chainId);
    }
    if (message.blockMaxGas !== 0) {
      obj.blockMaxGas = Math.round(message.blockMaxGas);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryTraceTxRequest>, I>>(base?: I): QueryTraceTxRequest {
    return QueryTraceTxRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryTraceTxRequest>, I>>(object: I): QueryTraceTxRequest {
    const message = createBaseQueryTraceTxRequest();
    message.msg = (object.msg !== undefined && object.msg !== null) ? MsgEthereumTx.fromPartial(object.msg) : undefined;
    message.traceConfig = (object.traceConfig !== undefined && object.traceConfig !== null)
      ? TraceConfig.fromPartial(object.traceConfig)
      : undefined;
    message.predecessors = object.predecessors?.map((e) => MsgEthereumTx.fromPartial(e)) || [];
    message.blockNumber = object.blockNumber ?? 0;
    message.blockHash = object.blockHash ?? "";
    message.blockTime = object.blockTime ?? undefined;
    message.proposerAddress = object.proposerAddress ?? new Uint8Array(0);
    message.chainId = object.chainId ?? 0;
    message.blockMaxGas = object.blockMaxGas ?? 0;
    return message;
  },
};

function createBaseQueryTraceTxResponse(): QueryTraceTxResponse {
  return { data: new Uint8Array(0) };
}

export const QueryTraceTxResponse: MessageFns<QueryTraceTxResponse> = {
  encode(message: QueryTraceTxResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.data.length !== 0) {
      writer.uint32(10).bytes(message.data);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryTraceTxResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryTraceTxResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.data = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryTraceTxResponse {
    return { data: isSet(object.data) ? bytesFromBase64(object.data) : new Uint8Array(0) };
  },

  toJSON(message: QueryTraceTxResponse): unknown {
    const obj: any = {};
    if (message.data.length !== 0) {
      obj.data = base64FromBytes(message.data);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryTraceTxResponse>, I>>(base?: I): QueryTraceTxResponse {
    return QueryTraceTxResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryTraceTxResponse>, I>>(object: I): QueryTraceTxResponse {
    const message = createBaseQueryTraceTxResponse();
    message.data = object.data ?? new Uint8Array(0);
    return message;
  },
};

function createBaseQueryTraceBlockRequest(): QueryTraceBlockRequest {
  return {
    txs: [],
    traceConfig: undefined,
    blockNumber: 0,
    blockHash: "",
    blockTime: undefined,
    proposerAddress: new Uint8Array(0),
    chainId: 0,
    blockMaxGas: 0,
  };
}

export const QueryTraceBlockRequest: MessageFns<QueryTraceBlockRequest> = {
  encode(message: QueryTraceBlockRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.txs) {
      MsgEthereumTx.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.traceConfig !== undefined) {
      TraceConfig.encode(message.traceConfig, writer.uint32(26).fork()).join();
    }
    if (message.blockNumber !== 0) {
      writer.uint32(40).int64(message.blockNumber);
    }
    if (message.blockHash !== "") {
      writer.uint32(50).string(message.blockHash);
    }
    if (message.blockTime !== undefined) {
      Timestamp.encode(toTimestamp(message.blockTime), writer.uint32(58).fork()).join();
    }
    if (message.proposerAddress.length !== 0) {
      writer.uint32(66).bytes(message.proposerAddress);
    }
    if (message.chainId !== 0) {
      writer.uint32(72).int64(message.chainId);
    }
    if (message.blockMaxGas !== 0) {
      writer.uint32(80).int64(message.blockMaxGas);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryTraceBlockRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryTraceBlockRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.txs.push(MsgEthereumTx.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.traceConfig = TraceConfig.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.blockNumber = longToNumber(reader.int64());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.blockHash = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.blockTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.proposerAddress = reader.bytes();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.chainId = longToNumber(reader.int64());
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.blockMaxGas = longToNumber(reader.int64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryTraceBlockRequest {
    return {
      txs: globalThis.Array.isArray(object?.txs) ? object.txs.map((e: any) => MsgEthereumTx.fromJSON(e)) : [],
      traceConfig: isSet(object.traceConfig) ? TraceConfig.fromJSON(object.traceConfig) : undefined,
      blockNumber: isSet(object.blockNumber) ? globalThis.Number(object.blockNumber) : 0,
      blockHash: isSet(object.blockHash) ? globalThis.String(object.blockHash) : "",
      blockTime: isSet(object.blockTime) ? fromJsonTimestamp(object.blockTime) : undefined,
      proposerAddress: isSet(object.proposerAddress) ? bytesFromBase64(object.proposerAddress) : new Uint8Array(0),
      chainId: isSet(object.chainId) ? globalThis.Number(object.chainId) : 0,
      blockMaxGas: isSet(object.blockMaxGas) ? globalThis.Number(object.blockMaxGas) : 0,
    };
  },

  toJSON(message: QueryTraceBlockRequest): unknown {
    const obj: any = {};
    if (message.txs?.length) {
      obj.txs = message.txs.map((e) => MsgEthereumTx.toJSON(e));
    }
    if (message.traceConfig !== undefined) {
      obj.traceConfig = TraceConfig.toJSON(message.traceConfig);
    }
    if (message.blockNumber !== 0) {
      obj.blockNumber = Math.round(message.blockNumber);
    }
    if (message.blockHash !== "") {
      obj.blockHash = message.blockHash;
    }
    if (message.blockTime !== undefined) {
      obj.blockTime = message.blockTime.toISOString();
    }
    if (message.proposerAddress.length !== 0) {
      obj.proposerAddress = base64FromBytes(message.proposerAddress);
    }
    if (message.chainId !== 0) {
      obj.chainId = Math.round(message.chainId);
    }
    if (message.blockMaxGas !== 0) {
      obj.blockMaxGas = Math.round(message.blockMaxGas);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryTraceBlockRequest>, I>>(base?: I): QueryTraceBlockRequest {
    return QueryTraceBlockRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryTraceBlockRequest>, I>>(object: I): QueryTraceBlockRequest {
    const message = createBaseQueryTraceBlockRequest();
    message.txs = object.txs?.map((e) => MsgEthereumTx.fromPartial(e)) || [];
    message.traceConfig = (object.traceConfig !== undefined && object.traceConfig !== null)
      ? TraceConfig.fromPartial(object.traceConfig)
      : undefined;
    message.blockNumber = object.blockNumber ?? 0;
    message.blockHash = object.blockHash ?? "";
    message.blockTime = object.blockTime ?? undefined;
    message.proposerAddress = object.proposerAddress ?? new Uint8Array(0);
    message.chainId = object.chainId ?? 0;
    message.blockMaxGas = object.blockMaxGas ?? 0;
    return message;
  },
};

function createBaseQueryTraceBlockResponse(): QueryTraceBlockResponse {
  return { data: new Uint8Array(0) };
}

export const QueryTraceBlockResponse: MessageFns<QueryTraceBlockResponse> = {
  encode(message: QueryTraceBlockResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.data.length !== 0) {
      writer.uint32(10).bytes(message.data);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryTraceBlockResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryTraceBlockResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.data = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryTraceBlockResponse {
    return { data: isSet(object.data) ? bytesFromBase64(object.data) : new Uint8Array(0) };
  },

  toJSON(message: QueryTraceBlockResponse): unknown {
    const obj: any = {};
    if (message.data.length !== 0) {
      obj.data = base64FromBytes(message.data);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryTraceBlockResponse>, I>>(base?: I): QueryTraceBlockResponse {
    return QueryTraceBlockResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryTraceBlockResponse>, I>>(object: I): QueryTraceBlockResponse {
    const message = createBaseQueryTraceBlockResponse();
    message.data = object.data ?? new Uint8Array(0);
    return message;
  },
};

function createBaseQueryBaseFeeRequest(): QueryBaseFeeRequest {
  return {};
}

export const QueryBaseFeeRequest: MessageFns<QueryBaseFeeRequest> = {
  encode(_: QueryBaseFeeRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryBaseFeeRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryBaseFeeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): QueryBaseFeeRequest {
    return {};
  },

  toJSON(_: QueryBaseFeeRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryBaseFeeRequest>, I>>(base?: I): QueryBaseFeeRequest {
    return QueryBaseFeeRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryBaseFeeRequest>, I>>(_: I): QueryBaseFeeRequest {
    const message = createBaseQueryBaseFeeRequest();
    return message;
  },
};

function createBaseQueryBaseFeeResponse(): QueryBaseFeeResponse {
  return { baseFee: "" };
}

export const QueryBaseFeeResponse: MessageFns<QueryBaseFeeResponse> = {
  encode(message: QueryBaseFeeResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.baseFee !== "") {
      writer.uint32(10).string(message.baseFee);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryBaseFeeResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryBaseFeeResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.baseFee = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryBaseFeeResponse {
    return { baseFee: isSet(object.baseFee) ? globalThis.String(object.baseFee) : "" };
  },

  toJSON(message: QueryBaseFeeResponse): unknown {
    const obj: any = {};
    if (message.baseFee !== "") {
      obj.baseFee = message.baseFee;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryBaseFeeResponse>, I>>(base?: I): QueryBaseFeeResponse {
    return QueryBaseFeeResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryBaseFeeResponse>, I>>(object: I): QueryBaseFeeResponse {
    const message = createBaseQueryBaseFeeResponse();
    message.baseFee = object.baseFee ?? "";
    return message;
  },
};

function createBaseOverrideAccount(): OverrideAccount {
  return { nonce: 0, code: new Uint8Array(0), balance: "", state: {}, stateDiff: {} };
}

export const OverrideAccount: MessageFns<OverrideAccount> = {
  encode(message: OverrideAccount, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.nonce !== 0) {
      writer.uint32(8).uint64(message.nonce);
    }
    if (message.code.length !== 0) {
      writer.uint32(18).bytes(message.code);
    }
    if (message.balance !== "") {
      writer.uint32(26).string(message.balance);
    }
    Object.entries(message.state).forEach(([key, value]) => {
      OverrideAccount_StateEntry.encode({ key: key as any, value }, writer.uint32(34).fork()).join();
    });
    Object.entries(message.stateDiff).forEach(([key, value]) => {
      OverrideAccount_StateDiffEntry.encode({ key: key as any, value }, writer.uint32(42).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OverrideAccount {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOverrideAccount();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.nonce = longToNumber(reader.uint64());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.code = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.balance = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          const entry4 = OverrideAccount_StateEntry.decode(reader, reader.uint32());
          if (entry4.value !== undefined) {
            message.state[entry4.key] = entry4.value;
          }
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          const entry5 = OverrideAccount_StateDiffEntry.decode(reader, reader.uint32());
          if (entry5.value !== undefined) {
            message.stateDiff[entry5.key] = entry5.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OverrideAccount {
    return {
      nonce: isSet(object.nonce) ? globalThis.Number(object.nonce) : 0,
      code: isSet(object.code) ? bytesFromBase64(object.code) : new Uint8Array(0),
      balance: isSet(object.balance) ? globalThis.String(object.balance) : "",
      state: isObject(object.state)
        ? Object.entries(object.state).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      stateDiff: isObject(object.stateDiff)
        ? Object.entries(object.stateDiff).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: OverrideAccount): unknown {
    const obj: any = {};
    if (message.nonce !== 0) {
      obj.nonce = Math.round(message.nonce);
    }
    if (message.code.length !== 0) {
      obj.code = base64FromBytes(message.code);
    }
    if (message.balance !== "") {
      obj.balance = message.balance;
    }
    if (message.state) {
      const entries = Object.entries(message.state);
      if (entries.length > 0) {
        obj.state = {};
        entries.forEach(([k, v]) => {
          obj.state[k] = v;
        });
      }
    }
    if (message.stateDiff) {
      const entries = Object.entries(message.stateDiff);
      if (entries.length > 0) {
        obj.stateDiff = {};
        entries.forEach(([k, v]) => {
          obj.stateDiff[k] = v;
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<OverrideAccount>, I>>(base?: I): OverrideAccount {
    return OverrideAccount.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<OverrideAccount>, I>>(object: I): OverrideAccount {
    const message = createBaseOverrideAccount();
    message.nonce = object.nonce ?? 0;
    message.code = object.code ?? new Uint8Array(0);
    message.balance = object.balance ?? "";
    message.state = Object.entries(object.state ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.stateDiff = Object.entries(object.stateDiff ?? {}).reduce<{ [key: string]: string }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseOverrideAccount_StateEntry(): OverrideAccount_StateEntry {
  return { key: "", value: "" };
}

export const OverrideAccount_StateEntry: MessageFns<OverrideAccount_StateEntry> = {
  encode(message: OverrideAccount_StateEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OverrideAccount_StateEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOverrideAccount_StateEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OverrideAccount_StateEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: OverrideAccount_StateEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<OverrideAccount_StateEntry>, I>>(base?: I): OverrideAccount_StateEntry {
    return OverrideAccount_StateEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<OverrideAccount_StateEntry>, I>>(object: I): OverrideAccount_StateEntry {
    const message = createBaseOverrideAccount_StateEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseOverrideAccount_StateDiffEntry(): OverrideAccount_StateDiffEntry {
  return { key: "", value: "" };
}

export const OverrideAccount_StateDiffEntry: MessageFns<OverrideAccount_StateDiffEntry> = {
  encode(message: OverrideAccount_StateDiffEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OverrideAccount_StateDiffEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOverrideAccount_StateDiffEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OverrideAccount_StateDiffEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: OverrideAccount_StateDiffEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<OverrideAccount_StateDiffEntry>, I>>(base?: I): OverrideAccount_StateDiffEntry {
    return OverrideAccount_StateDiffEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<OverrideAccount_StateDiffEntry>, I>>(
    object: I,
  ): OverrideAccount_StateDiffEntry {
    const message = createBaseOverrideAccount_StateDiffEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseStateOverride(): StateOverride {
  return { accounts: {} };
}

export const StateOverride: MessageFns<StateOverride> = {
  encode(message: StateOverride, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    Object.entries(message.accounts).forEach(([key, value]) => {
      StateOverride_AccountsEntry.encode({ key: key as any, value }, writer.uint32(10).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StateOverride {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStateOverride();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          const entry1 = StateOverride_AccountsEntry.decode(reader, reader.uint32());
          if (entry1.value !== undefined) {
            message.accounts[entry1.key] = entry1.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StateOverride {
    return {
      accounts: isObject(object.accounts)
        ? Object.entries(object.accounts).reduce<{ [key: string]: OverrideAccount }>((acc, [key, value]) => {
          acc[key] = OverrideAccount.fromJSON(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: StateOverride): unknown {
    const obj: any = {};
    if (message.accounts) {
      const entries = Object.entries(message.accounts);
      if (entries.length > 0) {
        obj.accounts = {};
        entries.forEach(([k, v]) => {
          obj.accounts[k] = OverrideAccount.toJSON(v);
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<StateOverride>, I>>(base?: I): StateOverride {
    return StateOverride.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<StateOverride>, I>>(object: I): StateOverride {
    const message = createBaseStateOverride();
    message.accounts = Object.entries(object.accounts ?? {}).reduce<{ [key: string]: OverrideAccount }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = OverrideAccount.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseStateOverride_AccountsEntry(): StateOverride_AccountsEntry {
  return { key: "", value: undefined };
}

export const StateOverride_AccountsEntry: MessageFns<StateOverride_AccountsEntry> = {
  encode(message: StateOverride_AccountsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      OverrideAccount.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StateOverride_AccountsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStateOverride_AccountsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = OverrideAccount.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StateOverride_AccountsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? OverrideAccount.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: StateOverride_AccountsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = OverrideAccount.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<StateOverride_AccountsEntry>, I>>(base?: I): StateOverride_AccountsEntry {
    return StateOverride_AccountsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<StateOverride_AccountsEntry>, I>>(object: I): StateOverride_AccountsEntry {
    const message = createBaseStateOverride_AccountsEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? OverrideAccount.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseBlockOverrides(): BlockOverrides {
  return { number: "", defficulty: "", time: 0, gasLimit: 0, coinbase: "", random: "", baseFee: "", blobBaseFee: "" };
}

export const BlockOverrides: MessageFns<BlockOverrides> = {
  encode(message: BlockOverrides, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.number !== "") {
      writer.uint32(10).string(message.number);
    }
    if (message.defficulty !== "") {
      writer.uint32(18).string(message.defficulty);
    }
    if (message.time !== 0) {
      writer.uint32(24).uint64(message.time);
    }
    if (message.gasLimit !== 0) {
      writer.uint32(32).uint64(message.gasLimit);
    }
    if (message.coinbase !== "") {
      writer.uint32(42).string(message.coinbase);
    }
    if (message.random !== "") {
      writer.uint32(50).string(message.random);
    }
    if (message.baseFee !== "") {
      writer.uint32(58).string(message.baseFee);
    }
    if (message.blobBaseFee !== "") {
      writer.uint32(66).string(message.blobBaseFee);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BlockOverrides {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBlockOverrides();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.number = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.defficulty = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.time = longToNumber(reader.uint64());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.gasLimit = longToNumber(reader.uint64());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.coinbase = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.random = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.baseFee = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.blobBaseFee = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BlockOverrides {
    return {
      number: isSet(object.number) ? globalThis.String(object.number) : "",
      defficulty: isSet(object.defficulty) ? globalThis.String(object.defficulty) : "",
      time: isSet(object.time) ? globalThis.Number(object.time) : 0,
      gasLimit: isSet(object.gasLimit) ? globalThis.Number(object.gasLimit) : 0,
      coinbase: isSet(object.coinbase) ? globalThis.String(object.coinbase) : "",
      random: isSet(object.random) ? globalThis.String(object.random) : "",
      baseFee: isSet(object.baseFee) ? globalThis.String(object.baseFee) : "",
      blobBaseFee: isSet(object.blobBaseFee) ? globalThis.String(object.blobBaseFee) : "",
    };
  },

  toJSON(message: BlockOverrides): unknown {
    const obj: any = {};
    if (message.number !== "") {
      obj.number = message.number;
    }
    if (message.defficulty !== "") {
      obj.defficulty = message.defficulty;
    }
    if (message.time !== 0) {
      obj.time = Math.round(message.time);
    }
    if (message.gasLimit !== 0) {
      obj.gasLimit = Math.round(message.gasLimit);
    }
    if (message.coinbase !== "") {
      obj.coinbase = message.coinbase;
    }
    if (message.random !== "") {
      obj.random = message.random;
    }
    if (message.baseFee !== "") {
      obj.baseFee = message.baseFee;
    }
    if (message.blobBaseFee !== "") {
      obj.blobBaseFee = message.blobBaseFee;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BlockOverrides>, I>>(base?: I): BlockOverrides {
    return BlockOverrides.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BlockOverrides>, I>>(object: I): BlockOverrides {
    const message = createBaseBlockOverrides();
    message.number = object.number ?? "";
    message.defficulty = object.defficulty ?? "";
    message.time = object.time ?? 0;
    message.gasLimit = object.gasLimit ?? 0;
    message.coinbase = object.coinbase ?? "";
    message.random = object.random ?? "";
    message.baseFee = object.baseFee ?? "";
    message.blobBaseFee = object.blobBaseFee ?? "";
    return message;
  },
};

function createBaseTraceCallConfig(): TraceCallConfig {
  return { traceConfig: undefined, stateOverrides: undefined, blockOverrieds: undefined };
}

export const TraceCallConfig: MessageFns<TraceCallConfig> = {
  encode(message: TraceCallConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.traceConfig !== undefined) {
      TraceConfig.encode(message.traceConfig, writer.uint32(10).fork()).join();
    }
    if (message.stateOverrides !== undefined) {
      StateOverride.encode(message.stateOverrides, writer.uint32(18).fork()).join();
    }
    if (message.blockOverrieds !== undefined) {
      BlockOverrides.encode(message.blockOverrieds, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TraceCallConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTraceCallConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.traceConfig = TraceConfig.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.stateOverrides = StateOverride.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.blockOverrieds = BlockOverrides.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TraceCallConfig {
    return {
      traceConfig: isSet(object.traceConfig) ? TraceConfig.fromJSON(object.traceConfig) : undefined,
      stateOverrides: isSet(object.stateOverrides) ? StateOverride.fromJSON(object.stateOverrides) : undefined,
      blockOverrieds: isSet(object.blockOverrieds) ? BlockOverrides.fromJSON(object.blockOverrieds) : undefined,
    };
  },

  toJSON(message: TraceCallConfig): unknown {
    const obj: any = {};
    if (message.traceConfig !== undefined) {
      obj.traceConfig = TraceConfig.toJSON(message.traceConfig);
    }
    if (message.stateOverrides !== undefined) {
      obj.stateOverrides = StateOverride.toJSON(message.stateOverrides);
    }
    if (message.blockOverrieds !== undefined) {
      obj.blockOverrieds = BlockOverrides.toJSON(message.blockOverrieds);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TraceCallConfig>, I>>(base?: I): TraceCallConfig {
    return TraceCallConfig.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TraceCallConfig>, I>>(object: I): TraceCallConfig {
    const message = createBaseTraceCallConfig();
    message.traceConfig = (object.traceConfig !== undefined && object.traceConfig !== null)
      ? TraceConfig.fromPartial(object.traceConfig)
      : undefined;
    message.stateOverrides = (object.stateOverrides !== undefined && object.stateOverrides !== null)
      ? StateOverride.fromPartial(object.stateOverrides)
      : undefined;
    message.blockOverrieds = (object.blockOverrieds !== undefined && object.blockOverrieds !== null)
      ? BlockOverrides.fromPartial(object.blockOverrieds)
      : undefined;
    return message;
  },
};

/** Query defines the gRPC querier service. */
export interface Query {
  /** Account queries an Ethereum account. */
  Account(request: QueryAccountRequest): Promise<QueryAccountResponse>;
  /** CosmosAccount queries an Ethereum account's Cosmos Address. */
  CosmosAccount(request: QueryCosmosAccountRequest): Promise<QueryCosmosAccountResponse>;
  /**
   * ValidatorAccount queries an Ethereum account's from a validator consensus
   * Address.
   */
  ValidatorAccount(request: QueryValidatorAccountRequest): Promise<QueryValidatorAccountResponse>;
  /**
   * Balance queries the balance of a the EVM denomination for a single
   * EthAccount.
   */
  Balance(request: QueryBalanceRequest): Promise<QueryBalanceResponse>;
  /** Storage queries the balance of all coins for a single account. */
  Storage(request: QueryStorageRequest): Promise<QueryStorageResponse>;
  /** Code queries the balance of all coins for a single account. */
  Code(request: QueryCodeRequest): Promise<QueryCodeResponse>;
  /** Params queries the parameters of x/evm module. */
  Params(request: QueryParamsRequest): Promise<QueryParamsResponse>;
  /** EthCall implements the `eth_call` rpc api */
  EthCall(request: EthCallRequest): Promise<MsgEthereumTxResponse>;
  /** EthCall implements the `eth_call` rpc api */
  EthCallWithOverride(request: EthCallWithOverrideRequest): Promise<MsgEthereumTxResponse>;
  /** EthCall implements the `eth_call` rpc api */
  EstimateGasWithOverride(request: EthCallWithOverrideRequest): Promise<EstimateGasResponse>;
  /** EstimateGas implements the `eth_estimateGas` rpc api */
  EstimateGas(request: EthCallRequest): Promise<EstimateGasResponse>;
  /** TraceTx implements the `debug_traceTransaction` rpc api */
  TraceTx(request: QueryTraceTxRequest): Promise<QueryTraceTxResponse>;
  /** TraceBlock implements the `debug_traceBlockByNumber` and `debug_traceBlockByHash` rpc api */
  TraceBlock(request: QueryTraceBlockRequest): Promise<QueryTraceBlockResponse>;
  /**
   * BaseFee queries the base fee of the parent block of the current block,
   * it's similar to feemarket module's method, but also checks london hardfork status.
   */
  BaseFee(request: QueryBaseFeeRequest): Promise<QueryBaseFeeResponse>;
}

export const QueryServiceName = "ethermint.evm.v1.Query";
export class QueryClientImpl implements Query {
  private readonly rpc: Rpc;
  private readonly service: string;
  constructor(rpc: Rpc, opts?: { service?: string }) {
    this.service = opts?.service || QueryServiceName;
    this.rpc = rpc;
    this.Account = this.Account.bind(this);
    this.CosmosAccount = this.CosmosAccount.bind(this);
    this.ValidatorAccount = this.ValidatorAccount.bind(this);
    this.Balance = this.Balance.bind(this);
    this.Storage = this.Storage.bind(this);
    this.Code = this.Code.bind(this);
    this.Params = this.Params.bind(this);
    this.EthCall = this.EthCall.bind(this);
    this.EthCallWithOverride = this.EthCallWithOverride.bind(this);
    this.EstimateGasWithOverride = this.EstimateGasWithOverride.bind(this);
    this.EstimateGas = this.EstimateGas.bind(this);
    this.TraceTx = this.TraceTx.bind(this);
    this.TraceBlock = this.TraceBlock.bind(this);
    this.BaseFee = this.BaseFee.bind(this);
  }
  Account(request: QueryAccountRequest): Promise<QueryAccountResponse> {
    const data = QueryAccountRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "Account", data);
    return promise.then((data) => QueryAccountResponse.decode(new BinaryReader(data)));
  }

  CosmosAccount(request: QueryCosmosAccountRequest): Promise<QueryCosmosAccountResponse> {
    const data = QueryCosmosAccountRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "CosmosAccount", data);
    return promise.then((data) => QueryCosmosAccountResponse.decode(new BinaryReader(data)));
  }

  ValidatorAccount(request: QueryValidatorAccountRequest): Promise<QueryValidatorAccountResponse> {
    const data = QueryValidatorAccountRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "ValidatorAccount", data);
    return promise.then((data) => QueryValidatorAccountResponse.decode(new BinaryReader(data)));
  }

  Balance(request: QueryBalanceRequest): Promise<QueryBalanceResponse> {
    const data = QueryBalanceRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "Balance", data);
    return promise.then((data) => QueryBalanceResponse.decode(new BinaryReader(data)));
  }

  Storage(request: QueryStorageRequest): Promise<QueryStorageResponse> {
    const data = QueryStorageRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "Storage", data);
    return promise.then((data) => QueryStorageResponse.decode(new BinaryReader(data)));
  }

  Code(request: QueryCodeRequest): Promise<QueryCodeResponse> {
    const data = QueryCodeRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "Code", data);
    return promise.then((data) => QueryCodeResponse.decode(new BinaryReader(data)));
  }

  Params(request: QueryParamsRequest): Promise<QueryParamsResponse> {
    const data = QueryParamsRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "Params", data);
    return promise.then((data) => QueryParamsResponse.decode(new BinaryReader(data)));
  }

  EthCall(request: EthCallRequest): Promise<MsgEthereumTxResponse> {
    const data = EthCallRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "EthCall", data);
    return promise.then((data) => MsgEthereumTxResponse.decode(new BinaryReader(data)));
  }

  EthCallWithOverride(request: EthCallWithOverrideRequest): Promise<MsgEthereumTxResponse> {
    const data = EthCallWithOverrideRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "EthCallWithOverride", data);
    return promise.then((data) => MsgEthereumTxResponse.decode(new BinaryReader(data)));
  }

  EstimateGasWithOverride(request: EthCallWithOverrideRequest): Promise<EstimateGasResponse> {
    const data = EthCallWithOverrideRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "EstimateGasWithOverride", data);
    return promise.then((data) => EstimateGasResponse.decode(new BinaryReader(data)));
  }

  EstimateGas(request: EthCallRequest): Promise<EstimateGasResponse> {
    const data = EthCallRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "EstimateGas", data);
    return promise.then((data) => EstimateGasResponse.decode(new BinaryReader(data)));
  }

  TraceTx(request: QueryTraceTxRequest): Promise<QueryTraceTxResponse> {
    const data = QueryTraceTxRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "TraceTx", data);
    return promise.then((data) => QueryTraceTxResponse.decode(new BinaryReader(data)));
  }

  TraceBlock(request: QueryTraceBlockRequest): Promise<QueryTraceBlockResponse> {
    const data = QueryTraceBlockRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "TraceBlock", data);
    return promise.then((data) => QueryTraceBlockResponse.decode(new BinaryReader(data)));
  }

  BaseFee(request: QueryBaseFeeRequest): Promise<QueryBaseFeeResponse> {
    const data = QueryBaseFeeRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "BaseFee", data);
    return promise.then((data) => QueryBaseFeeResponse.decode(new BinaryReader(data)));
  }
}

interface Rpc {
  request(service: string, method: string, data: Uint8Array): Promise<Uint8Array>;
}

function bytesFromBase64(b64: string): Uint8Array {
  if ((globalThis as any).Buffer) {
    return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
  } else {
    const bin = globalThis.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}

function base64FromBytes(arr: Uint8Array): string {
  if ((globalThis as any).Buffer) {
    return globalThis.Buffer.from(arr).toString("base64");
  } else {
    const bin: string[] = [];
    arr.forEach((byte) => {
      bin.push(globalThis.String.fromCharCode(byte));
    });
    return globalThis.btoa(bin.join(""));
  }
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function toTimestamp(date: Date): Timestamp {
  const seconds = Math.trunc(date.getTime() / 1_000);
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function longToNumber(int64: { toString(): string }): number {
  const num = globalThis.Number(int64.toString());
  if (num > globalThis.Number.MAX_SAFE_INTEGER) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (num < globalThis.Number.MIN_SAFE_INTEGER) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return num;
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
