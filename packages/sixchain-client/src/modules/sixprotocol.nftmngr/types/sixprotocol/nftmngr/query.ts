// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.6.1
//   protoc               unknown
// source: sixprotocol/nftmngr/query.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { PageRequest, PageResponse } from "../../cosmos/base/query/v1beta1/pagination";
import { ActionByRefId } from "./action_by_ref_id";
import { ActionExecutor } from "./action_executor";
import { ActionOfSchema } from "./action_of_schema";
import { ExecutorOfSchema } from "./executor_of_schema";
import { LockSchemaFee } from "./lock_schema_fee";
import { MetadataCreator } from "./metadata_creator";
import { NftData } from "./nft_data";
import { NFTFeeBalance } from "./nft_fee_balance";
import { NFTFeeConfig } from "./nft_fee_config";
import { NFTSchemaQueryResult } from "./nft_schema";
import { NFTSchemaByContract } from "./nft_schema_by_contract";
import { Organization } from "./organization";
import { Params } from "./params";
import { SchemaAttribute } from "./schema_attribute";
import { VirtualAction } from "./virtual_action";
import { VirtualSchema, VirtualSchemaProposal } from "./virtual_schema";

export const protobufPackage = "sixprotocol.nftmngr";

/** QueryParamsRequest is request type for the Query/Params RPC method. */
export interface QueryParamsRequest {
}

/** QueryParamsResponse is response type for the Query/Params RPC method. */
export interface QueryParamsResponse {
  /** params holds all the parameters of this module. */
  params: Params | undefined;
}

export interface QueryGetNFTSchemaRequest {
  code: string;
}

export interface QueryGetNFTSchemaResponse {
  nFTSchema: NFTSchemaQueryResult | undefined;
}

export interface QueryAllNFTSchemaRequest {
  pagination: PageRequest | undefined;
}

export interface QueryAllNFTSchemaResponse {
  nFTSchema: NFTSchemaQueryResult[];
  pagination: PageResponse | undefined;
}

export interface QueryGetNftDataRequest {
  nftSchemaCode: string;
  tokenId: string;
  withGlobal: boolean;
}

export interface QueryGetNftDataResponse {
  nftData: NftData | undefined;
}

export interface QueryAllNftDataRequest {
  withGlobal: boolean;
  pagination: PageRequest | undefined;
}

export interface QueryAllNftDataResponse {
  nftData: NftData[];
  pagination: PageResponse | undefined;
}

export interface QueryGetActionByRefIdRequest {
  refId: string;
}

export interface QueryGetActionByRefIdResponse {
  actionByRefId: ActionByRefId | undefined;
}

export interface QueryAllActionByRefIdRequest {
  pagination: PageRequest | undefined;
}

export interface QueryAllActionByRefIdResponse {
  actionByRefId: ActionByRefId[];
  pagination: PageResponse | undefined;
}

export interface QueryGetOrganizationRequest {
  name: string;
}

export interface QueryGetOrganizationResponse {
  organization: Organization | undefined;
}

export interface QueryAllOrganizationRequest {
  pagination: PageRequest | undefined;
}

export interface QueryAllOrganizationResponse {
  organization: Organization[];
  pagination: PageResponse | undefined;
}

export interface QueryGetNftCollectionRequest {
  nftSchemaCode: string;
  pagination: PageRequest | undefined;
}

export interface QueryGetNftCollectionResponse {
  nftCollection: NftData[];
  pagination: PageResponse | undefined;
}

export interface QueryGetNFTSchemaByContractRequest {
  originContractAddress: string;
}

export interface QueryGetNFTSchemaByContractResponse {
  nFTSchemaByContract: NFTSchemaByContract | undefined;
}

export interface QueryAllNFTSchemaByContractRequest {
  pagination: PageRequest | undefined;
}

export interface QueryAllNFTSchemaByContractResponse {
  nFTSchemaByContract: NFTSchemaByContract[];
  pagination: PageResponse | undefined;
}

export interface QueryGetNFTFeeConfigRequest {
}

export interface QueryGetNFTFeeConfigResponse {
  NFTFeeConfig: NFTFeeConfig | undefined;
}

export interface QueryGetNFTFeeBalanceRequest {
}

export interface QueryGetNFTFeeBalanceResponse {
  NFTFeeBalance: NFTFeeBalance | undefined;
}

export interface QueryGetMetadataCreatorRequest {
  nftSchemaCode: string;
}

export interface QueryGetMetadataCreatorResponse {
  metadataCreator: MetadataCreator | undefined;
}

export interface QueryAllMetadataCreatorRequest {
  pagination: PageRequest | undefined;
}

export interface QueryAllMetadataCreatorResponse {
  metadataCreator: MetadataCreator[];
  pagination: PageResponse | undefined;
}

export interface QueryGetActionExecutorRequest {
  nftSchemaCode: string;
  executorAddress: string;
}

export interface QueryGetActionExecutorResponse {
  actionExecutor: ActionExecutor | undefined;
}

export interface QueryAllActionExecutorRequest {
  pagination: PageRequest | undefined;
}

export interface QueryAllActionExecutorResponse {
  actionExecutor: ActionExecutor[];
  pagination: PageResponse | undefined;
}

export interface QueryGetSchemaAttributeRequest {
  nftSchemaCode: string;
  name: string;
}

export interface QueryGetSchemaAttributeResponse {
  schemaAttribute: SchemaAttribute | undefined;
}

export interface QueryAllSchemaAttributeRequest {
  nftSchemaCode: string;
  pagination: PageRequest | undefined;
}

export interface QueryAllSchemaAttributeResponse {
  schemaAttribute: SchemaAttribute[];
  pagination: PageResponse | undefined;
}

export interface QueryListAttributeBySchemaRequest {
  nftSchemaCode: string;
}

export interface QueryListAttributeBySchemaResponse {
  schemaAttribute: SchemaAttribute[];
}

export interface QueryGetActionOfSchemaRequest {
  nftSchemaCode: string;
  name: string;
}

export interface QueryGetActionOfSchemaResponse {
  actionOfSchema: ActionOfSchema | undefined;
}

export interface QueryAllActionOfSchemaRequest {
  pagination: PageRequest | undefined;
}

export interface QueryAllActionOfSchemaResponse {
  actionOfSchema: ActionOfSchema[];
  pagination: PageResponse | undefined;
}

export interface QueryGetExecutorOfSchemaRequest {
  nftSchemaCode: string;
}

export interface QueryGetExecutorOfSchemaResponse {
  executorOfSchema: ExecutorOfSchema | undefined;
}

export interface QueryAllExecutorOfSchemaRequest {
  pagination: PageRequest | undefined;
}

export interface QueryAllExecutorOfSchemaResponse {
  executorOfSchema: ExecutorOfSchema[];
  pagination: PageResponse | undefined;
}

export interface QueryGetVirtualActionRequest {
  nftSchemaCode: string;
  name: string;
}

export interface QueryGetVirtualActionResponse {
  virtualAction: VirtualAction | undefined;
}

export interface QueryAllVirtualActionRequest {
  nftSchemaCode: string;
  pagination: PageRequest | undefined;
}

export interface QueryAllVirtualActionResponse {
  virtualAction: VirtualAction[];
  pagination: PageResponse | undefined;
}

export interface QueryGetVirtualSchemaRequest {
  nftSchemaCode: string;
}

export interface QueryGetVirtualSchemaResponse {
  virtualSchema: VirtualSchema | undefined;
}

export interface QueryAllVirtualSchemaRequest {
  pagination: PageRequest | undefined;
}

export interface QueryAllVirtualSchemaResponse {
  virtualSchema: VirtualSchema[];
  pagination: PageResponse | undefined;
}

export interface QueryGetVirtualSchemaProposalRequest {
  index: string;
}

export interface QueryGetVirtualSchemaProposalResponse {
  virtualSchemaProposal: VirtualSchemaProposal | undefined;
}

export interface QueryAllVirtualSchemaProposalRequest {
  pagination: PageRequest | undefined;
}

export interface QueryAllVirtualSchemaProposalResponse {
  virtualSchemaProposal: VirtualSchemaProposal[];
  pagination: PageResponse | undefined;
}

export interface QueryListActiveProposalRequest {
}

export interface QueryListActiveProposalResponse {
  virtualSchemaProposal: VirtualSchemaProposal[];
}

export interface QueryGetLockSchemaFeeRequest {
  index: string;
}

export interface QueryGetLockSchemaFeeResponse {
  lockSchemaFee: LockSchemaFee | undefined;
}

export interface QueryAllLockSchemaFeeRequest {
  pagination: PageRequest | undefined;
}

export interface QueryAllLockSchemaFeeResponse {
  lockSchemaFee: LockSchemaFee[];
  pagination: PageResponse | undefined;
}

function createBaseQueryParamsRequest(): QueryParamsRequest {
  return {};
}

export const QueryParamsRequest: MessageFns<QueryParamsRequest> = {
  encode(_: QueryParamsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryParamsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryParamsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): QueryParamsRequest {
    return {};
  },

  toJSON(_: QueryParamsRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryParamsRequest>, I>>(base?: I): QueryParamsRequest {
    return QueryParamsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryParamsRequest>, I>>(_: I): QueryParamsRequest {
    const message = createBaseQueryParamsRequest();
    return message;
  },
};

function createBaseQueryParamsResponse(): QueryParamsResponse {
  return { params: undefined };
}

export const QueryParamsResponse: MessageFns<QueryParamsResponse> = {
  encode(message: QueryParamsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.params !== undefined) {
      Params.encode(message.params, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryParamsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryParamsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.params = Params.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryParamsResponse {
    return { params: isSet(object.params) ? Params.fromJSON(object.params) : undefined };
  },

  toJSON(message: QueryParamsResponse): unknown {
    const obj: any = {};
    if (message.params !== undefined) {
      obj.params = Params.toJSON(message.params);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryParamsResponse>, I>>(base?: I): QueryParamsResponse {
    return QueryParamsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryParamsResponse>, I>>(object: I): QueryParamsResponse {
    const message = createBaseQueryParamsResponse();
    message.params = (object.params !== undefined && object.params !== null)
      ? Params.fromPartial(object.params)
      : undefined;
    return message;
  },
};

function createBaseQueryGetNFTSchemaRequest(): QueryGetNFTSchemaRequest {
  return { code: "" };
}

export const QueryGetNFTSchemaRequest: MessageFns<QueryGetNFTSchemaRequest> = {
  encode(message: QueryGetNFTSchemaRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.code !== "") {
      writer.uint32(10).string(message.code);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryGetNFTSchemaRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryGetNFTSchemaRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.code = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryGetNFTSchemaRequest {
    return { code: isSet(object.code) ? globalThis.String(object.code) : "" };
  },

  toJSON(message: QueryGetNFTSchemaRequest): unknown {
    const obj: any = {};
    if (message.code !== "") {
      obj.code = message.code;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryGetNFTSchemaRequest>, I>>(base?: I): QueryGetNFTSchemaRequest {
    return QueryGetNFTSchemaRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryGetNFTSchemaRequest>, I>>(object: I): QueryGetNFTSchemaRequest {
    const message = createBaseQueryGetNFTSchemaRequest();
    message.code = object.code ?? "";
    return message;
  },
};

function createBaseQueryGetNFTSchemaResponse(): QueryGetNFTSchemaResponse {
  return { nFTSchema: undefined };
}

export const QueryGetNFTSchemaResponse: MessageFns<QueryGetNFTSchemaResponse> = {
  encode(message: QueryGetNFTSchemaResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.nFTSchema !== undefined) {
      NFTSchemaQueryResult.encode(message.nFTSchema, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryGetNFTSchemaResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryGetNFTSchemaResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.nFTSchema = NFTSchemaQueryResult.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryGetNFTSchemaResponse {
    return { nFTSchema: isSet(object.nFTSchema) ? NFTSchemaQueryResult.fromJSON(object.nFTSchema) : undefined };
  },

  toJSON(message: QueryGetNFTSchemaResponse): unknown {
    const obj: any = {};
    if (message.nFTSchema !== undefined) {
      obj.nFTSchema = NFTSchemaQueryResult.toJSON(message.nFTSchema);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryGetNFTSchemaResponse>, I>>(base?: I): QueryGetNFTSchemaResponse {
    return QueryGetNFTSchemaResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryGetNFTSchemaResponse>, I>>(object: I): QueryGetNFTSchemaResponse {
    const message = createBaseQueryGetNFTSchemaResponse();
    message.nFTSchema = (object.nFTSchema !== undefined && object.nFTSchema !== null)
      ? NFTSchemaQueryResult.fromPartial(object.nFTSchema)
      : undefined;
    return message;
  },
};

function createBaseQueryAllNFTSchemaRequest(): QueryAllNFTSchemaRequest {
  return { pagination: undefined };
}

export const QueryAllNFTSchemaRequest: MessageFns<QueryAllNFTSchemaRequest> = {
  encode(message: QueryAllNFTSchemaRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.pagination !== undefined) {
      PageRequest.encode(message.pagination, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryAllNFTSchemaRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryAllNFTSchemaRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.pagination = PageRequest.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryAllNFTSchemaRequest {
    return { pagination: isSet(object.pagination) ? PageRequest.fromJSON(object.pagination) : undefined };
  },

  toJSON(message: QueryAllNFTSchemaRequest): unknown {
    const obj: any = {};
    if (message.pagination !== undefined) {
      obj.pagination = PageRequest.toJSON(message.pagination);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryAllNFTSchemaRequest>, I>>(base?: I): QueryAllNFTSchemaRequest {
    return QueryAllNFTSchemaRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryAllNFTSchemaRequest>, I>>(object: I): QueryAllNFTSchemaRequest {
    const message = createBaseQueryAllNFTSchemaRequest();
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? PageRequest.fromPartial(object.pagination)
      : undefined;
    return message;
  },
};

function createBaseQueryAllNFTSchemaResponse(): QueryAllNFTSchemaResponse {
  return { nFTSchema: [], pagination: undefined };
}

export const QueryAllNFTSchemaResponse: MessageFns<QueryAllNFTSchemaResponse> = {
  encode(message: QueryAllNFTSchemaResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.nFTSchema) {
      NFTSchemaQueryResult.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.pagination !== undefined) {
      PageResponse.encode(message.pagination, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryAllNFTSchemaResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryAllNFTSchemaResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.nFTSchema.push(NFTSchemaQueryResult.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pagination = PageResponse.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryAllNFTSchemaResponse {
    return {
      nFTSchema: globalThis.Array.isArray(object?.nFTSchema)
        ? object.nFTSchema.map((e: any) => NFTSchemaQueryResult.fromJSON(e))
        : [],
      pagination: isSet(object.pagination) ? PageResponse.fromJSON(object.pagination) : undefined,
    };
  },

  toJSON(message: QueryAllNFTSchemaResponse): unknown {
    const obj: any = {};
    if (message.nFTSchema?.length) {
      obj.nFTSchema = message.nFTSchema.map((e) => NFTSchemaQueryResult.toJSON(e));
    }
    if (message.pagination !== undefined) {
      obj.pagination = PageResponse.toJSON(message.pagination);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryAllNFTSchemaResponse>, I>>(base?: I): QueryAllNFTSchemaResponse {
    return QueryAllNFTSchemaResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryAllNFTSchemaResponse>, I>>(object: I): QueryAllNFTSchemaResponse {
    const message = createBaseQueryAllNFTSchemaResponse();
    message.nFTSchema = object.nFTSchema?.map((e) => NFTSchemaQueryResult.fromPartial(e)) || [];
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? PageResponse.fromPartial(object.pagination)
      : undefined;
    return message;
  },
};

function createBaseQueryGetNftDataRequest(): QueryGetNftDataRequest {
  return { nftSchemaCode: "", tokenId: "", withGlobal: false };
}

export const QueryGetNftDataRequest: MessageFns<QueryGetNftDataRequest> = {
  encode(message: QueryGetNftDataRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.nftSchemaCode !== "") {
      writer.uint32(10).string(message.nftSchemaCode);
    }
    if (message.tokenId !== "") {
      writer.uint32(18).string(message.tokenId);
    }
    if (message.withGlobal !== false) {
      writer.uint32(24).bool(message.withGlobal);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryGetNftDataRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryGetNftDataRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.nftSchemaCode = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.tokenId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.withGlobal = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryGetNftDataRequest {
    return {
      nftSchemaCode: isSet(object.nftSchemaCode) ? globalThis.String(object.nftSchemaCode) : "",
      tokenId: isSet(object.tokenId) ? globalThis.String(object.tokenId) : "",
      withGlobal: isSet(object.withGlobal) ? globalThis.Boolean(object.withGlobal) : false,
    };
  },

  toJSON(message: QueryGetNftDataRequest): unknown {
    const obj: any = {};
    if (message.nftSchemaCode !== "") {
      obj.nftSchemaCode = message.nftSchemaCode;
    }
    if (message.tokenId !== "") {
      obj.tokenId = message.tokenId;
    }
    if (message.withGlobal !== false) {
      obj.withGlobal = message.withGlobal;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryGetNftDataRequest>, I>>(base?: I): QueryGetNftDataRequest {
    return QueryGetNftDataRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryGetNftDataRequest>, I>>(object: I): QueryGetNftDataRequest {
    const message = createBaseQueryGetNftDataRequest();
    message.nftSchemaCode = object.nftSchemaCode ?? "";
    message.tokenId = object.tokenId ?? "";
    message.withGlobal = object.withGlobal ?? false;
    return message;
  },
};

function createBaseQueryGetNftDataResponse(): QueryGetNftDataResponse {
  return { nftData: undefined };
}

export const QueryGetNftDataResponse: MessageFns<QueryGetNftDataResponse> = {
  encode(message: QueryGetNftDataResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.nftData !== undefined) {
      NftData.encode(message.nftData, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryGetNftDataResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryGetNftDataResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.nftData = NftData.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryGetNftDataResponse {
    return { nftData: isSet(object.nftData) ? NftData.fromJSON(object.nftData) : undefined };
  },

  toJSON(message: QueryGetNftDataResponse): unknown {
    const obj: any = {};
    if (message.nftData !== undefined) {
      obj.nftData = NftData.toJSON(message.nftData);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryGetNftDataResponse>, I>>(base?: I): QueryGetNftDataResponse {
    return QueryGetNftDataResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryGetNftDataResponse>, I>>(object: I): QueryGetNftDataResponse {
    const message = createBaseQueryGetNftDataResponse();
    message.nftData = (object.nftData !== undefined && object.nftData !== null)
      ? NftData.fromPartial(object.nftData)
      : undefined;
    return message;
  },
};

function createBaseQueryAllNftDataRequest(): QueryAllNftDataRequest {
  return { withGlobal: false, pagination: undefined };
}

export const QueryAllNftDataRequest: MessageFns<QueryAllNftDataRequest> = {
  encode(message: QueryAllNftDataRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.withGlobal !== false) {
      writer.uint32(8).bool(message.withGlobal);
    }
    if (message.pagination !== undefined) {
      PageRequest.encode(message.pagination, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryAllNftDataRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryAllNftDataRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.withGlobal = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pagination = PageRequest.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryAllNftDataRequest {
    return {
      withGlobal: isSet(object.withGlobal) ? globalThis.Boolean(object.withGlobal) : false,
      pagination: isSet(object.pagination) ? PageRequest.fromJSON(object.pagination) : undefined,
    };
  },

  toJSON(message: QueryAllNftDataRequest): unknown {
    const obj: any = {};
    if (message.withGlobal !== false) {
      obj.withGlobal = message.withGlobal;
    }
    if (message.pagination !== undefined) {
      obj.pagination = PageRequest.toJSON(message.pagination);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryAllNftDataRequest>, I>>(base?: I): QueryAllNftDataRequest {
    return QueryAllNftDataRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryAllNftDataRequest>, I>>(object: I): QueryAllNftDataRequest {
    const message = createBaseQueryAllNftDataRequest();
    message.withGlobal = object.withGlobal ?? false;
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? PageRequest.fromPartial(object.pagination)
      : undefined;
    return message;
  },
};

function createBaseQueryAllNftDataResponse(): QueryAllNftDataResponse {
  return { nftData: [], pagination: undefined };
}

export const QueryAllNftDataResponse: MessageFns<QueryAllNftDataResponse> = {
  encode(message: QueryAllNftDataResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.nftData) {
      NftData.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.pagination !== undefined) {
      PageResponse.encode(message.pagination, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryAllNftDataResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryAllNftDataResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.nftData.push(NftData.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pagination = PageResponse.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryAllNftDataResponse {
    return {
      nftData: globalThis.Array.isArray(object?.nftData) ? object.nftData.map((e: any) => NftData.fromJSON(e)) : [],
      pagination: isSet(object.pagination) ? PageResponse.fromJSON(object.pagination) : undefined,
    };
  },

  toJSON(message: QueryAllNftDataResponse): unknown {
    const obj: any = {};
    if (message.nftData?.length) {
      obj.nftData = message.nftData.map((e) => NftData.toJSON(e));
    }
    if (message.pagination !== undefined) {
      obj.pagination = PageResponse.toJSON(message.pagination);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryAllNftDataResponse>, I>>(base?: I): QueryAllNftDataResponse {
    return QueryAllNftDataResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryAllNftDataResponse>, I>>(object: I): QueryAllNftDataResponse {
    const message = createBaseQueryAllNftDataResponse();
    message.nftData = object.nftData?.map((e) => NftData.fromPartial(e)) || [];
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? PageResponse.fromPartial(object.pagination)
      : undefined;
    return message;
  },
};

function createBaseQueryGetActionByRefIdRequest(): QueryGetActionByRefIdRequest {
  return { refId: "" };
}

export const QueryGetActionByRefIdRequest: MessageFns<QueryGetActionByRefIdRequest> = {
  encode(message: QueryGetActionByRefIdRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.refId !== "") {
      writer.uint32(10).string(message.refId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryGetActionByRefIdRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryGetActionByRefIdRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.refId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryGetActionByRefIdRequest {
    return { refId: isSet(object.refId) ? globalThis.String(object.refId) : "" };
  },

  toJSON(message: QueryGetActionByRefIdRequest): unknown {
    const obj: any = {};
    if (message.refId !== "") {
      obj.refId = message.refId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryGetActionByRefIdRequest>, I>>(base?: I): QueryGetActionByRefIdRequest {
    return QueryGetActionByRefIdRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryGetActionByRefIdRequest>, I>>(object: I): QueryGetActionByRefIdRequest {
    const message = createBaseQueryGetActionByRefIdRequest();
    message.refId = object.refId ?? "";
    return message;
  },
};

function createBaseQueryGetActionByRefIdResponse(): QueryGetActionByRefIdResponse {
  return { actionByRefId: undefined };
}

export const QueryGetActionByRefIdResponse: MessageFns<QueryGetActionByRefIdResponse> = {
  encode(message: QueryGetActionByRefIdResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.actionByRefId !== undefined) {
      ActionByRefId.encode(message.actionByRefId, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryGetActionByRefIdResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryGetActionByRefIdResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.actionByRefId = ActionByRefId.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryGetActionByRefIdResponse {
    return { actionByRefId: isSet(object.actionByRefId) ? ActionByRefId.fromJSON(object.actionByRefId) : undefined };
  },

  toJSON(message: QueryGetActionByRefIdResponse): unknown {
    const obj: any = {};
    if (message.actionByRefId !== undefined) {
      obj.actionByRefId = ActionByRefId.toJSON(message.actionByRefId);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryGetActionByRefIdResponse>, I>>(base?: I): QueryGetActionByRefIdResponse {
    return QueryGetActionByRefIdResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryGetActionByRefIdResponse>, I>>(
    object: I,
  ): QueryGetActionByRefIdResponse {
    const message = createBaseQueryGetActionByRefIdResponse();
    message.actionByRefId = (object.actionByRefId !== undefined && object.actionByRefId !== null)
      ? ActionByRefId.fromPartial(object.actionByRefId)
      : undefined;
    return message;
  },
};

function createBaseQueryAllActionByRefIdRequest(): QueryAllActionByRefIdRequest {
  return { pagination: undefined };
}

export const QueryAllActionByRefIdRequest: MessageFns<QueryAllActionByRefIdRequest> = {
  encode(message: QueryAllActionByRefIdRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.pagination !== undefined) {
      PageRequest.encode(message.pagination, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryAllActionByRefIdRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryAllActionByRefIdRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.pagination = PageRequest.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryAllActionByRefIdRequest {
    return { pagination: isSet(object.pagination) ? PageRequest.fromJSON(object.pagination) : undefined };
  },

  toJSON(message: QueryAllActionByRefIdRequest): unknown {
    const obj: any = {};
    if (message.pagination !== undefined) {
      obj.pagination = PageRequest.toJSON(message.pagination);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryAllActionByRefIdRequest>, I>>(base?: I): QueryAllActionByRefIdRequest {
    return QueryAllActionByRefIdRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryAllActionByRefIdRequest>, I>>(object: I): QueryAllActionByRefIdRequest {
    const message = createBaseQueryAllActionByRefIdRequest();
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? PageRequest.fromPartial(object.pagination)
      : undefined;
    return message;
  },
};

function createBaseQueryAllActionByRefIdResponse(): QueryAllActionByRefIdResponse {
  return { actionByRefId: [], pagination: undefined };
}

export const QueryAllActionByRefIdResponse: MessageFns<QueryAllActionByRefIdResponse> = {
  encode(message: QueryAllActionByRefIdResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.actionByRefId) {
      ActionByRefId.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.pagination !== undefined) {
      PageResponse.encode(message.pagination, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryAllActionByRefIdResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryAllActionByRefIdResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.actionByRefId.push(ActionByRefId.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pagination = PageResponse.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryAllActionByRefIdResponse {
    return {
      actionByRefId: globalThis.Array.isArray(object?.actionByRefId)
        ? object.actionByRefId.map((e: any) => ActionByRefId.fromJSON(e))
        : [],
      pagination: isSet(object.pagination) ? PageResponse.fromJSON(object.pagination) : undefined,
    };
  },

  toJSON(message: QueryAllActionByRefIdResponse): unknown {
    const obj: any = {};
    if (message.actionByRefId?.length) {
      obj.actionByRefId = message.actionByRefId.map((e) => ActionByRefId.toJSON(e));
    }
    if (message.pagination !== undefined) {
      obj.pagination = PageResponse.toJSON(message.pagination);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryAllActionByRefIdResponse>, I>>(base?: I): QueryAllActionByRefIdResponse {
    return QueryAllActionByRefIdResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryAllActionByRefIdResponse>, I>>(
    object: I,
  ): QueryAllActionByRefIdResponse {
    const message = createBaseQueryAllActionByRefIdResponse();
    message.actionByRefId = object.actionByRefId?.map((e) => ActionByRefId.fromPartial(e)) || [];
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? PageResponse.fromPartial(object.pagination)
      : undefined;
    return message;
  },
};

function createBaseQueryGetOrganizationRequest(): QueryGetOrganizationRequest {
  return { name: "" };
}

export const QueryGetOrganizationRequest: MessageFns<QueryGetOrganizationRequest> = {
  encode(message: QueryGetOrganizationRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryGetOrganizationRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryGetOrganizationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryGetOrganizationRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: QueryGetOrganizationRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryGetOrganizationRequest>, I>>(base?: I): QueryGetOrganizationRequest {
    return QueryGetOrganizationRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryGetOrganizationRequest>, I>>(object: I): QueryGetOrganizationRequest {
    const message = createBaseQueryGetOrganizationRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseQueryGetOrganizationResponse(): QueryGetOrganizationResponse {
  return { organization: undefined };
}

export const QueryGetOrganizationResponse: MessageFns<QueryGetOrganizationResponse> = {
  encode(message: QueryGetOrganizationResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.organization !== undefined) {
      Organization.encode(message.organization, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryGetOrganizationResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryGetOrganizationResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.organization = Organization.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryGetOrganizationResponse {
    return { organization: isSet(object.organization) ? Organization.fromJSON(object.organization) : undefined };
  },

  toJSON(message: QueryGetOrganizationResponse): unknown {
    const obj: any = {};
    if (message.organization !== undefined) {
      obj.organization = Organization.toJSON(message.organization);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryGetOrganizationResponse>, I>>(base?: I): QueryGetOrganizationResponse {
    return QueryGetOrganizationResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryGetOrganizationResponse>, I>>(object: I): QueryGetOrganizationResponse {
    const message = createBaseQueryGetOrganizationResponse();
    message.organization = (object.organization !== undefined && object.organization !== null)
      ? Organization.fromPartial(object.organization)
      : undefined;
    return message;
  },
};

function createBaseQueryAllOrganizationRequest(): QueryAllOrganizationRequest {
  return { pagination: undefined };
}

export const QueryAllOrganizationRequest: MessageFns<QueryAllOrganizationRequest> = {
  encode(message: QueryAllOrganizationRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.pagination !== undefined) {
      PageRequest.encode(message.pagination, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryAllOrganizationRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryAllOrganizationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.pagination = PageRequest.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryAllOrganizationRequest {
    return { pagination: isSet(object.pagination) ? PageRequest.fromJSON(object.pagination) : undefined };
  },

  toJSON(message: QueryAllOrganizationRequest): unknown {
    const obj: any = {};
    if (message.pagination !== undefined) {
      obj.pagination = PageRequest.toJSON(message.pagination);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryAllOrganizationRequest>, I>>(base?: I): QueryAllOrganizationRequest {
    return QueryAllOrganizationRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryAllOrganizationRequest>, I>>(object: I): QueryAllOrganizationRequest {
    const message = createBaseQueryAllOrganizationRequest();
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? PageRequest.fromPartial(object.pagination)
      : undefined;
    return message;
  },
};

function createBaseQueryAllOrganizationResponse(): QueryAllOrganizationResponse {
  return { organization: [], pagination: undefined };
}

export const QueryAllOrganizationResponse: MessageFns<QueryAllOrganizationResponse> = {
  encode(message: QueryAllOrganizationResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.organization) {
      Organization.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.pagination !== undefined) {
      PageResponse.encode(message.pagination, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryAllOrganizationResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryAllOrganizationResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.organization.push(Organization.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pagination = PageResponse.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryAllOrganizationResponse {
    return {
      organization: globalThis.Array.isArray(object?.organization)
        ? object.organization.map((e: any) => Organization.fromJSON(e))
        : [],
      pagination: isSet(object.pagination) ? PageResponse.fromJSON(object.pagination) : undefined,
    };
  },

  toJSON(message: QueryAllOrganizationResponse): unknown {
    const obj: any = {};
    if (message.organization?.length) {
      obj.organization = message.organization.map((e) => Organization.toJSON(e));
    }
    if (message.pagination !== undefined) {
      obj.pagination = PageResponse.toJSON(message.pagination);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryAllOrganizationResponse>, I>>(base?: I): QueryAllOrganizationResponse {
    return QueryAllOrganizationResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryAllOrganizationResponse>, I>>(object: I): QueryAllOrganizationResponse {
    const message = createBaseQueryAllOrganizationResponse();
    message.organization = object.organization?.map((e) => Organization.fromPartial(e)) || [];
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? PageResponse.fromPartial(object.pagination)
      : undefined;
    return message;
  },
};

function createBaseQueryGetNftCollectionRequest(): QueryGetNftCollectionRequest {
  return { nftSchemaCode: "", pagination: undefined };
}

export const QueryGetNftCollectionRequest: MessageFns<QueryGetNftCollectionRequest> = {
  encode(message: QueryGetNftCollectionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.nftSchemaCode !== "") {
      writer.uint32(10).string(message.nftSchemaCode);
    }
    if (message.pagination !== undefined) {
      PageRequest.encode(message.pagination, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryGetNftCollectionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryGetNftCollectionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.nftSchemaCode = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pagination = PageRequest.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryGetNftCollectionRequest {
    return {
      nftSchemaCode: isSet(object.nftSchemaCode) ? globalThis.String(object.nftSchemaCode) : "",
      pagination: isSet(object.pagination) ? PageRequest.fromJSON(object.pagination) : undefined,
    };
  },

  toJSON(message: QueryGetNftCollectionRequest): unknown {
    const obj: any = {};
    if (message.nftSchemaCode !== "") {
      obj.nftSchemaCode = message.nftSchemaCode;
    }
    if (message.pagination !== undefined) {
      obj.pagination = PageRequest.toJSON(message.pagination);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryGetNftCollectionRequest>, I>>(base?: I): QueryGetNftCollectionRequest {
    return QueryGetNftCollectionRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryGetNftCollectionRequest>, I>>(object: I): QueryGetNftCollectionRequest {
    const message = createBaseQueryGetNftCollectionRequest();
    message.nftSchemaCode = object.nftSchemaCode ?? "";
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? PageRequest.fromPartial(object.pagination)
      : undefined;
    return message;
  },
};

function createBaseQueryGetNftCollectionResponse(): QueryGetNftCollectionResponse {
  return { nftCollection: [], pagination: undefined };
}

export const QueryGetNftCollectionResponse: MessageFns<QueryGetNftCollectionResponse> = {
  encode(message: QueryGetNftCollectionResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.nftCollection) {
      NftData.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.pagination !== undefined) {
      PageResponse.encode(message.pagination, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryGetNftCollectionResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryGetNftCollectionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.nftCollection.push(NftData.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pagination = PageResponse.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryGetNftCollectionResponse {
    return {
      nftCollection: globalThis.Array.isArray(object?.nftCollection)
        ? object.nftCollection.map((e: any) => NftData.fromJSON(e))
        : [],
      pagination: isSet(object.pagination) ? PageResponse.fromJSON(object.pagination) : undefined,
    };
  },

  toJSON(message: QueryGetNftCollectionResponse): unknown {
    const obj: any = {};
    if (message.nftCollection?.length) {
      obj.nftCollection = message.nftCollection.map((e) => NftData.toJSON(e));
    }
    if (message.pagination !== undefined) {
      obj.pagination = PageResponse.toJSON(message.pagination);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryGetNftCollectionResponse>, I>>(base?: I): QueryGetNftCollectionResponse {
    return QueryGetNftCollectionResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryGetNftCollectionResponse>, I>>(
    object: I,
  ): QueryGetNftCollectionResponse {
    const message = createBaseQueryGetNftCollectionResponse();
    message.nftCollection = object.nftCollection?.map((e) => NftData.fromPartial(e)) || [];
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? PageResponse.fromPartial(object.pagination)
      : undefined;
    return message;
  },
};

function createBaseQueryGetNFTSchemaByContractRequest(): QueryGetNFTSchemaByContractRequest {
  return { originContractAddress: "" };
}

export const QueryGetNFTSchemaByContractRequest: MessageFns<QueryGetNFTSchemaByContractRequest> = {
  encode(message: QueryGetNFTSchemaByContractRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.originContractAddress !== "") {
      writer.uint32(10).string(message.originContractAddress);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryGetNFTSchemaByContractRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryGetNFTSchemaByContractRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.originContractAddress = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryGetNFTSchemaByContractRequest {
    return {
      originContractAddress: isSet(object.originContractAddress) ? globalThis.String(object.originContractAddress) : "",
    };
  },

  toJSON(message: QueryGetNFTSchemaByContractRequest): unknown {
    const obj: any = {};
    if (message.originContractAddress !== "") {
      obj.originContractAddress = message.originContractAddress;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryGetNFTSchemaByContractRequest>, I>>(
    base?: I,
  ): QueryGetNFTSchemaByContractRequest {
    return QueryGetNFTSchemaByContractRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryGetNFTSchemaByContractRequest>, I>>(
    object: I,
  ): QueryGetNFTSchemaByContractRequest {
    const message = createBaseQueryGetNFTSchemaByContractRequest();
    message.originContractAddress = object.originContractAddress ?? "";
    return message;
  },
};

function createBaseQueryGetNFTSchemaByContractResponse(): QueryGetNFTSchemaByContractResponse {
  return { nFTSchemaByContract: undefined };
}

export const QueryGetNFTSchemaByContractResponse: MessageFns<QueryGetNFTSchemaByContractResponse> = {
  encode(message: QueryGetNFTSchemaByContractResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.nFTSchemaByContract !== undefined) {
      NFTSchemaByContract.encode(message.nFTSchemaByContract, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryGetNFTSchemaByContractResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryGetNFTSchemaByContractResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.nFTSchemaByContract = NFTSchemaByContract.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryGetNFTSchemaByContractResponse {
    return {
      nFTSchemaByContract: isSet(object.nFTSchemaByContract)
        ? NFTSchemaByContract.fromJSON(object.nFTSchemaByContract)
        : undefined,
    };
  },

  toJSON(message: QueryGetNFTSchemaByContractResponse): unknown {
    const obj: any = {};
    if (message.nFTSchemaByContract !== undefined) {
      obj.nFTSchemaByContract = NFTSchemaByContract.toJSON(message.nFTSchemaByContract);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryGetNFTSchemaByContractResponse>, I>>(
    base?: I,
  ): QueryGetNFTSchemaByContractResponse {
    return QueryGetNFTSchemaByContractResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryGetNFTSchemaByContractResponse>, I>>(
    object: I,
  ): QueryGetNFTSchemaByContractResponse {
    const message = createBaseQueryGetNFTSchemaByContractResponse();
    message.nFTSchemaByContract = (object.nFTSchemaByContract !== undefined && object.nFTSchemaByContract !== null)
      ? NFTSchemaByContract.fromPartial(object.nFTSchemaByContract)
      : undefined;
    return message;
  },
};

function createBaseQueryAllNFTSchemaByContractRequest(): QueryAllNFTSchemaByContractRequest {
  return { pagination: undefined };
}

export const QueryAllNFTSchemaByContractRequest: MessageFns<QueryAllNFTSchemaByContractRequest> = {
  encode(message: QueryAllNFTSchemaByContractRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.pagination !== undefined) {
      PageRequest.encode(message.pagination, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryAllNFTSchemaByContractRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryAllNFTSchemaByContractRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.pagination = PageRequest.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryAllNFTSchemaByContractRequest {
    return { pagination: isSet(object.pagination) ? PageRequest.fromJSON(object.pagination) : undefined };
  },

  toJSON(message: QueryAllNFTSchemaByContractRequest): unknown {
    const obj: any = {};
    if (message.pagination !== undefined) {
      obj.pagination = PageRequest.toJSON(message.pagination);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryAllNFTSchemaByContractRequest>, I>>(
    base?: I,
  ): QueryAllNFTSchemaByContractRequest {
    return QueryAllNFTSchemaByContractRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryAllNFTSchemaByContractRequest>, I>>(
    object: I,
  ): QueryAllNFTSchemaByContractRequest {
    const message = createBaseQueryAllNFTSchemaByContractRequest();
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? PageRequest.fromPartial(object.pagination)
      : undefined;
    return message;
  },
};

function createBaseQueryAllNFTSchemaByContractResponse(): QueryAllNFTSchemaByContractResponse {
  return { nFTSchemaByContract: [], pagination: undefined };
}

export const QueryAllNFTSchemaByContractResponse: MessageFns<QueryAllNFTSchemaByContractResponse> = {
  encode(message: QueryAllNFTSchemaByContractResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.nFTSchemaByContract) {
      NFTSchemaByContract.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.pagination !== undefined) {
      PageResponse.encode(message.pagination, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryAllNFTSchemaByContractResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryAllNFTSchemaByContractResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.nFTSchemaByContract.push(NFTSchemaByContract.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pagination = PageResponse.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryAllNFTSchemaByContractResponse {
    return {
      nFTSchemaByContract: globalThis.Array.isArray(object?.nFTSchemaByContract)
        ? object.nFTSchemaByContract.map((e: any) => NFTSchemaByContract.fromJSON(e))
        : [],
      pagination: isSet(object.pagination) ? PageResponse.fromJSON(object.pagination) : undefined,
    };
  },

  toJSON(message: QueryAllNFTSchemaByContractResponse): unknown {
    const obj: any = {};
    if (message.nFTSchemaByContract?.length) {
      obj.nFTSchemaByContract = message.nFTSchemaByContract.map((e) => NFTSchemaByContract.toJSON(e));
    }
    if (message.pagination !== undefined) {
      obj.pagination = PageResponse.toJSON(message.pagination);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryAllNFTSchemaByContractResponse>, I>>(
    base?: I,
  ): QueryAllNFTSchemaByContractResponse {
    return QueryAllNFTSchemaByContractResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryAllNFTSchemaByContractResponse>, I>>(
    object: I,
  ): QueryAllNFTSchemaByContractResponse {
    const message = createBaseQueryAllNFTSchemaByContractResponse();
    message.nFTSchemaByContract = object.nFTSchemaByContract?.map((e) => NFTSchemaByContract.fromPartial(e)) || [];
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? PageResponse.fromPartial(object.pagination)
      : undefined;
    return message;
  },
};

function createBaseQueryGetNFTFeeConfigRequest(): QueryGetNFTFeeConfigRequest {
  return {};
}

export const QueryGetNFTFeeConfigRequest: MessageFns<QueryGetNFTFeeConfigRequest> = {
  encode(_: QueryGetNFTFeeConfigRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryGetNFTFeeConfigRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryGetNFTFeeConfigRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): QueryGetNFTFeeConfigRequest {
    return {};
  },

  toJSON(_: QueryGetNFTFeeConfigRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryGetNFTFeeConfigRequest>, I>>(base?: I): QueryGetNFTFeeConfigRequest {
    return QueryGetNFTFeeConfigRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryGetNFTFeeConfigRequest>, I>>(_: I): QueryGetNFTFeeConfigRequest {
    const message = createBaseQueryGetNFTFeeConfigRequest();
    return message;
  },
};

function createBaseQueryGetNFTFeeConfigResponse(): QueryGetNFTFeeConfigResponse {
  return { NFTFeeConfig: undefined };
}

export const QueryGetNFTFeeConfigResponse: MessageFns<QueryGetNFTFeeConfigResponse> = {
  encode(message: QueryGetNFTFeeConfigResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.NFTFeeConfig !== undefined) {
      NFTFeeConfig.encode(message.NFTFeeConfig, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryGetNFTFeeConfigResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryGetNFTFeeConfigResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.NFTFeeConfig = NFTFeeConfig.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryGetNFTFeeConfigResponse {
    return { NFTFeeConfig: isSet(object.NFTFeeConfig) ? NFTFeeConfig.fromJSON(object.NFTFeeConfig) : undefined };
  },

  toJSON(message: QueryGetNFTFeeConfigResponse): unknown {
    const obj: any = {};
    if (message.NFTFeeConfig !== undefined) {
      obj.NFTFeeConfig = NFTFeeConfig.toJSON(message.NFTFeeConfig);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryGetNFTFeeConfigResponse>, I>>(base?: I): QueryGetNFTFeeConfigResponse {
    return QueryGetNFTFeeConfigResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryGetNFTFeeConfigResponse>, I>>(object: I): QueryGetNFTFeeConfigResponse {
    const message = createBaseQueryGetNFTFeeConfigResponse();
    message.NFTFeeConfig = (object.NFTFeeConfig !== undefined && object.NFTFeeConfig !== null)
      ? NFTFeeConfig.fromPartial(object.NFTFeeConfig)
      : undefined;
    return message;
  },
};

function createBaseQueryGetNFTFeeBalanceRequest(): QueryGetNFTFeeBalanceRequest {
  return {};
}

export const QueryGetNFTFeeBalanceRequest: MessageFns<QueryGetNFTFeeBalanceRequest> = {
  encode(_: QueryGetNFTFeeBalanceRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryGetNFTFeeBalanceRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryGetNFTFeeBalanceRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): QueryGetNFTFeeBalanceRequest {
    return {};
  },

  toJSON(_: QueryGetNFTFeeBalanceRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryGetNFTFeeBalanceRequest>, I>>(base?: I): QueryGetNFTFeeBalanceRequest {
    return QueryGetNFTFeeBalanceRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryGetNFTFeeBalanceRequest>, I>>(_: I): QueryGetNFTFeeBalanceRequest {
    const message = createBaseQueryGetNFTFeeBalanceRequest();
    return message;
  },
};

function createBaseQueryGetNFTFeeBalanceResponse(): QueryGetNFTFeeBalanceResponse {
  return { NFTFeeBalance: undefined };
}

export const QueryGetNFTFeeBalanceResponse: MessageFns<QueryGetNFTFeeBalanceResponse> = {
  encode(message: QueryGetNFTFeeBalanceResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.NFTFeeBalance !== undefined) {
      NFTFeeBalance.encode(message.NFTFeeBalance, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryGetNFTFeeBalanceResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryGetNFTFeeBalanceResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.NFTFeeBalance = NFTFeeBalance.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryGetNFTFeeBalanceResponse {
    return { NFTFeeBalance: isSet(object.NFTFeeBalance) ? NFTFeeBalance.fromJSON(object.NFTFeeBalance) : undefined };
  },

  toJSON(message: QueryGetNFTFeeBalanceResponse): unknown {
    const obj: any = {};
    if (message.NFTFeeBalance !== undefined) {
      obj.NFTFeeBalance = NFTFeeBalance.toJSON(message.NFTFeeBalance);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryGetNFTFeeBalanceResponse>, I>>(base?: I): QueryGetNFTFeeBalanceResponse {
    return QueryGetNFTFeeBalanceResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryGetNFTFeeBalanceResponse>, I>>(
    object: I,
  ): QueryGetNFTFeeBalanceResponse {
    const message = createBaseQueryGetNFTFeeBalanceResponse();
    message.NFTFeeBalance = (object.NFTFeeBalance !== undefined && object.NFTFeeBalance !== null)
      ? NFTFeeBalance.fromPartial(object.NFTFeeBalance)
      : undefined;
    return message;
  },
};

function createBaseQueryGetMetadataCreatorRequest(): QueryGetMetadataCreatorRequest {
  return { nftSchemaCode: "" };
}

export const QueryGetMetadataCreatorRequest: MessageFns<QueryGetMetadataCreatorRequest> = {
  encode(message: QueryGetMetadataCreatorRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.nftSchemaCode !== "") {
      writer.uint32(10).string(message.nftSchemaCode);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryGetMetadataCreatorRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryGetMetadataCreatorRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.nftSchemaCode = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryGetMetadataCreatorRequest {
    return { nftSchemaCode: isSet(object.nftSchemaCode) ? globalThis.String(object.nftSchemaCode) : "" };
  },

  toJSON(message: QueryGetMetadataCreatorRequest): unknown {
    const obj: any = {};
    if (message.nftSchemaCode !== "") {
      obj.nftSchemaCode = message.nftSchemaCode;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryGetMetadataCreatorRequest>, I>>(base?: I): QueryGetMetadataCreatorRequest {
    return QueryGetMetadataCreatorRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryGetMetadataCreatorRequest>, I>>(
    object: I,
  ): QueryGetMetadataCreatorRequest {
    const message = createBaseQueryGetMetadataCreatorRequest();
    message.nftSchemaCode = object.nftSchemaCode ?? "";
    return message;
  },
};

function createBaseQueryGetMetadataCreatorResponse(): QueryGetMetadataCreatorResponse {
  return { metadataCreator: undefined };
}

export const QueryGetMetadataCreatorResponse: MessageFns<QueryGetMetadataCreatorResponse> = {
  encode(message: QueryGetMetadataCreatorResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.metadataCreator !== undefined) {
      MetadataCreator.encode(message.metadataCreator, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryGetMetadataCreatorResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryGetMetadataCreatorResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.metadataCreator = MetadataCreator.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryGetMetadataCreatorResponse {
    return {
      metadataCreator: isSet(object.metadataCreator) ? MetadataCreator.fromJSON(object.metadataCreator) : undefined,
    };
  },

  toJSON(message: QueryGetMetadataCreatorResponse): unknown {
    const obj: any = {};
    if (message.metadataCreator !== undefined) {
      obj.metadataCreator = MetadataCreator.toJSON(message.metadataCreator);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryGetMetadataCreatorResponse>, I>>(base?: I): QueryGetMetadataCreatorResponse {
    return QueryGetMetadataCreatorResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryGetMetadataCreatorResponse>, I>>(
    object: I,
  ): QueryGetMetadataCreatorResponse {
    const message = createBaseQueryGetMetadataCreatorResponse();
    message.metadataCreator = (object.metadataCreator !== undefined && object.metadataCreator !== null)
      ? MetadataCreator.fromPartial(object.metadataCreator)
      : undefined;
    return message;
  },
};

function createBaseQueryAllMetadataCreatorRequest(): QueryAllMetadataCreatorRequest {
  return { pagination: undefined };
}

export const QueryAllMetadataCreatorRequest: MessageFns<QueryAllMetadataCreatorRequest> = {
  encode(message: QueryAllMetadataCreatorRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.pagination !== undefined) {
      PageRequest.encode(message.pagination, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryAllMetadataCreatorRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryAllMetadataCreatorRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.pagination = PageRequest.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryAllMetadataCreatorRequest {
    return { pagination: isSet(object.pagination) ? PageRequest.fromJSON(object.pagination) : undefined };
  },

  toJSON(message: QueryAllMetadataCreatorRequest): unknown {
    const obj: any = {};
    if (message.pagination !== undefined) {
      obj.pagination = PageRequest.toJSON(message.pagination);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryAllMetadataCreatorRequest>, I>>(base?: I): QueryAllMetadataCreatorRequest {
    return QueryAllMetadataCreatorRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryAllMetadataCreatorRequest>, I>>(
    object: I,
  ): QueryAllMetadataCreatorRequest {
    const message = createBaseQueryAllMetadataCreatorRequest();
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? PageRequest.fromPartial(object.pagination)
      : undefined;
    return message;
  },
};

function createBaseQueryAllMetadataCreatorResponse(): QueryAllMetadataCreatorResponse {
  return { metadataCreator: [], pagination: undefined };
}

export const QueryAllMetadataCreatorResponse: MessageFns<QueryAllMetadataCreatorResponse> = {
  encode(message: QueryAllMetadataCreatorResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.metadataCreator) {
      MetadataCreator.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.pagination !== undefined) {
      PageResponse.encode(message.pagination, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryAllMetadataCreatorResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryAllMetadataCreatorResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.metadataCreator.push(MetadataCreator.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pagination = PageResponse.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryAllMetadataCreatorResponse {
    return {
      metadataCreator: globalThis.Array.isArray(object?.metadataCreator)
        ? object.metadataCreator.map((e: any) => MetadataCreator.fromJSON(e))
        : [],
      pagination: isSet(object.pagination) ? PageResponse.fromJSON(object.pagination) : undefined,
    };
  },

  toJSON(message: QueryAllMetadataCreatorResponse): unknown {
    const obj: any = {};
    if (message.metadataCreator?.length) {
      obj.metadataCreator = message.metadataCreator.map((e) => MetadataCreator.toJSON(e));
    }
    if (message.pagination !== undefined) {
      obj.pagination = PageResponse.toJSON(message.pagination);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryAllMetadataCreatorResponse>, I>>(base?: I): QueryAllMetadataCreatorResponse {
    return QueryAllMetadataCreatorResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryAllMetadataCreatorResponse>, I>>(
    object: I,
  ): QueryAllMetadataCreatorResponse {
    const message = createBaseQueryAllMetadataCreatorResponse();
    message.metadataCreator = object.metadataCreator?.map((e) => MetadataCreator.fromPartial(e)) || [];
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? PageResponse.fromPartial(object.pagination)
      : undefined;
    return message;
  },
};

function createBaseQueryGetActionExecutorRequest(): QueryGetActionExecutorRequest {
  return { nftSchemaCode: "", executorAddress: "" };
}

export const QueryGetActionExecutorRequest: MessageFns<QueryGetActionExecutorRequest> = {
  encode(message: QueryGetActionExecutorRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.nftSchemaCode !== "") {
      writer.uint32(10).string(message.nftSchemaCode);
    }
    if (message.executorAddress !== "") {
      writer.uint32(18).string(message.executorAddress);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryGetActionExecutorRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryGetActionExecutorRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.nftSchemaCode = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.executorAddress = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryGetActionExecutorRequest {
    return {
      nftSchemaCode: isSet(object.nftSchemaCode) ? globalThis.String(object.nftSchemaCode) : "",
      executorAddress: isSet(object.executorAddress) ? globalThis.String(object.executorAddress) : "",
    };
  },

  toJSON(message: QueryGetActionExecutorRequest): unknown {
    const obj: any = {};
    if (message.nftSchemaCode !== "") {
      obj.nftSchemaCode = message.nftSchemaCode;
    }
    if (message.executorAddress !== "") {
      obj.executorAddress = message.executorAddress;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryGetActionExecutorRequest>, I>>(base?: I): QueryGetActionExecutorRequest {
    return QueryGetActionExecutorRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryGetActionExecutorRequest>, I>>(
    object: I,
  ): QueryGetActionExecutorRequest {
    const message = createBaseQueryGetActionExecutorRequest();
    message.nftSchemaCode = object.nftSchemaCode ?? "";
    message.executorAddress = object.executorAddress ?? "";
    return message;
  },
};

function createBaseQueryGetActionExecutorResponse(): QueryGetActionExecutorResponse {
  return { actionExecutor: undefined };
}

export const QueryGetActionExecutorResponse: MessageFns<QueryGetActionExecutorResponse> = {
  encode(message: QueryGetActionExecutorResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.actionExecutor !== undefined) {
      ActionExecutor.encode(message.actionExecutor, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryGetActionExecutorResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryGetActionExecutorResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.actionExecutor = ActionExecutor.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryGetActionExecutorResponse {
    return {
      actionExecutor: isSet(object.actionExecutor) ? ActionExecutor.fromJSON(object.actionExecutor) : undefined,
    };
  },

  toJSON(message: QueryGetActionExecutorResponse): unknown {
    const obj: any = {};
    if (message.actionExecutor !== undefined) {
      obj.actionExecutor = ActionExecutor.toJSON(message.actionExecutor);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryGetActionExecutorResponse>, I>>(base?: I): QueryGetActionExecutorResponse {
    return QueryGetActionExecutorResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryGetActionExecutorResponse>, I>>(
    object: I,
  ): QueryGetActionExecutorResponse {
    const message = createBaseQueryGetActionExecutorResponse();
    message.actionExecutor = (object.actionExecutor !== undefined && object.actionExecutor !== null)
      ? ActionExecutor.fromPartial(object.actionExecutor)
      : undefined;
    return message;
  },
};

function createBaseQueryAllActionExecutorRequest(): QueryAllActionExecutorRequest {
  return { pagination: undefined };
}

export const QueryAllActionExecutorRequest: MessageFns<QueryAllActionExecutorRequest> = {
  encode(message: QueryAllActionExecutorRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.pagination !== undefined) {
      PageRequest.encode(message.pagination, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryAllActionExecutorRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryAllActionExecutorRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.pagination = PageRequest.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryAllActionExecutorRequest {
    return { pagination: isSet(object.pagination) ? PageRequest.fromJSON(object.pagination) : undefined };
  },

  toJSON(message: QueryAllActionExecutorRequest): unknown {
    const obj: any = {};
    if (message.pagination !== undefined) {
      obj.pagination = PageRequest.toJSON(message.pagination);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryAllActionExecutorRequest>, I>>(base?: I): QueryAllActionExecutorRequest {
    return QueryAllActionExecutorRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryAllActionExecutorRequest>, I>>(
    object: I,
  ): QueryAllActionExecutorRequest {
    const message = createBaseQueryAllActionExecutorRequest();
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? PageRequest.fromPartial(object.pagination)
      : undefined;
    return message;
  },
};

function createBaseQueryAllActionExecutorResponse(): QueryAllActionExecutorResponse {
  return { actionExecutor: [], pagination: undefined };
}

export const QueryAllActionExecutorResponse: MessageFns<QueryAllActionExecutorResponse> = {
  encode(message: QueryAllActionExecutorResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.actionExecutor) {
      ActionExecutor.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.pagination !== undefined) {
      PageResponse.encode(message.pagination, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryAllActionExecutorResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryAllActionExecutorResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.actionExecutor.push(ActionExecutor.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pagination = PageResponse.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryAllActionExecutorResponse {
    return {
      actionExecutor: globalThis.Array.isArray(object?.actionExecutor)
        ? object.actionExecutor.map((e: any) => ActionExecutor.fromJSON(e))
        : [],
      pagination: isSet(object.pagination) ? PageResponse.fromJSON(object.pagination) : undefined,
    };
  },

  toJSON(message: QueryAllActionExecutorResponse): unknown {
    const obj: any = {};
    if (message.actionExecutor?.length) {
      obj.actionExecutor = message.actionExecutor.map((e) => ActionExecutor.toJSON(e));
    }
    if (message.pagination !== undefined) {
      obj.pagination = PageResponse.toJSON(message.pagination);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryAllActionExecutorResponse>, I>>(base?: I): QueryAllActionExecutorResponse {
    return QueryAllActionExecutorResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryAllActionExecutorResponse>, I>>(
    object: I,
  ): QueryAllActionExecutorResponse {
    const message = createBaseQueryAllActionExecutorResponse();
    message.actionExecutor = object.actionExecutor?.map((e) => ActionExecutor.fromPartial(e)) || [];
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? PageResponse.fromPartial(object.pagination)
      : undefined;
    return message;
  },
};

function createBaseQueryGetSchemaAttributeRequest(): QueryGetSchemaAttributeRequest {
  return { nftSchemaCode: "", name: "" };
}

export const QueryGetSchemaAttributeRequest: MessageFns<QueryGetSchemaAttributeRequest> = {
  encode(message: QueryGetSchemaAttributeRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.nftSchemaCode !== "") {
      writer.uint32(10).string(message.nftSchemaCode);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryGetSchemaAttributeRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryGetSchemaAttributeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.nftSchemaCode = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryGetSchemaAttributeRequest {
    return {
      nftSchemaCode: isSet(object.nftSchemaCode) ? globalThis.String(object.nftSchemaCode) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
    };
  },

  toJSON(message: QueryGetSchemaAttributeRequest): unknown {
    const obj: any = {};
    if (message.nftSchemaCode !== "") {
      obj.nftSchemaCode = message.nftSchemaCode;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryGetSchemaAttributeRequest>, I>>(base?: I): QueryGetSchemaAttributeRequest {
    return QueryGetSchemaAttributeRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryGetSchemaAttributeRequest>, I>>(
    object: I,
  ): QueryGetSchemaAttributeRequest {
    const message = createBaseQueryGetSchemaAttributeRequest();
    message.nftSchemaCode = object.nftSchemaCode ?? "";
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseQueryGetSchemaAttributeResponse(): QueryGetSchemaAttributeResponse {
  return { schemaAttribute: undefined };
}

export const QueryGetSchemaAttributeResponse: MessageFns<QueryGetSchemaAttributeResponse> = {
  encode(message: QueryGetSchemaAttributeResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.schemaAttribute !== undefined) {
      SchemaAttribute.encode(message.schemaAttribute, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryGetSchemaAttributeResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryGetSchemaAttributeResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.schemaAttribute = SchemaAttribute.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryGetSchemaAttributeResponse {
    return {
      schemaAttribute: isSet(object.schemaAttribute) ? SchemaAttribute.fromJSON(object.schemaAttribute) : undefined,
    };
  },

  toJSON(message: QueryGetSchemaAttributeResponse): unknown {
    const obj: any = {};
    if (message.schemaAttribute !== undefined) {
      obj.schemaAttribute = SchemaAttribute.toJSON(message.schemaAttribute);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryGetSchemaAttributeResponse>, I>>(base?: I): QueryGetSchemaAttributeResponse {
    return QueryGetSchemaAttributeResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryGetSchemaAttributeResponse>, I>>(
    object: I,
  ): QueryGetSchemaAttributeResponse {
    const message = createBaseQueryGetSchemaAttributeResponse();
    message.schemaAttribute = (object.schemaAttribute !== undefined && object.schemaAttribute !== null)
      ? SchemaAttribute.fromPartial(object.schemaAttribute)
      : undefined;
    return message;
  },
};

function createBaseQueryAllSchemaAttributeRequest(): QueryAllSchemaAttributeRequest {
  return { nftSchemaCode: "", pagination: undefined };
}

export const QueryAllSchemaAttributeRequest: MessageFns<QueryAllSchemaAttributeRequest> = {
  encode(message: QueryAllSchemaAttributeRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.nftSchemaCode !== "") {
      writer.uint32(10).string(message.nftSchemaCode);
    }
    if (message.pagination !== undefined) {
      PageRequest.encode(message.pagination, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryAllSchemaAttributeRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryAllSchemaAttributeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.nftSchemaCode = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pagination = PageRequest.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryAllSchemaAttributeRequest {
    return {
      nftSchemaCode: isSet(object.nftSchemaCode) ? globalThis.String(object.nftSchemaCode) : "",
      pagination: isSet(object.pagination) ? PageRequest.fromJSON(object.pagination) : undefined,
    };
  },

  toJSON(message: QueryAllSchemaAttributeRequest): unknown {
    const obj: any = {};
    if (message.nftSchemaCode !== "") {
      obj.nftSchemaCode = message.nftSchemaCode;
    }
    if (message.pagination !== undefined) {
      obj.pagination = PageRequest.toJSON(message.pagination);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryAllSchemaAttributeRequest>, I>>(base?: I): QueryAllSchemaAttributeRequest {
    return QueryAllSchemaAttributeRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryAllSchemaAttributeRequest>, I>>(
    object: I,
  ): QueryAllSchemaAttributeRequest {
    const message = createBaseQueryAllSchemaAttributeRequest();
    message.nftSchemaCode = object.nftSchemaCode ?? "";
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? PageRequest.fromPartial(object.pagination)
      : undefined;
    return message;
  },
};

function createBaseQueryAllSchemaAttributeResponse(): QueryAllSchemaAttributeResponse {
  return { schemaAttribute: [], pagination: undefined };
}

export const QueryAllSchemaAttributeResponse: MessageFns<QueryAllSchemaAttributeResponse> = {
  encode(message: QueryAllSchemaAttributeResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.schemaAttribute) {
      SchemaAttribute.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.pagination !== undefined) {
      PageResponse.encode(message.pagination, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryAllSchemaAttributeResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryAllSchemaAttributeResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.schemaAttribute.push(SchemaAttribute.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pagination = PageResponse.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryAllSchemaAttributeResponse {
    return {
      schemaAttribute: globalThis.Array.isArray(object?.schemaAttribute)
        ? object.schemaAttribute.map((e: any) => SchemaAttribute.fromJSON(e))
        : [],
      pagination: isSet(object.pagination) ? PageResponse.fromJSON(object.pagination) : undefined,
    };
  },

  toJSON(message: QueryAllSchemaAttributeResponse): unknown {
    const obj: any = {};
    if (message.schemaAttribute?.length) {
      obj.schemaAttribute = message.schemaAttribute.map((e) => SchemaAttribute.toJSON(e));
    }
    if (message.pagination !== undefined) {
      obj.pagination = PageResponse.toJSON(message.pagination);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryAllSchemaAttributeResponse>, I>>(base?: I): QueryAllSchemaAttributeResponse {
    return QueryAllSchemaAttributeResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryAllSchemaAttributeResponse>, I>>(
    object: I,
  ): QueryAllSchemaAttributeResponse {
    const message = createBaseQueryAllSchemaAttributeResponse();
    message.schemaAttribute = object.schemaAttribute?.map((e) => SchemaAttribute.fromPartial(e)) || [];
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? PageResponse.fromPartial(object.pagination)
      : undefined;
    return message;
  },
};

function createBaseQueryListAttributeBySchemaRequest(): QueryListAttributeBySchemaRequest {
  return { nftSchemaCode: "" };
}

export const QueryListAttributeBySchemaRequest: MessageFns<QueryListAttributeBySchemaRequest> = {
  encode(message: QueryListAttributeBySchemaRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.nftSchemaCode !== "") {
      writer.uint32(10).string(message.nftSchemaCode);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryListAttributeBySchemaRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryListAttributeBySchemaRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.nftSchemaCode = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryListAttributeBySchemaRequest {
    return { nftSchemaCode: isSet(object.nftSchemaCode) ? globalThis.String(object.nftSchemaCode) : "" };
  },

  toJSON(message: QueryListAttributeBySchemaRequest): unknown {
    const obj: any = {};
    if (message.nftSchemaCode !== "") {
      obj.nftSchemaCode = message.nftSchemaCode;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryListAttributeBySchemaRequest>, I>>(
    base?: I,
  ): QueryListAttributeBySchemaRequest {
    return QueryListAttributeBySchemaRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryListAttributeBySchemaRequest>, I>>(
    object: I,
  ): QueryListAttributeBySchemaRequest {
    const message = createBaseQueryListAttributeBySchemaRequest();
    message.nftSchemaCode = object.nftSchemaCode ?? "";
    return message;
  },
};

function createBaseQueryListAttributeBySchemaResponse(): QueryListAttributeBySchemaResponse {
  return { schemaAttribute: [] };
}

export const QueryListAttributeBySchemaResponse: MessageFns<QueryListAttributeBySchemaResponse> = {
  encode(message: QueryListAttributeBySchemaResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.schemaAttribute) {
      SchemaAttribute.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryListAttributeBySchemaResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryListAttributeBySchemaResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.schemaAttribute.push(SchemaAttribute.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryListAttributeBySchemaResponse {
    return {
      schemaAttribute: globalThis.Array.isArray(object?.schemaAttribute)
        ? object.schemaAttribute.map((e: any) => SchemaAttribute.fromJSON(e))
        : [],
    };
  },

  toJSON(message: QueryListAttributeBySchemaResponse): unknown {
    const obj: any = {};
    if (message.schemaAttribute?.length) {
      obj.schemaAttribute = message.schemaAttribute.map((e) => SchemaAttribute.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryListAttributeBySchemaResponse>, I>>(
    base?: I,
  ): QueryListAttributeBySchemaResponse {
    return QueryListAttributeBySchemaResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryListAttributeBySchemaResponse>, I>>(
    object: I,
  ): QueryListAttributeBySchemaResponse {
    const message = createBaseQueryListAttributeBySchemaResponse();
    message.schemaAttribute = object.schemaAttribute?.map((e) => SchemaAttribute.fromPartial(e)) || [];
    return message;
  },
};

function createBaseQueryGetActionOfSchemaRequest(): QueryGetActionOfSchemaRequest {
  return { nftSchemaCode: "", name: "" };
}

export const QueryGetActionOfSchemaRequest: MessageFns<QueryGetActionOfSchemaRequest> = {
  encode(message: QueryGetActionOfSchemaRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.nftSchemaCode !== "") {
      writer.uint32(10).string(message.nftSchemaCode);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryGetActionOfSchemaRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryGetActionOfSchemaRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.nftSchemaCode = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryGetActionOfSchemaRequest {
    return {
      nftSchemaCode: isSet(object.nftSchemaCode) ? globalThis.String(object.nftSchemaCode) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
    };
  },

  toJSON(message: QueryGetActionOfSchemaRequest): unknown {
    const obj: any = {};
    if (message.nftSchemaCode !== "") {
      obj.nftSchemaCode = message.nftSchemaCode;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryGetActionOfSchemaRequest>, I>>(base?: I): QueryGetActionOfSchemaRequest {
    return QueryGetActionOfSchemaRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryGetActionOfSchemaRequest>, I>>(
    object: I,
  ): QueryGetActionOfSchemaRequest {
    const message = createBaseQueryGetActionOfSchemaRequest();
    message.nftSchemaCode = object.nftSchemaCode ?? "";
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseQueryGetActionOfSchemaResponse(): QueryGetActionOfSchemaResponse {
  return { actionOfSchema: undefined };
}

export const QueryGetActionOfSchemaResponse: MessageFns<QueryGetActionOfSchemaResponse> = {
  encode(message: QueryGetActionOfSchemaResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.actionOfSchema !== undefined) {
      ActionOfSchema.encode(message.actionOfSchema, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryGetActionOfSchemaResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryGetActionOfSchemaResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.actionOfSchema = ActionOfSchema.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryGetActionOfSchemaResponse {
    return {
      actionOfSchema: isSet(object.actionOfSchema) ? ActionOfSchema.fromJSON(object.actionOfSchema) : undefined,
    };
  },

  toJSON(message: QueryGetActionOfSchemaResponse): unknown {
    const obj: any = {};
    if (message.actionOfSchema !== undefined) {
      obj.actionOfSchema = ActionOfSchema.toJSON(message.actionOfSchema);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryGetActionOfSchemaResponse>, I>>(base?: I): QueryGetActionOfSchemaResponse {
    return QueryGetActionOfSchemaResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryGetActionOfSchemaResponse>, I>>(
    object: I,
  ): QueryGetActionOfSchemaResponse {
    const message = createBaseQueryGetActionOfSchemaResponse();
    message.actionOfSchema = (object.actionOfSchema !== undefined && object.actionOfSchema !== null)
      ? ActionOfSchema.fromPartial(object.actionOfSchema)
      : undefined;
    return message;
  },
};

function createBaseQueryAllActionOfSchemaRequest(): QueryAllActionOfSchemaRequest {
  return { pagination: undefined };
}

export const QueryAllActionOfSchemaRequest: MessageFns<QueryAllActionOfSchemaRequest> = {
  encode(message: QueryAllActionOfSchemaRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.pagination !== undefined) {
      PageRequest.encode(message.pagination, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryAllActionOfSchemaRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryAllActionOfSchemaRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.pagination = PageRequest.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryAllActionOfSchemaRequest {
    return { pagination: isSet(object.pagination) ? PageRequest.fromJSON(object.pagination) : undefined };
  },

  toJSON(message: QueryAllActionOfSchemaRequest): unknown {
    const obj: any = {};
    if (message.pagination !== undefined) {
      obj.pagination = PageRequest.toJSON(message.pagination);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryAllActionOfSchemaRequest>, I>>(base?: I): QueryAllActionOfSchemaRequest {
    return QueryAllActionOfSchemaRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryAllActionOfSchemaRequest>, I>>(
    object: I,
  ): QueryAllActionOfSchemaRequest {
    const message = createBaseQueryAllActionOfSchemaRequest();
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? PageRequest.fromPartial(object.pagination)
      : undefined;
    return message;
  },
};

function createBaseQueryAllActionOfSchemaResponse(): QueryAllActionOfSchemaResponse {
  return { actionOfSchema: [], pagination: undefined };
}

export const QueryAllActionOfSchemaResponse: MessageFns<QueryAllActionOfSchemaResponse> = {
  encode(message: QueryAllActionOfSchemaResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.actionOfSchema) {
      ActionOfSchema.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.pagination !== undefined) {
      PageResponse.encode(message.pagination, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryAllActionOfSchemaResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryAllActionOfSchemaResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.actionOfSchema.push(ActionOfSchema.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pagination = PageResponse.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryAllActionOfSchemaResponse {
    return {
      actionOfSchema: globalThis.Array.isArray(object?.actionOfSchema)
        ? object.actionOfSchema.map((e: any) => ActionOfSchema.fromJSON(e))
        : [],
      pagination: isSet(object.pagination) ? PageResponse.fromJSON(object.pagination) : undefined,
    };
  },

  toJSON(message: QueryAllActionOfSchemaResponse): unknown {
    const obj: any = {};
    if (message.actionOfSchema?.length) {
      obj.actionOfSchema = message.actionOfSchema.map((e) => ActionOfSchema.toJSON(e));
    }
    if (message.pagination !== undefined) {
      obj.pagination = PageResponse.toJSON(message.pagination);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryAllActionOfSchemaResponse>, I>>(base?: I): QueryAllActionOfSchemaResponse {
    return QueryAllActionOfSchemaResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryAllActionOfSchemaResponse>, I>>(
    object: I,
  ): QueryAllActionOfSchemaResponse {
    const message = createBaseQueryAllActionOfSchemaResponse();
    message.actionOfSchema = object.actionOfSchema?.map((e) => ActionOfSchema.fromPartial(e)) || [];
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? PageResponse.fromPartial(object.pagination)
      : undefined;
    return message;
  },
};

function createBaseQueryGetExecutorOfSchemaRequest(): QueryGetExecutorOfSchemaRequest {
  return { nftSchemaCode: "" };
}

export const QueryGetExecutorOfSchemaRequest: MessageFns<QueryGetExecutorOfSchemaRequest> = {
  encode(message: QueryGetExecutorOfSchemaRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.nftSchemaCode !== "") {
      writer.uint32(10).string(message.nftSchemaCode);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryGetExecutorOfSchemaRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryGetExecutorOfSchemaRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.nftSchemaCode = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryGetExecutorOfSchemaRequest {
    return { nftSchemaCode: isSet(object.nftSchemaCode) ? globalThis.String(object.nftSchemaCode) : "" };
  },

  toJSON(message: QueryGetExecutorOfSchemaRequest): unknown {
    const obj: any = {};
    if (message.nftSchemaCode !== "") {
      obj.nftSchemaCode = message.nftSchemaCode;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryGetExecutorOfSchemaRequest>, I>>(base?: I): QueryGetExecutorOfSchemaRequest {
    return QueryGetExecutorOfSchemaRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryGetExecutorOfSchemaRequest>, I>>(
    object: I,
  ): QueryGetExecutorOfSchemaRequest {
    const message = createBaseQueryGetExecutorOfSchemaRequest();
    message.nftSchemaCode = object.nftSchemaCode ?? "";
    return message;
  },
};

function createBaseQueryGetExecutorOfSchemaResponse(): QueryGetExecutorOfSchemaResponse {
  return { executorOfSchema: undefined };
}

export const QueryGetExecutorOfSchemaResponse: MessageFns<QueryGetExecutorOfSchemaResponse> = {
  encode(message: QueryGetExecutorOfSchemaResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.executorOfSchema !== undefined) {
      ExecutorOfSchema.encode(message.executorOfSchema, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryGetExecutorOfSchemaResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryGetExecutorOfSchemaResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.executorOfSchema = ExecutorOfSchema.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryGetExecutorOfSchemaResponse {
    return {
      executorOfSchema: isSet(object.executorOfSchema) ? ExecutorOfSchema.fromJSON(object.executorOfSchema) : undefined,
    };
  },

  toJSON(message: QueryGetExecutorOfSchemaResponse): unknown {
    const obj: any = {};
    if (message.executorOfSchema !== undefined) {
      obj.executorOfSchema = ExecutorOfSchema.toJSON(message.executorOfSchema);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryGetExecutorOfSchemaResponse>, I>>(
    base?: I,
  ): QueryGetExecutorOfSchemaResponse {
    return QueryGetExecutorOfSchemaResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryGetExecutorOfSchemaResponse>, I>>(
    object: I,
  ): QueryGetExecutorOfSchemaResponse {
    const message = createBaseQueryGetExecutorOfSchemaResponse();
    message.executorOfSchema = (object.executorOfSchema !== undefined && object.executorOfSchema !== null)
      ? ExecutorOfSchema.fromPartial(object.executorOfSchema)
      : undefined;
    return message;
  },
};

function createBaseQueryAllExecutorOfSchemaRequest(): QueryAllExecutorOfSchemaRequest {
  return { pagination: undefined };
}

export const QueryAllExecutorOfSchemaRequest: MessageFns<QueryAllExecutorOfSchemaRequest> = {
  encode(message: QueryAllExecutorOfSchemaRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.pagination !== undefined) {
      PageRequest.encode(message.pagination, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryAllExecutorOfSchemaRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryAllExecutorOfSchemaRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.pagination = PageRequest.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryAllExecutorOfSchemaRequest {
    return { pagination: isSet(object.pagination) ? PageRequest.fromJSON(object.pagination) : undefined };
  },

  toJSON(message: QueryAllExecutorOfSchemaRequest): unknown {
    const obj: any = {};
    if (message.pagination !== undefined) {
      obj.pagination = PageRequest.toJSON(message.pagination);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryAllExecutorOfSchemaRequest>, I>>(base?: I): QueryAllExecutorOfSchemaRequest {
    return QueryAllExecutorOfSchemaRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryAllExecutorOfSchemaRequest>, I>>(
    object: I,
  ): QueryAllExecutorOfSchemaRequest {
    const message = createBaseQueryAllExecutorOfSchemaRequest();
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? PageRequest.fromPartial(object.pagination)
      : undefined;
    return message;
  },
};

function createBaseQueryAllExecutorOfSchemaResponse(): QueryAllExecutorOfSchemaResponse {
  return { executorOfSchema: [], pagination: undefined };
}

export const QueryAllExecutorOfSchemaResponse: MessageFns<QueryAllExecutorOfSchemaResponse> = {
  encode(message: QueryAllExecutorOfSchemaResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.executorOfSchema) {
      ExecutorOfSchema.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.pagination !== undefined) {
      PageResponse.encode(message.pagination, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryAllExecutorOfSchemaResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryAllExecutorOfSchemaResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.executorOfSchema.push(ExecutorOfSchema.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pagination = PageResponse.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryAllExecutorOfSchemaResponse {
    return {
      executorOfSchema: globalThis.Array.isArray(object?.executorOfSchema)
        ? object.executorOfSchema.map((e: any) => ExecutorOfSchema.fromJSON(e))
        : [],
      pagination: isSet(object.pagination) ? PageResponse.fromJSON(object.pagination) : undefined,
    };
  },

  toJSON(message: QueryAllExecutorOfSchemaResponse): unknown {
    const obj: any = {};
    if (message.executorOfSchema?.length) {
      obj.executorOfSchema = message.executorOfSchema.map((e) => ExecutorOfSchema.toJSON(e));
    }
    if (message.pagination !== undefined) {
      obj.pagination = PageResponse.toJSON(message.pagination);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryAllExecutorOfSchemaResponse>, I>>(
    base?: I,
  ): QueryAllExecutorOfSchemaResponse {
    return QueryAllExecutorOfSchemaResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryAllExecutorOfSchemaResponse>, I>>(
    object: I,
  ): QueryAllExecutorOfSchemaResponse {
    const message = createBaseQueryAllExecutorOfSchemaResponse();
    message.executorOfSchema = object.executorOfSchema?.map((e) => ExecutorOfSchema.fromPartial(e)) || [];
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? PageResponse.fromPartial(object.pagination)
      : undefined;
    return message;
  },
};

function createBaseQueryGetVirtualActionRequest(): QueryGetVirtualActionRequest {
  return { nftSchemaCode: "", name: "" };
}

export const QueryGetVirtualActionRequest: MessageFns<QueryGetVirtualActionRequest> = {
  encode(message: QueryGetVirtualActionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.nftSchemaCode !== "") {
      writer.uint32(10).string(message.nftSchemaCode);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryGetVirtualActionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryGetVirtualActionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.nftSchemaCode = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryGetVirtualActionRequest {
    return {
      nftSchemaCode: isSet(object.nftSchemaCode) ? globalThis.String(object.nftSchemaCode) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
    };
  },

  toJSON(message: QueryGetVirtualActionRequest): unknown {
    const obj: any = {};
    if (message.nftSchemaCode !== "") {
      obj.nftSchemaCode = message.nftSchemaCode;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryGetVirtualActionRequest>, I>>(base?: I): QueryGetVirtualActionRequest {
    return QueryGetVirtualActionRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryGetVirtualActionRequest>, I>>(object: I): QueryGetVirtualActionRequest {
    const message = createBaseQueryGetVirtualActionRequest();
    message.nftSchemaCode = object.nftSchemaCode ?? "";
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseQueryGetVirtualActionResponse(): QueryGetVirtualActionResponse {
  return { virtualAction: undefined };
}

export const QueryGetVirtualActionResponse: MessageFns<QueryGetVirtualActionResponse> = {
  encode(message: QueryGetVirtualActionResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.virtualAction !== undefined) {
      VirtualAction.encode(message.virtualAction, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryGetVirtualActionResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryGetVirtualActionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.virtualAction = VirtualAction.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryGetVirtualActionResponse {
    return { virtualAction: isSet(object.virtualAction) ? VirtualAction.fromJSON(object.virtualAction) : undefined };
  },

  toJSON(message: QueryGetVirtualActionResponse): unknown {
    const obj: any = {};
    if (message.virtualAction !== undefined) {
      obj.virtualAction = VirtualAction.toJSON(message.virtualAction);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryGetVirtualActionResponse>, I>>(base?: I): QueryGetVirtualActionResponse {
    return QueryGetVirtualActionResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryGetVirtualActionResponse>, I>>(
    object: I,
  ): QueryGetVirtualActionResponse {
    const message = createBaseQueryGetVirtualActionResponse();
    message.virtualAction = (object.virtualAction !== undefined && object.virtualAction !== null)
      ? VirtualAction.fromPartial(object.virtualAction)
      : undefined;
    return message;
  },
};

function createBaseQueryAllVirtualActionRequest(): QueryAllVirtualActionRequest {
  return { nftSchemaCode: "", pagination: undefined };
}

export const QueryAllVirtualActionRequest: MessageFns<QueryAllVirtualActionRequest> = {
  encode(message: QueryAllVirtualActionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.nftSchemaCode !== "") {
      writer.uint32(10).string(message.nftSchemaCode);
    }
    if (message.pagination !== undefined) {
      PageRequest.encode(message.pagination, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryAllVirtualActionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryAllVirtualActionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.nftSchemaCode = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pagination = PageRequest.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryAllVirtualActionRequest {
    return {
      nftSchemaCode: isSet(object.nftSchemaCode) ? globalThis.String(object.nftSchemaCode) : "",
      pagination: isSet(object.pagination) ? PageRequest.fromJSON(object.pagination) : undefined,
    };
  },

  toJSON(message: QueryAllVirtualActionRequest): unknown {
    const obj: any = {};
    if (message.nftSchemaCode !== "") {
      obj.nftSchemaCode = message.nftSchemaCode;
    }
    if (message.pagination !== undefined) {
      obj.pagination = PageRequest.toJSON(message.pagination);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryAllVirtualActionRequest>, I>>(base?: I): QueryAllVirtualActionRequest {
    return QueryAllVirtualActionRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryAllVirtualActionRequest>, I>>(object: I): QueryAllVirtualActionRequest {
    const message = createBaseQueryAllVirtualActionRequest();
    message.nftSchemaCode = object.nftSchemaCode ?? "";
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? PageRequest.fromPartial(object.pagination)
      : undefined;
    return message;
  },
};

function createBaseQueryAllVirtualActionResponse(): QueryAllVirtualActionResponse {
  return { virtualAction: [], pagination: undefined };
}

export const QueryAllVirtualActionResponse: MessageFns<QueryAllVirtualActionResponse> = {
  encode(message: QueryAllVirtualActionResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.virtualAction) {
      VirtualAction.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.pagination !== undefined) {
      PageResponse.encode(message.pagination, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryAllVirtualActionResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryAllVirtualActionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.virtualAction.push(VirtualAction.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pagination = PageResponse.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryAllVirtualActionResponse {
    return {
      virtualAction: globalThis.Array.isArray(object?.virtualAction)
        ? object.virtualAction.map((e: any) => VirtualAction.fromJSON(e))
        : [],
      pagination: isSet(object.pagination) ? PageResponse.fromJSON(object.pagination) : undefined,
    };
  },

  toJSON(message: QueryAllVirtualActionResponse): unknown {
    const obj: any = {};
    if (message.virtualAction?.length) {
      obj.virtualAction = message.virtualAction.map((e) => VirtualAction.toJSON(e));
    }
    if (message.pagination !== undefined) {
      obj.pagination = PageResponse.toJSON(message.pagination);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryAllVirtualActionResponse>, I>>(base?: I): QueryAllVirtualActionResponse {
    return QueryAllVirtualActionResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryAllVirtualActionResponse>, I>>(
    object: I,
  ): QueryAllVirtualActionResponse {
    const message = createBaseQueryAllVirtualActionResponse();
    message.virtualAction = object.virtualAction?.map((e) => VirtualAction.fromPartial(e)) || [];
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? PageResponse.fromPartial(object.pagination)
      : undefined;
    return message;
  },
};

function createBaseQueryGetVirtualSchemaRequest(): QueryGetVirtualSchemaRequest {
  return { nftSchemaCode: "" };
}

export const QueryGetVirtualSchemaRequest: MessageFns<QueryGetVirtualSchemaRequest> = {
  encode(message: QueryGetVirtualSchemaRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.nftSchemaCode !== "") {
      writer.uint32(10).string(message.nftSchemaCode);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryGetVirtualSchemaRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryGetVirtualSchemaRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.nftSchemaCode = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryGetVirtualSchemaRequest {
    return { nftSchemaCode: isSet(object.nftSchemaCode) ? globalThis.String(object.nftSchemaCode) : "" };
  },

  toJSON(message: QueryGetVirtualSchemaRequest): unknown {
    const obj: any = {};
    if (message.nftSchemaCode !== "") {
      obj.nftSchemaCode = message.nftSchemaCode;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryGetVirtualSchemaRequest>, I>>(base?: I): QueryGetVirtualSchemaRequest {
    return QueryGetVirtualSchemaRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryGetVirtualSchemaRequest>, I>>(object: I): QueryGetVirtualSchemaRequest {
    const message = createBaseQueryGetVirtualSchemaRequest();
    message.nftSchemaCode = object.nftSchemaCode ?? "";
    return message;
  },
};

function createBaseQueryGetVirtualSchemaResponse(): QueryGetVirtualSchemaResponse {
  return { virtualSchema: undefined };
}

export const QueryGetVirtualSchemaResponse: MessageFns<QueryGetVirtualSchemaResponse> = {
  encode(message: QueryGetVirtualSchemaResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.virtualSchema !== undefined) {
      VirtualSchema.encode(message.virtualSchema, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryGetVirtualSchemaResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryGetVirtualSchemaResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.virtualSchema = VirtualSchema.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryGetVirtualSchemaResponse {
    return { virtualSchema: isSet(object.virtualSchema) ? VirtualSchema.fromJSON(object.virtualSchema) : undefined };
  },

  toJSON(message: QueryGetVirtualSchemaResponse): unknown {
    const obj: any = {};
    if (message.virtualSchema !== undefined) {
      obj.virtualSchema = VirtualSchema.toJSON(message.virtualSchema);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryGetVirtualSchemaResponse>, I>>(base?: I): QueryGetVirtualSchemaResponse {
    return QueryGetVirtualSchemaResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryGetVirtualSchemaResponse>, I>>(
    object: I,
  ): QueryGetVirtualSchemaResponse {
    const message = createBaseQueryGetVirtualSchemaResponse();
    message.virtualSchema = (object.virtualSchema !== undefined && object.virtualSchema !== null)
      ? VirtualSchema.fromPartial(object.virtualSchema)
      : undefined;
    return message;
  },
};

function createBaseQueryAllVirtualSchemaRequest(): QueryAllVirtualSchemaRequest {
  return { pagination: undefined };
}

export const QueryAllVirtualSchemaRequest: MessageFns<QueryAllVirtualSchemaRequest> = {
  encode(message: QueryAllVirtualSchemaRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.pagination !== undefined) {
      PageRequest.encode(message.pagination, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryAllVirtualSchemaRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryAllVirtualSchemaRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.pagination = PageRequest.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryAllVirtualSchemaRequest {
    return { pagination: isSet(object.pagination) ? PageRequest.fromJSON(object.pagination) : undefined };
  },

  toJSON(message: QueryAllVirtualSchemaRequest): unknown {
    const obj: any = {};
    if (message.pagination !== undefined) {
      obj.pagination = PageRequest.toJSON(message.pagination);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryAllVirtualSchemaRequest>, I>>(base?: I): QueryAllVirtualSchemaRequest {
    return QueryAllVirtualSchemaRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryAllVirtualSchemaRequest>, I>>(object: I): QueryAllVirtualSchemaRequest {
    const message = createBaseQueryAllVirtualSchemaRequest();
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? PageRequest.fromPartial(object.pagination)
      : undefined;
    return message;
  },
};

function createBaseQueryAllVirtualSchemaResponse(): QueryAllVirtualSchemaResponse {
  return { virtualSchema: [], pagination: undefined };
}

export const QueryAllVirtualSchemaResponse: MessageFns<QueryAllVirtualSchemaResponse> = {
  encode(message: QueryAllVirtualSchemaResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.virtualSchema) {
      VirtualSchema.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.pagination !== undefined) {
      PageResponse.encode(message.pagination, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryAllVirtualSchemaResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryAllVirtualSchemaResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.virtualSchema.push(VirtualSchema.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pagination = PageResponse.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryAllVirtualSchemaResponse {
    return {
      virtualSchema: globalThis.Array.isArray(object?.virtualSchema)
        ? object.virtualSchema.map((e: any) => VirtualSchema.fromJSON(e))
        : [],
      pagination: isSet(object.pagination) ? PageResponse.fromJSON(object.pagination) : undefined,
    };
  },

  toJSON(message: QueryAllVirtualSchemaResponse): unknown {
    const obj: any = {};
    if (message.virtualSchema?.length) {
      obj.virtualSchema = message.virtualSchema.map((e) => VirtualSchema.toJSON(e));
    }
    if (message.pagination !== undefined) {
      obj.pagination = PageResponse.toJSON(message.pagination);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryAllVirtualSchemaResponse>, I>>(base?: I): QueryAllVirtualSchemaResponse {
    return QueryAllVirtualSchemaResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryAllVirtualSchemaResponse>, I>>(
    object: I,
  ): QueryAllVirtualSchemaResponse {
    const message = createBaseQueryAllVirtualSchemaResponse();
    message.virtualSchema = object.virtualSchema?.map((e) => VirtualSchema.fromPartial(e)) || [];
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? PageResponse.fromPartial(object.pagination)
      : undefined;
    return message;
  },
};

function createBaseQueryGetVirtualSchemaProposalRequest(): QueryGetVirtualSchemaProposalRequest {
  return { index: "" };
}

export const QueryGetVirtualSchemaProposalRequest: MessageFns<QueryGetVirtualSchemaProposalRequest> = {
  encode(message: QueryGetVirtualSchemaProposalRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.index !== "") {
      writer.uint32(10).string(message.index);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryGetVirtualSchemaProposalRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryGetVirtualSchemaProposalRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.index = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryGetVirtualSchemaProposalRequest {
    return { index: isSet(object.index) ? globalThis.String(object.index) : "" };
  },

  toJSON(message: QueryGetVirtualSchemaProposalRequest): unknown {
    const obj: any = {};
    if (message.index !== "") {
      obj.index = message.index;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryGetVirtualSchemaProposalRequest>, I>>(
    base?: I,
  ): QueryGetVirtualSchemaProposalRequest {
    return QueryGetVirtualSchemaProposalRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryGetVirtualSchemaProposalRequest>, I>>(
    object: I,
  ): QueryGetVirtualSchemaProposalRequest {
    const message = createBaseQueryGetVirtualSchemaProposalRequest();
    message.index = object.index ?? "";
    return message;
  },
};

function createBaseQueryGetVirtualSchemaProposalResponse(): QueryGetVirtualSchemaProposalResponse {
  return { virtualSchemaProposal: undefined };
}

export const QueryGetVirtualSchemaProposalResponse: MessageFns<QueryGetVirtualSchemaProposalResponse> = {
  encode(message: QueryGetVirtualSchemaProposalResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.virtualSchemaProposal !== undefined) {
      VirtualSchemaProposal.encode(message.virtualSchemaProposal, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryGetVirtualSchemaProposalResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryGetVirtualSchemaProposalResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.virtualSchemaProposal = VirtualSchemaProposal.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryGetVirtualSchemaProposalResponse {
    return {
      virtualSchemaProposal: isSet(object.virtualSchemaProposal)
        ? VirtualSchemaProposal.fromJSON(object.virtualSchemaProposal)
        : undefined,
    };
  },

  toJSON(message: QueryGetVirtualSchemaProposalResponse): unknown {
    const obj: any = {};
    if (message.virtualSchemaProposal !== undefined) {
      obj.virtualSchemaProposal = VirtualSchemaProposal.toJSON(message.virtualSchemaProposal);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryGetVirtualSchemaProposalResponse>, I>>(
    base?: I,
  ): QueryGetVirtualSchemaProposalResponse {
    return QueryGetVirtualSchemaProposalResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryGetVirtualSchemaProposalResponse>, I>>(
    object: I,
  ): QueryGetVirtualSchemaProposalResponse {
    const message = createBaseQueryGetVirtualSchemaProposalResponse();
    message.virtualSchemaProposal =
      (object.virtualSchemaProposal !== undefined && object.virtualSchemaProposal !== null)
        ? VirtualSchemaProposal.fromPartial(object.virtualSchemaProposal)
        : undefined;
    return message;
  },
};

function createBaseQueryAllVirtualSchemaProposalRequest(): QueryAllVirtualSchemaProposalRequest {
  return { pagination: undefined };
}

export const QueryAllVirtualSchemaProposalRequest: MessageFns<QueryAllVirtualSchemaProposalRequest> = {
  encode(message: QueryAllVirtualSchemaProposalRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.pagination !== undefined) {
      PageRequest.encode(message.pagination, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryAllVirtualSchemaProposalRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryAllVirtualSchemaProposalRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.pagination = PageRequest.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryAllVirtualSchemaProposalRequest {
    return { pagination: isSet(object.pagination) ? PageRequest.fromJSON(object.pagination) : undefined };
  },

  toJSON(message: QueryAllVirtualSchemaProposalRequest): unknown {
    const obj: any = {};
    if (message.pagination !== undefined) {
      obj.pagination = PageRequest.toJSON(message.pagination);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryAllVirtualSchemaProposalRequest>, I>>(
    base?: I,
  ): QueryAllVirtualSchemaProposalRequest {
    return QueryAllVirtualSchemaProposalRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryAllVirtualSchemaProposalRequest>, I>>(
    object: I,
  ): QueryAllVirtualSchemaProposalRequest {
    const message = createBaseQueryAllVirtualSchemaProposalRequest();
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? PageRequest.fromPartial(object.pagination)
      : undefined;
    return message;
  },
};

function createBaseQueryAllVirtualSchemaProposalResponse(): QueryAllVirtualSchemaProposalResponse {
  return { virtualSchemaProposal: [], pagination: undefined };
}

export const QueryAllVirtualSchemaProposalResponse: MessageFns<QueryAllVirtualSchemaProposalResponse> = {
  encode(message: QueryAllVirtualSchemaProposalResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.virtualSchemaProposal) {
      VirtualSchemaProposal.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.pagination !== undefined) {
      PageResponse.encode(message.pagination, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryAllVirtualSchemaProposalResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryAllVirtualSchemaProposalResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.virtualSchemaProposal.push(VirtualSchemaProposal.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pagination = PageResponse.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryAllVirtualSchemaProposalResponse {
    return {
      virtualSchemaProposal: globalThis.Array.isArray(object?.virtualSchemaProposal)
        ? object.virtualSchemaProposal.map((e: any) => VirtualSchemaProposal.fromJSON(e))
        : [],
      pagination: isSet(object.pagination) ? PageResponse.fromJSON(object.pagination) : undefined,
    };
  },

  toJSON(message: QueryAllVirtualSchemaProposalResponse): unknown {
    const obj: any = {};
    if (message.virtualSchemaProposal?.length) {
      obj.virtualSchemaProposal = message.virtualSchemaProposal.map((e) => VirtualSchemaProposal.toJSON(e));
    }
    if (message.pagination !== undefined) {
      obj.pagination = PageResponse.toJSON(message.pagination);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryAllVirtualSchemaProposalResponse>, I>>(
    base?: I,
  ): QueryAllVirtualSchemaProposalResponse {
    return QueryAllVirtualSchemaProposalResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryAllVirtualSchemaProposalResponse>, I>>(
    object: I,
  ): QueryAllVirtualSchemaProposalResponse {
    const message = createBaseQueryAllVirtualSchemaProposalResponse();
    message.virtualSchemaProposal = object.virtualSchemaProposal?.map((e) => VirtualSchemaProposal.fromPartial(e)) ||
      [];
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? PageResponse.fromPartial(object.pagination)
      : undefined;
    return message;
  },
};

function createBaseQueryListActiveProposalRequest(): QueryListActiveProposalRequest {
  return {};
}

export const QueryListActiveProposalRequest: MessageFns<QueryListActiveProposalRequest> = {
  encode(_: QueryListActiveProposalRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryListActiveProposalRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryListActiveProposalRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): QueryListActiveProposalRequest {
    return {};
  },

  toJSON(_: QueryListActiveProposalRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryListActiveProposalRequest>, I>>(base?: I): QueryListActiveProposalRequest {
    return QueryListActiveProposalRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryListActiveProposalRequest>, I>>(_: I): QueryListActiveProposalRequest {
    const message = createBaseQueryListActiveProposalRequest();
    return message;
  },
};

function createBaseQueryListActiveProposalResponse(): QueryListActiveProposalResponse {
  return { virtualSchemaProposal: [] };
}

export const QueryListActiveProposalResponse: MessageFns<QueryListActiveProposalResponse> = {
  encode(message: QueryListActiveProposalResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.virtualSchemaProposal) {
      VirtualSchemaProposal.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryListActiveProposalResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryListActiveProposalResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.virtualSchemaProposal.push(VirtualSchemaProposal.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryListActiveProposalResponse {
    return {
      virtualSchemaProposal: globalThis.Array.isArray(object?.virtualSchemaProposal)
        ? object.virtualSchemaProposal.map((e: any) => VirtualSchemaProposal.fromJSON(e))
        : [],
    };
  },

  toJSON(message: QueryListActiveProposalResponse): unknown {
    const obj: any = {};
    if (message.virtualSchemaProposal?.length) {
      obj.virtualSchemaProposal = message.virtualSchemaProposal.map((e) => VirtualSchemaProposal.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryListActiveProposalResponse>, I>>(base?: I): QueryListActiveProposalResponse {
    return QueryListActiveProposalResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryListActiveProposalResponse>, I>>(
    object: I,
  ): QueryListActiveProposalResponse {
    const message = createBaseQueryListActiveProposalResponse();
    message.virtualSchemaProposal = object.virtualSchemaProposal?.map((e) => VirtualSchemaProposal.fromPartial(e)) ||
      [];
    return message;
  },
};

function createBaseQueryGetLockSchemaFeeRequest(): QueryGetLockSchemaFeeRequest {
  return { index: "" };
}

export const QueryGetLockSchemaFeeRequest: MessageFns<QueryGetLockSchemaFeeRequest> = {
  encode(message: QueryGetLockSchemaFeeRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.index !== "") {
      writer.uint32(10).string(message.index);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryGetLockSchemaFeeRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryGetLockSchemaFeeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.index = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryGetLockSchemaFeeRequest {
    return { index: isSet(object.index) ? globalThis.String(object.index) : "" };
  },

  toJSON(message: QueryGetLockSchemaFeeRequest): unknown {
    const obj: any = {};
    if (message.index !== "") {
      obj.index = message.index;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryGetLockSchemaFeeRequest>, I>>(base?: I): QueryGetLockSchemaFeeRequest {
    return QueryGetLockSchemaFeeRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryGetLockSchemaFeeRequest>, I>>(object: I): QueryGetLockSchemaFeeRequest {
    const message = createBaseQueryGetLockSchemaFeeRequest();
    message.index = object.index ?? "";
    return message;
  },
};

function createBaseQueryGetLockSchemaFeeResponse(): QueryGetLockSchemaFeeResponse {
  return { lockSchemaFee: undefined };
}

export const QueryGetLockSchemaFeeResponse: MessageFns<QueryGetLockSchemaFeeResponse> = {
  encode(message: QueryGetLockSchemaFeeResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.lockSchemaFee !== undefined) {
      LockSchemaFee.encode(message.lockSchemaFee, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryGetLockSchemaFeeResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryGetLockSchemaFeeResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.lockSchemaFee = LockSchemaFee.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryGetLockSchemaFeeResponse {
    return { lockSchemaFee: isSet(object.lockSchemaFee) ? LockSchemaFee.fromJSON(object.lockSchemaFee) : undefined };
  },

  toJSON(message: QueryGetLockSchemaFeeResponse): unknown {
    const obj: any = {};
    if (message.lockSchemaFee !== undefined) {
      obj.lockSchemaFee = LockSchemaFee.toJSON(message.lockSchemaFee);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryGetLockSchemaFeeResponse>, I>>(base?: I): QueryGetLockSchemaFeeResponse {
    return QueryGetLockSchemaFeeResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryGetLockSchemaFeeResponse>, I>>(
    object: I,
  ): QueryGetLockSchemaFeeResponse {
    const message = createBaseQueryGetLockSchemaFeeResponse();
    message.lockSchemaFee = (object.lockSchemaFee !== undefined && object.lockSchemaFee !== null)
      ? LockSchemaFee.fromPartial(object.lockSchemaFee)
      : undefined;
    return message;
  },
};

function createBaseQueryAllLockSchemaFeeRequest(): QueryAllLockSchemaFeeRequest {
  return { pagination: undefined };
}

export const QueryAllLockSchemaFeeRequest: MessageFns<QueryAllLockSchemaFeeRequest> = {
  encode(message: QueryAllLockSchemaFeeRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.pagination !== undefined) {
      PageRequest.encode(message.pagination, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryAllLockSchemaFeeRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryAllLockSchemaFeeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.pagination = PageRequest.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryAllLockSchemaFeeRequest {
    return { pagination: isSet(object.pagination) ? PageRequest.fromJSON(object.pagination) : undefined };
  },

  toJSON(message: QueryAllLockSchemaFeeRequest): unknown {
    const obj: any = {};
    if (message.pagination !== undefined) {
      obj.pagination = PageRequest.toJSON(message.pagination);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryAllLockSchemaFeeRequest>, I>>(base?: I): QueryAllLockSchemaFeeRequest {
    return QueryAllLockSchemaFeeRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryAllLockSchemaFeeRequest>, I>>(object: I): QueryAllLockSchemaFeeRequest {
    const message = createBaseQueryAllLockSchemaFeeRequest();
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? PageRequest.fromPartial(object.pagination)
      : undefined;
    return message;
  },
};

function createBaseQueryAllLockSchemaFeeResponse(): QueryAllLockSchemaFeeResponse {
  return { lockSchemaFee: [], pagination: undefined };
}

export const QueryAllLockSchemaFeeResponse: MessageFns<QueryAllLockSchemaFeeResponse> = {
  encode(message: QueryAllLockSchemaFeeResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.lockSchemaFee) {
      LockSchemaFee.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.pagination !== undefined) {
      PageResponse.encode(message.pagination, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryAllLockSchemaFeeResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryAllLockSchemaFeeResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.lockSchemaFee.push(LockSchemaFee.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pagination = PageResponse.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryAllLockSchemaFeeResponse {
    return {
      lockSchemaFee: globalThis.Array.isArray(object?.lockSchemaFee)
        ? object.lockSchemaFee.map((e: any) => LockSchemaFee.fromJSON(e))
        : [],
      pagination: isSet(object.pagination) ? PageResponse.fromJSON(object.pagination) : undefined,
    };
  },

  toJSON(message: QueryAllLockSchemaFeeResponse): unknown {
    const obj: any = {};
    if (message.lockSchemaFee?.length) {
      obj.lockSchemaFee = message.lockSchemaFee.map((e) => LockSchemaFee.toJSON(e));
    }
    if (message.pagination !== undefined) {
      obj.pagination = PageResponse.toJSON(message.pagination);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryAllLockSchemaFeeResponse>, I>>(base?: I): QueryAllLockSchemaFeeResponse {
    return QueryAllLockSchemaFeeResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryAllLockSchemaFeeResponse>, I>>(
    object: I,
  ): QueryAllLockSchemaFeeResponse {
    const message = createBaseQueryAllLockSchemaFeeResponse();
    message.lockSchemaFee = object.lockSchemaFee?.map((e) => LockSchemaFee.fromPartial(e)) || [];
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? PageResponse.fromPartial(object.pagination)
      : undefined;
    return message;
  },
};

/** Query defines the gRPC querier service. */
export interface Query {
  /** Parameters queries the parameters of the module. */
  Params(request: QueryParamsRequest): Promise<QueryParamsResponse>;
  /** Queries a NFTSchema by index. */
  NFTSchema(request: QueryGetNFTSchemaRequest): Promise<QueryGetNFTSchemaResponse>;
  /** Queries a list of NFTSchema items. */
  NFTSchemaAll(request: QueryAllNFTSchemaRequest): Promise<QueryAllNFTSchemaResponse>;
  /** Queries a NftData by index. */
  NftData(request: QueryGetNftDataRequest): Promise<QueryGetNftDataResponse>;
  /** Queries a list of NftData items. */
  NftDataAll(request: QueryAllNftDataRequest): Promise<QueryAllNftDataResponse>;
  /** Queries a ActionByRefId by index. */
  ActionByRefId(request: QueryGetActionByRefIdRequest): Promise<QueryGetActionByRefIdResponse>;
  /** Queries a list of ActionByRefId items. */
  ActionByRefIdAll(request: QueryAllActionByRefIdRequest): Promise<QueryAllActionByRefIdResponse>;
  /** Queries a Organization by index. */
  Organization(request: QueryGetOrganizationRequest): Promise<QueryGetOrganizationResponse>;
  /** Queries a list of Organization items. */
  OrganizationAll(request: QueryAllOrganizationRequest): Promise<QueryAllOrganizationResponse>;
  /** Queries a NftCollection by index. */
  NftCollection(request: QueryGetNftCollectionRequest): Promise<QueryGetNftCollectionResponse>;
  /** Queries a NFTSchemaByContract by index. */
  NFTSchemaByContract(request: QueryGetNFTSchemaByContractRequest): Promise<QueryGetNFTSchemaByContractResponse>;
  /** Queries a list of NFTSchemaByContract items. */
  NFTSchemaByContractAll(request: QueryAllNFTSchemaByContractRequest): Promise<QueryAllNFTSchemaByContractResponse>;
  /** Queries a NFTFeeConfig by index. */
  NFTFeeConfig(request: QueryGetNFTFeeConfigRequest): Promise<QueryGetNFTFeeConfigResponse>;
  /** Queries a NFTFeeBalance by index. */
  NFTFeeBalance(request: QueryGetNFTFeeBalanceRequest): Promise<QueryGetNFTFeeBalanceResponse>;
  /** Queries a MetadataCreator by index. */
  MetadataCreator(request: QueryGetMetadataCreatorRequest): Promise<QueryGetMetadataCreatorResponse>;
  /** Queries a list of MetadataCreator items. */
  MetadataCreatorAll(request: QueryAllMetadataCreatorRequest): Promise<QueryAllMetadataCreatorResponse>;
  /** Queries a ActionExecutor by index. */
  ActionExecutor(request: QueryGetActionExecutorRequest): Promise<QueryGetActionExecutorResponse>;
  /** Queries a list of ActionExecutor items. */
  ActionExecutorAll(request: QueryAllActionExecutorRequest): Promise<QueryAllActionExecutorResponse>;
  /** Queries a SchemaAttribute by index. */
  SchemaAttribute(request: QueryGetSchemaAttributeRequest): Promise<QueryGetSchemaAttributeResponse>;
  /** Queries a list of SchemaAttribute items. */
  SchemaAttributeAll(request: QueryAllSchemaAttributeRequest): Promise<QueryAllSchemaAttributeResponse>;
  /** Queries a list of ListAttributeBySchema items. */
  ListAttributeBySchema(request: QueryListAttributeBySchemaRequest): Promise<QueryListAttributeBySchemaResponse>;
  /** Queries a ActionOfSchema by index. */
  ActionOfSchema(request: QueryGetActionOfSchemaRequest): Promise<QueryGetActionOfSchemaResponse>;
  /** Queries a list of ActionOfSchema items. */
  ActionOfSchemaAll(request: QueryAllActionOfSchemaRequest): Promise<QueryAllActionOfSchemaResponse>;
  /** Queries a ExecutorOfSchema by index. */
  ExecutorOfSchema(request: QueryGetExecutorOfSchemaRequest): Promise<QueryGetExecutorOfSchemaResponse>;
  /** Queries a list of ExecutorOfSchema items. */
  ExecutorOfSchemaAll(request: QueryAllExecutorOfSchemaRequest): Promise<QueryAllExecutorOfSchemaResponse>;
  /** Queries a Virtual by index */
  VirtualAction(request: QueryGetVirtualActionRequest): Promise<QueryGetVirtualActionResponse>;
  /** Queries a list of Virtual items. */
  VirtualActionAll(request: QueryAllVirtualActionRequest): Promise<QueryAllVirtualActionResponse>;
  /** Queries a VirtualSchema by index. */
  VirtualSchema(request: QueryGetVirtualSchemaRequest): Promise<QueryGetVirtualSchemaResponse>;
  /** Queries a list of VirtualSchema items. */
  VirtualSchemaAll(request: QueryAllVirtualSchemaRequest): Promise<QueryAllVirtualSchemaResponse>;
  /** Queries a VirtualSchemaProposal by index. */
  VirtualSchemaProposal(request: QueryGetVirtualSchemaProposalRequest): Promise<QueryGetVirtualSchemaProposalResponse>;
  /** Queries a list of VirtualSchemaProposal items. */
  VirtualSchemaProposalAll(
    request: QueryAllVirtualSchemaProposalRequest,
  ): Promise<QueryAllVirtualSchemaProposalResponse>;
  /** Queries a list of ListActiveProposal items. */
  ListActiveProposal(request: QueryListActiveProposalRequest): Promise<QueryListActiveProposalResponse>;
  /** Queries a LockSchemaFee by index. */
  LockSchemaFee(request: QueryGetLockSchemaFeeRequest): Promise<QueryGetLockSchemaFeeResponse>;
  /** Queries a list of LockSchemaFee items. */
  LockSchemaFeeAll(request: QueryAllLockSchemaFeeRequest): Promise<QueryAllLockSchemaFeeResponse>;
}

export const QueryServiceName = "sixprotocol.nftmngr.Query";
export class QueryClientImpl implements Query {
  private readonly rpc: Rpc;
  private readonly service: string;
  constructor(rpc: Rpc, opts?: { service?: string }) {
    this.service = opts?.service || QueryServiceName;
    this.rpc = rpc;
    this.Params = this.Params.bind(this);
    this.NFTSchema = this.NFTSchema.bind(this);
    this.NFTSchemaAll = this.NFTSchemaAll.bind(this);
    this.NftData = this.NftData.bind(this);
    this.NftDataAll = this.NftDataAll.bind(this);
    this.ActionByRefId = this.ActionByRefId.bind(this);
    this.ActionByRefIdAll = this.ActionByRefIdAll.bind(this);
    this.Organization = this.Organization.bind(this);
    this.OrganizationAll = this.OrganizationAll.bind(this);
    this.NftCollection = this.NftCollection.bind(this);
    this.NFTSchemaByContract = this.NFTSchemaByContract.bind(this);
    this.NFTSchemaByContractAll = this.NFTSchemaByContractAll.bind(this);
    this.NFTFeeConfig = this.NFTFeeConfig.bind(this);
    this.NFTFeeBalance = this.NFTFeeBalance.bind(this);
    this.MetadataCreator = this.MetadataCreator.bind(this);
    this.MetadataCreatorAll = this.MetadataCreatorAll.bind(this);
    this.ActionExecutor = this.ActionExecutor.bind(this);
    this.ActionExecutorAll = this.ActionExecutorAll.bind(this);
    this.SchemaAttribute = this.SchemaAttribute.bind(this);
    this.SchemaAttributeAll = this.SchemaAttributeAll.bind(this);
    this.ListAttributeBySchema = this.ListAttributeBySchema.bind(this);
    this.ActionOfSchema = this.ActionOfSchema.bind(this);
    this.ActionOfSchemaAll = this.ActionOfSchemaAll.bind(this);
    this.ExecutorOfSchema = this.ExecutorOfSchema.bind(this);
    this.ExecutorOfSchemaAll = this.ExecutorOfSchemaAll.bind(this);
    this.VirtualAction = this.VirtualAction.bind(this);
    this.VirtualActionAll = this.VirtualActionAll.bind(this);
    this.VirtualSchema = this.VirtualSchema.bind(this);
    this.VirtualSchemaAll = this.VirtualSchemaAll.bind(this);
    this.VirtualSchemaProposal = this.VirtualSchemaProposal.bind(this);
    this.VirtualSchemaProposalAll = this.VirtualSchemaProposalAll.bind(this);
    this.ListActiveProposal = this.ListActiveProposal.bind(this);
    this.LockSchemaFee = this.LockSchemaFee.bind(this);
    this.LockSchemaFeeAll = this.LockSchemaFeeAll.bind(this);
  }
  Params(request: QueryParamsRequest): Promise<QueryParamsResponse> {
    const data = QueryParamsRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "Params", data);
    return promise.then((data) => QueryParamsResponse.decode(new BinaryReader(data)));
  }

  NFTSchema(request: QueryGetNFTSchemaRequest): Promise<QueryGetNFTSchemaResponse> {
    const data = QueryGetNFTSchemaRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "NFTSchema", data);
    return promise.then((data) => QueryGetNFTSchemaResponse.decode(new BinaryReader(data)));
  }

  NFTSchemaAll(request: QueryAllNFTSchemaRequest): Promise<QueryAllNFTSchemaResponse> {
    const data = QueryAllNFTSchemaRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "NFTSchemaAll", data);
    return promise.then((data) => QueryAllNFTSchemaResponse.decode(new BinaryReader(data)));
  }

  NftData(request: QueryGetNftDataRequest): Promise<QueryGetNftDataResponse> {
    const data = QueryGetNftDataRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "NftData", data);
    return promise.then((data) => QueryGetNftDataResponse.decode(new BinaryReader(data)));
  }

  NftDataAll(request: QueryAllNftDataRequest): Promise<QueryAllNftDataResponse> {
    const data = QueryAllNftDataRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "NftDataAll", data);
    return promise.then((data) => QueryAllNftDataResponse.decode(new BinaryReader(data)));
  }

  ActionByRefId(request: QueryGetActionByRefIdRequest): Promise<QueryGetActionByRefIdResponse> {
    const data = QueryGetActionByRefIdRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "ActionByRefId", data);
    return promise.then((data) => QueryGetActionByRefIdResponse.decode(new BinaryReader(data)));
  }

  ActionByRefIdAll(request: QueryAllActionByRefIdRequest): Promise<QueryAllActionByRefIdResponse> {
    const data = QueryAllActionByRefIdRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "ActionByRefIdAll", data);
    return promise.then((data) => QueryAllActionByRefIdResponse.decode(new BinaryReader(data)));
  }

  Organization(request: QueryGetOrganizationRequest): Promise<QueryGetOrganizationResponse> {
    const data = QueryGetOrganizationRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "Organization", data);
    return promise.then((data) => QueryGetOrganizationResponse.decode(new BinaryReader(data)));
  }

  OrganizationAll(request: QueryAllOrganizationRequest): Promise<QueryAllOrganizationResponse> {
    const data = QueryAllOrganizationRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "OrganizationAll", data);
    return promise.then((data) => QueryAllOrganizationResponse.decode(new BinaryReader(data)));
  }

  NftCollection(request: QueryGetNftCollectionRequest): Promise<QueryGetNftCollectionResponse> {
    const data = QueryGetNftCollectionRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "NftCollection", data);
    return promise.then((data) => QueryGetNftCollectionResponse.decode(new BinaryReader(data)));
  }

  NFTSchemaByContract(request: QueryGetNFTSchemaByContractRequest): Promise<QueryGetNFTSchemaByContractResponse> {
    const data = QueryGetNFTSchemaByContractRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "NFTSchemaByContract", data);
    return promise.then((data) => QueryGetNFTSchemaByContractResponse.decode(new BinaryReader(data)));
  }

  NFTSchemaByContractAll(request: QueryAllNFTSchemaByContractRequest): Promise<QueryAllNFTSchemaByContractResponse> {
    const data = QueryAllNFTSchemaByContractRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "NFTSchemaByContractAll", data);
    return promise.then((data) => QueryAllNFTSchemaByContractResponse.decode(new BinaryReader(data)));
  }

  NFTFeeConfig(request: QueryGetNFTFeeConfigRequest): Promise<QueryGetNFTFeeConfigResponse> {
    const data = QueryGetNFTFeeConfigRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "NFTFeeConfig", data);
    return promise.then((data) => QueryGetNFTFeeConfigResponse.decode(new BinaryReader(data)));
  }

  NFTFeeBalance(request: QueryGetNFTFeeBalanceRequest): Promise<QueryGetNFTFeeBalanceResponse> {
    const data = QueryGetNFTFeeBalanceRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "NFTFeeBalance", data);
    return promise.then((data) => QueryGetNFTFeeBalanceResponse.decode(new BinaryReader(data)));
  }

  MetadataCreator(request: QueryGetMetadataCreatorRequest): Promise<QueryGetMetadataCreatorResponse> {
    const data = QueryGetMetadataCreatorRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "MetadataCreator", data);
    return promise.then((data) => QueryGetMetadataCreatorResponse.decode(new BinaryReader(data)));
  }

  MetadataCreatorAll(request: QueryAllMetadataCreatorRequest): Promise<QueryAllMetadataCreatorResponse> {
    const data = QueryAllMetadataCreatorRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "MetadataCreatorAll", data);
    return promise.then((data) => QueryAllMetadataCreatorResponse.decode(new BinaryReader(data)));
  }

  ActionExecutor(request: QueryGetActionExecutorRequest): Promise<QueryGetActionExecutorResponse> {
    const data = QueryGetActionExecutorRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "ActionExecutor", data);
    return promise.then((data) => QueryGetActionExecutorResponse.decode(new BinaryReader(data)));
  }

  ActionExecutorAll(request: QueryAllActionExecutorRequest): Promise<QueryAllActionExecutorResponse> {
    const data = QueryAllActionExecutorRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "ActionExecutorAll", data);
    return promise.then((data) => QueryAllActionExecutorResponse.decode(new BinaryReader(data)));
  }

  SchemaAttribute(request: QueryGetSchemaAttributeRequest): Promise<QueryGetSchemaAttributeResponse> {
    const data = QueryGetSchemaAttributeRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "SchemaAttribute", data);
    return promise.then((data) => QueryGetSchemaAttributeResponse.decode(new BinaryReader(data)));
  }

  SchemaAttributeAll(request: QueryAllSchemaAttributeRequest): Promise<QueryAllSchemaAttributeResponse> {
    const data = QueryAllSchemaAttributeRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "SchemaAttributeAll", data);
    return promise.then((data) => QueryAllSchemaAttributeResponse.decode(new BinaryReader(data)));
  }

  ListAttributeBySchema(request: QueryListAttributeBySchemaRequest): Promise<QueryListAttributeBySchemaResponse> {
    const data = QueryListAttributeBySchemaRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "ListAttributeBySchema", data);
    return promise.then((data) => QueryListAttributeBySchemaResponse.decode(new BinaryReader(data)));
  }

  ActionOfSchema(request: QueryGetActionOfSchemaRequest): Promise<QueryGetActionOfSchemaResponse> {
    const data = QueryGetActionOfSchemaRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "ActionOfSchema", data);
    return promise.then((data) => QueryGetActionOfSchemaResponse.decode(new BinaryReader(data)));
  }

  ActionOfSchemaAll(request: QueryAllActionOfSchemaRequest): Promise<QueryAllActionOfSchemaResponse> {
    const data = QueryAllActionOfSchemaRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "ActionOfSchemaAll", data);
    return promise.then((data) => QueryAllActionOfSchemaResponse.decode(new BinaryReader(data)));
  }

  ExecutorOfSchema(request: QueryGetExecutorOfSchemaRequest): Promise<QueryGetExecutorOfSchemaResponse> {
    const data = QueryGetExecutorOfSchemaRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "ExecutorOfSchema", data);
    return promise.then((data) => QueryGetExecutorOfSchemaResponse.decode(new BinaryReader(data)));
  }

  ExecutorOfSchemaAll(request: QueryAllExecutorOfSchemaRequest): Promise<QueryAllExecutorOfSchemaResponse> {
    const data = QueryAllExecutorOfSchemaRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "ExecutorOfSchemaAll", data);
    return promise.then((data) => QueryAllExecutorOfSchemaResponse.decode(new BinaryReader(data)));
  }

  VirtualAction(request: QueryGetVirtualActionRequest): Promise<QueryGetVirtualActionResponse> {
    const data = QueryGetVirtualActionRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "VirtualAction", data);
    return promise.then((data) => QueryGetVirtualActionResponse.decode(new BinaryReader(data)));
  }

  VirtualActionAll(request: QueryAllVirtualActionRequest): Promise<QueryAllVirtualActionResponse> {
    const data = QueryAllVirtualActionRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "VirtualActionAll", data);
    return promise.then((data) => QueryAllVirtualActionResponse.decode(new BinaryReader(data)));
  }

  VirtualSchema(request: QueryGetVirtualSchemaRequest): Promise<QueryGetVirtualSchemaResponse> {
    const data = QueryGetVirtualSchemaRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "VirtualSchema", data);
    return promise.then((data) => QueryGetVirtualSchemaResponse.decode(new BinaryReader(data)));
  }

  VirtualSchemaAll(request: QueryAllVirtualSchemaRequest): Promise<QueryAllVirtualSchemaResponse> {
    const data = QueryAllVirtualSchemaRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "VirtualSchemaAll", data);
    return promise.then((data) => QueryAllVirtualSchemaResponse.decode(new BinaryReader(data)));
  }

  VirtualSchemaProposal(request: QueryGetVirtualSchemaProposalRequest): Promise<QueryGetVirtualSchemaProposalResponse> {
    const data = QueryGetVirtualSchemaProposalRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "VirtualSchemaProposal", data);
    return promise.then((data) => QueryGetVirtualSchemaProposalResponse.decode(new BinaryReader(data)));
  }

  VirtualSchemaProposalAll(
    request: QueryAllVirtualSchemaProposalRequest,
  ): Promise<QueryAllVirtualSchemaProposalResponse> {
    const data = QueryAllVirtualSchemaProposalRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "VirtualSchemaProposalAll", data);
    return promise.then((data) => QueryAllVirtualSchemaProposalResponse.decode(new BinaryReader(data)));
  }

  ListActiveProposal(request: QueryListActiveProposalRequest): Promise<QueryListActiveProposalResponse> {
    const data = QueryListActiveProposalRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "ListActiveProposal", data);
    return promise.then((data) => QueryListActiveProposalResponse.decode(new BinaryReader(data)));
  }

  LockSchemaFee(request: QueryGetLockSchemaFeeRequest): Promise<QueryGetLockSchemaFeeResponse> {
    const data = QueryGetLockSchemaFeeRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "LockSchemaFee", data);
    return promise.then((data) => QueryGetLockSchemaFeeResponse.decode(new BinaryReader(data)));
  }

  LockSchemaFeeAll(request: QueryAllLockSchemaFeeRequest): Promise<QueryAllLockSchemaFeeResponse> {
    const data = QueryAllLockSchemaFeeRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "LockSchemaFeeAll", data);
    return promise.then((data) => QueryAllLockSchemaFeeResponse.decode(new BinaryReader(data)));
  }
}

interface Rpc {
  request(service: string, method: string, data: Uint8Array): Promise<Uint8Array>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
