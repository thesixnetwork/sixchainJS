// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.6.1
//   protoc               unknown
// source: sixprotocol/nftmngr/tx.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { Any } from "../../google/protobuf/any";
import { Action } from "./action";
import { FeeConfig } from "./nft_fee_config";
import { Params } from "./params";
import { VirtualAction } from "./virtual_action";
import {
  ProposalType,
  proposalTypeFromJSON,
  proposalTypeToJSON,
  RegistryStatus,
  registryStatusFromJSON,
  registryStatusToJSON,
  VirtualSchemaRegistryRequest,
} from "./virtual_schema";

export const protobufPackage = "sixprotocol.nftmngr";

export enum AttributeLocation {
  NFT_ATTRIBUTE = 0,
  TOKEN_ATTRIBUTE = 1,
  UNRECOGNIZED = -1,
}

export function attributeLocationFromJSON(object: any): AttributeLocation {
  switch (object) {
    case 0:
    case "NFT_ATTRIBUTE":
      return AttributeLocation.NFT_ATTRIBUTE;
    case 1:
    case "TOKEN_ATTRIBUTE":
      return AttributeLocation.TOKEN_ATTRIBUTE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return AttributeLocation.UNRECOGNIZED;
  }
}

export function attributeLocationToJSON(object: AttributeLocation): string {
  switch (object) {
    case AttributeLocation.NFT_ATTRIBUTE:
      return "NFT_ATTRIBUTE";
    case AttributeLocation.TOKEN_ATTRIBUTE:
      return "TOKEN_ATTRIBUTE";
    case AttributeLocation.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum AuthorizeTo {
  SYSTEM = 0,
  ALL = 1,
  UNRECOGNIZED = -1,
}

export function authorizeToFromJSON(object: any): AuthorizeTo {
  switch (object) {
    case 0:
    case "SYSTEM":
      return AuthorizeTo.SYSTEM;
    case 1:
    case "ALL":
      return AuthorizeTo.ALL;
    case -1:
    case "UNRECOGNIZED":
    default:
      return AuthorizeTo.UNRECOGNIZED;
  }
}

export function authorizeToToJSON(object: AuthorizeTo): string {
  switch (object) {
    case AuthorizeTo.SYSTEM:
      return "SYSTEM";
    case AuthorizeTo.ALL:
      return "ALL";
    case AuthorizeTo.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** MsgUpdateParams is the Msg/UpdateParams request type. */
export interface MsgUpdateParams {
  /**
   * authority is the address that controls the module (defaults to x/gov unless
   * overwritten).
   */
  authority: string;
  params: Params | undefined;
}

/**
 * MsgUpdateParamsResponse defines the response structure for executing a
 * MsgUpdateParams message.
 */
export interface MsgUpdateParamsResponse {
}

export interface MsgCreateNFTSchema {
  creator: string;
  nftSchemaBase64: string;
}

export interface MsgCreateNFTSchemaResponse {
  code: string;
}

export interface MsgCreateMetadata {
  creator: string;
  nftSchemaCode: string;
  tokenId: string;
  base64NFTData: string;
}

export interface MsgCreateMetadataResponse {
  nftSchemaCode: string;
  tokenId: string;
}

export interface OpenseaAttribute {
  traitType: string;
  value: Any | undefined;
}

export interface UpdatedOpenseaAttributes {
  attributes: OpenseaAttribute[];
}

export interface UpdatedOriginData {
  opensea?: UpdatedOpenseaAttributes | undefined;
}

/** ActionParameter */
export interface ActionParameter {
  name: string;
  value: string;
}

export interface MsgPerformActionByAdmin {
  creator: string;
  nftSchemaCode: string;
  tokenId: string;
  action: string;
  refId: string;
  parameters: ActionParameter[];
}

export interface MsgPerformActionByAdminResponse {
  nftSchemaCode: string;
  tokenId: string;
}

export interface MsgAddAttribute {
  creator: string;
  code: string;
  location: AttributeLocation;
  base64NewAttriuteDefenition: string;
}

export interface MsgAddAttributeResponse {
  code: string;
  name: string;
}

export interface MsgAddAction {
  creator: string;
  code: string;
  base64NewAction: string;
}

export interface MsgAddActionResponse {
  code: string;
  name: string;
}

export interface MsgSetBaseUri {
  creator: string;
  code: string;
  newBaseUri: string;
}

export interface MsgSetBaseUriResponse {
  code: string;
  uri: string;
}

export interface MsgToggleAction {
  creator: string;
  code: string;
  action: string;
  status: boolean;
}

export interface MsgToggleActionResponse {
  code: string;
  name: string;
  status: boolean;
}

export interface MsgChangeSchemaOwner {
  creator: string;
  nftSchemaCode: string;
  newOwner: string;
}

export interface MsgChangeSchemaOwnerResponse {
  nftSchemaCode: string;
  newOwner: string;
}

export interface MsgResyncAttributesResponse {
  nftSchemaCode: string;
  tokenId: string;
}

export interface MsgShowAttributes {
  creator: string;
  nftSchemaCode: string;
  show: boolean;
  attributeNames: string[];
}

export interface MsgShowAttributesResponse {
  nftSchema: string;
}

export interface MsgResyncAttributes {
  creator: string;
  nftSchemaCode: string;
  tokenId: string;
}

export interface MsgSetFeeConfig {
  creator: string;
  feeConfig: FeeConfig | undefined;
}

export interface MsgSetFeeConfigResponse {
}

export interface MsgSetMintauth {
  creator: string;
  nftSchemaCode: string;
  authorizeTo: AuthorizeTo;
}

export interface MsgSetMintauthResponse {
  nftSchemaCode: string;
}

export interface MsgChangeOrgOwner {
  creator: string;
  orgName: string;
  toNewOwner: string;
}

export interface MsgChangeOrgOwnerResponse {
  orgName: string;
  oldOwner: string;
  newOwner: string;
}

export interface MsgSetUriRetrievalMethod {
  creator: string;
  schemaCode: string;
  newMethod: number;
}

export interface MsgSetUriRetrievalMethodResponse {
  schemaCode: string;
  newMethod: string;
}

export interface MsgSetOriginChain {
  creator: string;
  schemaCode: string;
  newOriginChain: string;
}

export interface MsgSetOriginChainResponse {
  schemaCode: string;
  newOriginChain: string;
}

export interface MsgSetOriginContract {
  creator: string;
  schemaCode: string;
  newContractAddress: string;
}

export interface MsgSetOriginContractResponse {
  schemaCode: string;
  newContractAddress: string;
}

export interface MsgSetAttributeOveriding {
  creator: string;
  schemaCode: string;
  newOveridingType: number;
}

export interface MsgSetAttributeOveridingResponse {
  schemaCode: string;
  newOveriding: string;
}

export interface MsgSetMetadataFormat {
  creator: string;
  schemaCode: string;
  newFormat: string;
}

export interface MsgSetMetadataFormatResponse {
  schemaCode: string;
  newFormat: string;
}

export interface MsgCreateActionExecutor {
  creator: string;
  nftSchemaCode: string;
  executorAddress: string;
}

export interface MsgCreateActionExecutorResponse {
  nftSchemaCode: string;
  executorAddress: string;
}

export interface MsgUpdateActionExecutor {
  creator: string;
  nftSchemaCode: string;
  executorAddress: string;
}

export interface MsgUpdateActionExecutorResponse {
  nftSchemaCode: string;
  executorAddress: string;
}

export interface MsgDeleteActionExecutor {
  creator: string;
  nftSchemaCode: string;
  executorAddress: string;
}

export interface MsgDeleteActionExecutorResponse {
  nftSchemaCode: string;
  executorAddress: string;
}

export interface MsgUpdateSchemaAttribute {
  creator: string;
  nftSchemaCode: string;
  Base64UpdateAttriuteDefenition: string;
}

export interface MsgUpdateSchemaAttributeResponse {
  nftSchemaCode: string;
  name: string;
}

export interface MsgUpdateAction {
  creator: string;
  nftSchemaCode: string;
  base64UpdateAction: string;
}

export interface MsgUpdateActionResponse {
  nftSchemaCode: string;
  name: string;
}

export interface MsgCreateVirtualAction {
  creator: string;
  nftSchemaCode: string;
  newActions: Action[];
}

export interface MsgCreateVirtualActionResponse {
  nftSchemaCode: string;
  virtualAction: VirtualAction[];
}

export interface MsgUpdateVirtualAction {
  creator: string;
  nftSchemaCode: string;
  newActions: Action[];
}

export interface MsgUpdateVirtualActionResponse {
  nftSchemaCode: string;
  virtualAction: VirtualAction[];
}

export interface MsgDeleteVirtualAction {
  creator: string;
  nftSchemaCode: string;
  name: string;
}

export interface MsgDeleteVirtualActionResponse {
  creator: string;
  status: string;
}

export interface MsgPerformVirtualAction {
  creator: string;
  nftSchemaName: string;
  tokenIdMap: TokenIdMap[];
  action: string;
  refId: string;
  parameters: ActionParameter[];
}

export interface MsgPerformVirtualActionResponse {
  nftSchemaName: string;
}

export interface TokenIdMap {
  nftSchemaName: string;
  tokenId: string;
}

export interface MsgProposalVirtualSchema {
  creator: string;
  virtualNftSchemaCode: string;
  proposalType: ProposalType;
  registry: VirtualSchemaRegistryRequest[];
  actions: Action[];
  executors: string[];
  enable: boolean;
}

export interface MsgProposalVirtualSchemaResponse {
  id: string;
  virtualNftSchemaCode: string;
  proposalType: ProposalType;
}

export interface MsgVoteVirtualSchemaProposal {
  creator: string;
  id: string;
  nftSchemaCode: string;
  option: RegistryStatus;
}

export interface MsgVoteVirtualSchemaProposalResponse {
}

function createBaseMsgUpdateParams(): MsgUpdateParams {
  return { authority: "", params: undefined };
}

export const MsgUpdateParams: MessageFns<MsgUpdateParams> = {
  encode(message: MsgUpdateParams, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.authority !== "") {
      writer.uint32(10).string(message.authority);
    }
    if (message.params !== undefined) {
      Params.encode(message.params, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgUpdateParams {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgUpdateParams();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.authority = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.params = Params.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgUpdateParams {
    return {
      authority: isSet(object.authority) ? globalThis.String(object.authority) : "",
      params: isSet(object.params) ? Params.fromJSON(object.params) : undefined,
    };
  },

  toJSON(message: MsgUpdateParams): unknown {
    const obj: any = {};
    if (message.authority !== "") {
      obj.authority = message.authority;
    }
    if (message.params !== undefined) {
      obj.params = Params.toJSON(message.params);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgUpdateParams>, I>>(base?: I): MsgUpdateParams {
    return MsgUpdateParams.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgUpdateParams>, I>>(object: I): MsgUpdateParams {
    const message = createBaseMsgUpdateParams();
    message.authority = object.authority ?? "";
    message.params = (object.params !== undefined && object.params !== null)
      ? Params.fromPartial(object.params)
      : undefined;
    return message;
  },
};

function createBaseMsgUpdateParamsResponse(): MsgUpdateParamsResponse {
  return {};
}

export const MsgUpdateParamsResponse: MessageFns<MsgUpdateParamsResponse> = {
  encode(_: MsgUpdateParamsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgUpdateParamsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgUpdateParamsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgUpdateParamsResponse {
    return {};
  },

  toJSON(_: MsgUpdateParamsResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgUpdateParamsResponse>, I>>(base?: I): MsgUpdateParamsResponse {
    return MsgUpdateParamsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgUpdateParamsResponse>, I>>(_: I): MsgUpdateParamsResponse {
    const message = createBaseMsgUpdateParamsResponse();
    return message;
  },
};

function createBaseMsgCreateNFTSchema(): MsgCreateNFTSchema {
  return { creator: "", nftSchemaBase64: "" };
}

export const MsgCreateNFTSchema: MessageFns<MsgCreateNFTSchema> = {
  encode(message: MsgCreateNFTSchema, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.creator !== "") {
      writer.uint32(10).string(message.creator);
    }
    if (message.nftSchemaBase64 !== "") {
      writer.uint32(18).string(message.nftSchemaBase64);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgCreateNFTSchema {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgCreateNFTSchema();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.creator = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.nftSchemaBase64 = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgCreateNFTSchema {
    return {
      creator: isSet(object.creator) ? globalThis.String(object.creator) : "",
      nftSchemaBase64: isSet(object.nftSchemaBase64) ? globalThis.String(object.nftSchemaBase64) : "",
    };
  },

  toJSON(message: MsgCreateNFTSchema): unknown {
    const obj: any = {};
    if (message.creator !== "") {
      obj.creator = message.creator;
    }
    if (message.nftSchemaBase64 !== "") {
      obj.nftSchemaBase64 = message.nftSchemaBase64;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgCreateNFTSchema>, I>>(base?: I): MsgCreateNFTSchema {
    return MsgCreateNFTSchema.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgCreateNFTSchema>, I>>(object: I): MsgCreateNFTSchema {
    const message = createBaseMsgCreateNFTSchema();
    message.creator = object.creator ?? "";
    message.nftSchemaBase64 = object.nftSchemaBase64 ?? "";
    return message;
  },
};

function createBaseMsgCreateNFTSchemaResponse(): MsgCreateNFTSchemaResponse {
  return { code: "" };
}

export const MsgCreateNFTSchemaResponse: MessageFns<MsgCreateNFTSchemaResponse> = {
  encode(message: MsgCreateNFTSchemaResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.code !== "") {
      writer.uint32(10).string(message.code);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgCreateNFTSchemaResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgCreateNFTSchemaResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.code = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgCreateNFTSchemaResponse {
    return { code: isSet(object.code) ? globalThis.String(object.code) : "" };
  },

  toJSON(message: MsgCreateNFTSchemaResponse): unknown {
    const obj: any = {};
    if (message.code !== "") {
      obj.code = message.code;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgCreateNFTSchemaResponse>, I>>(base?: I): MsgCreateNFTSchemaResponse {
    return MsgCreateNFTSchemaResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgCreateNFTSchemaResponse>, I>>(object: I): MsgCreateNFTSchemaResponse {
    const message = createBaseMsgCreateNFTSchemaResponse();
    message.code = object.code ?? "";
    return message;
  },
};

function createBaseMsgCreateMetadata(): MsgCreateMetadata {
  return { creator: "", nftSchemaCode: "", tokenId: "", base64NFTData: "" };
}

export const MsgCreateMetadata: MessageFns<MsgCreateMetadata> = {
  encode(message: MsgCreateMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.creator !== "") {
      writer.uint32(10).string(message.creator);
    }
    if (message.nftSchemaCode !== "") {
      writer.uint32(18).string(message.nftSchemaCode);
    }
    if (message.tokenId !== "") {
      writer.uint32(26).string(message.tokenId);
    }
    if (message.base64NFTData !== "") {
      writer.uint32(34).string(message.base64NFTData);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgCreateMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgCreateMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.creator = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.nftSchemaCode = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.tokenId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.base64NFTData = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgCreateMetadata {
    return {
      creator: isSet(object.creator) ? globalThis.String(object.creator) : "",
      nftSchemaCode: isSet(object.nftSchemaCode) ? globalThis.String(object.nftSchemaCode) : "",
      tokenId: isSet(object.tokenId) ? globalThis.String(object.tokenId) : "",
      base64NFTData: isSet(object.base64NFTData) ? globalThis.String(object.base64NFTData) : "",
    };
  },

  toJSON(message: MsgCreateMetadata): unknown {
    const obj: any = {};
    if (message.creator !== "") {
      obj.creator = message.creator;
    }
    if (message.nftSchemaCode !== "") {
      obj.nftSchemaCode = message.nftSchemaCode;
    }
    if (message.tokenId !== "") {
      obj.tokenId = message.tokenId;
    }
    if (message.base64NFTData !== "") {
      obj.base64NFTData = message.base64NFTData;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgCreateMetadata>, I>>(base?: I): MsgCreateMetadata {
    return MsgCreateMetadata.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgCreateMetadata>, I>>(object: I): MsgCreateMetadata {
    const message = createBaseMsgCreateMetadata();
    message.creator = object.creator ?? "";
    message.nftSchemaCode = object.nftSchemaCode ?? "";
    message.tokenId = object.tokenId ?? "";
    message.base64NFTData = object.base64NFTData ?? "";
    return message;
  },
};

function createBaseMsgCreateMetadataResponse(): MsgCreateMetadataResponse {
  return { nftSchemaCode: "", tokenId: "" };
}

export const MsgCreateMetadataResponse: MessageFns<MsgCreateMetadataResponse> = {
  encode(message: MsgCreateMetadataResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.nftSchemaCode !== "") {
      writer.uint32(10).string(message.nftSchemaCode);
    }
    if (message.tokenId !== "") {
      writer.uint32(18).string(message.tokenId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgCreateMetadataResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgCreateMetadataResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.nftSchemaCode = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.tokenId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgCreateMetadataResponse {
    return {
      nftSchemaCode: isSet(object.nftSchemaCode) ? globalThis.String(object.nftSchemaCode) : "",
      tokenId: isSet(object.tokenId) ? globalThis.String(object.tokenId) : "",
    };
  },

  toJSON(message: MsgCreateMetadataResponse): unknown {
    const obj: any = {};
    if (message.nftSchemaCode !== "") {
      obj.nftSchemaCode = message.nftSchemaCode;
    }
    if (message.tokenId !== "") {
      obj.tokenId = message.tokenId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgCreateMetadataResponse>, I>>(base?: I): MsgCreateMetadataResponse {
    return MsgCreateMetadataResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgCreateMetadataResponse>, I>>(object: I): MsgCreateMetadataResponse {
    const message = createBaseMsgCreateMetadataResponse();
    message.nftSchemaCode = object.nftSchemaCode ?? "";
    message.tokenId = object.tokenId ?? "";
    return message;
  },
};

function createBaseOpenseaAttribute(): OpenseaAttribute {
  return { traitType: "", value: undefined };
}

export const OpenseaAttribute: MessageFns<OpenseaAttribute> = {
  encode(message: OpenseaAttribute, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.traitType !== "") {
      writer.uint32(10).string(message.traitType);
    }
    if (message.value !== undefined) {
      Any.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OpenseaAttribute {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOpenseaAttribute();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.traitType = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = Any.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OpenseaAttribute {
    return {
      traitType: isSet(object.traitType) ? globalThis.String(object.traitType) : "",
      value: isSet(object.value) ? Any.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: OpenseaAttribute): unknown {
    const obj: any = {};
    if (message.traitType !== "") {
      obj.traitType = message.traitType;
    }
    if (message.value !== undefined) {
      obj.value = Any.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<OpenseaAttribute>, I>>(base?: I): OpenseaAttribute {
    return OpenseaAttribute.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<OpenseaAttribute>, I>>(object: I): OpenseaAttribute {
    const message = createBaseOpenseaAttribute();
    message.traitType = object.traitType ?? "";
    message.value = (object.value !== undefined && object.value !== null) ? Any.fromPartial(object.value) : undefined;
    return message;
  },
};

function createBaseUpdatedOpenseaAttributes(): UpdatedOpenseaAttributes {
  return { attributes: [] };
}

export const UpdatedOpenseaAttributes: MessageFns<UpdatedOpenseaAttributes> = {
  encode(message: UpdatedOpenseaAttributes, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.attributes) {
      OpenseaAttribute.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdatedOpenseaAttributes {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdatedOpenseaAttributes();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.attributes.push(OpenseaAttribute.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdatedOpenseaAttributes {
    return {
      attributes: globalThis.Array.isArray(object?.attributes)
        ? object.attributes.map((e: any) => OpenseaAttribute.fromJSON(e))
        : [],
    };
  },

  toJSON(message: UpdatedOpenseaAttributes): unknown {
    const obj: any = {};
    if (message.attributes?.length) {
      obj.attributes = message.attributes.map((e) => OpenseaAttribute.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdatedOpenseaAttributes>, I>>(base?: I): UpdatedOpenseaAttributes {
    return UpdatedOpenseaAttributes.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdatedOpenseaAttributes>, I>>(object: I): UpdatedOpenseaAttributes {
    const message = createBaseUpdatedOpenseaAttributes();
    message.attributes = object.attributes?.map((e) => OpenseaAttribute.fromPartial(e)) || [];
    return message;
  },
};

function createBaseUpdatedOriginData(): UpdatedOriginData {
  return { opensea: undefined };
}

export const UpdatedOriginData: MessageFns<UpdatedOriginData> = {
  encode(message: UpdatedOriginData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.opensea !== undefined) {
      UpdatedOpenseaAttributes.encode(message.opensea, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdatedOriginData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdatedOriginData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.opensea = UpdatedOpenseaAttributes.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdatedOriginData {
    return { opensea: isSet(object.opensea) ? UpdatedOpenseaAttributes.fromJSON(object.opensea) : undefined };
  },

  toJSON(message: UpdatedOriginData): unknown {
    const obj: any = {};
    if (message.opensea !== undefined) {
      obj.opensea = UpdatedOpenseaAttributes.toJSON(message.opensea);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdatedOriginData>, I>>(base?: I): UpdatedOriginData {
    return UpdatedOriginData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdatedOriginData>, I>>(object: I): UpdatedOriginData {
    const message = createBaseUpdatedOriginData();
    message.opensea = (object.opensea !== undefined && object.opensea !== null)
      ? UpdatedOpenseaAttributes.fromPartial(object.opensea)
      : undefined;
    return message;
  },
};

function createBaseActionParameter(): ActionParameter {
  return { name: "", value: "" };
}

export const ActionParameter: MessageFns<ActionParameter> = {
  encode(message: ActionParameter, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ActionParameter {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseActionParameter();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ActionParameter {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: ActionParameter): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ActionParameter>, I>>(base?: I): ActionParameter {
    return ActionParameter.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ActionParameter>, I>>(object: I): ActionParameter {
    const message = createBaseActionParameter();
    message.name = object.name ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseMsgPerformActionByAdmin(): MsgPerformActionByAdmin {
  return { creator: "", nftSchemaCode: "", tokenId: "", action: "", refId: "", parameters: [] };
}

export const MsgPerformActionByAdmin: MessageFns<MsgPerformActionByAdmin> = {
  encode(message: MsgPerformActionByAdmin, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.creator !== "") {
      writer.uint32(10).string(message.creator);
    }
    if (message.nftSchemaCode !== "") {
      writer.uint32(18).string(message.nftSchemaCode);
    }
    if (message.tokenId !== "") {
      writer.uint32(26).string(message.tokenId);
    }
    if (message.action !== "") {
      writer.uint32(34).string(message.action);
    }
    if (message.refId !== "") {
      writer.uint32(42).string(message.refId);
    }
    for (const v of message.parameters) {
      ActionParameter.encode(v!, writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgPerformActionByAdmin {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgPerformActionByAdmin();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.creator = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.nftSchemaCode = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.tokenId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.action = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.refId = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.parameters.push(ActionParameter.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgPerformActionByAdmin {
    return {
      creator: isSet(object.creator) ? globalThis.String(object.creator) : "",
      nftSchemaCode: isSet(object.nftSchemaCode) ? globalThis.String(object.nftSchemaCode) : "",
      tokenId: isSet(object.tokenId) ? globalThis.String(object.tokenId) : "",
      action: isSet(object.action) ? globalThis.String(object.action) : "",
      refId: isSet(object.refId) ? globalThis.String(object.refId) : "",
      parameters: globalThis.Array.isArray(object?.parameters)
        ? object.parameters.map((e: any) => ActionParameter.fromJSON(e))
        : [],
    };
  },

  toJSON(message: MsgPerformActionByAdmin): unknown {
    const obj: any = {};
    if (message.creator !== "") {
      obj.creator = message.creator;
    }
    if (message.nftSchemaCode !== "") {
      obj.nftSchemaCode = message.nftSchemaCode;
    }
    if (message.tokenId !== "") {
      obj.tokenId = message.tokenId;
    }
    if (message.action !== "") {
      obj.action = message.action;
    }
    if (message.refId !== "") {
      obj.refId = message.refId;
    }
    if (message.parameters?.length) {
      obj.parameters = message.parameters.map((e) => ActionParameter.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgPerformActionByAdmin>, I>>(base?: I): MsgPerformActionByAdmin {
    return MsgPerformActionByAdmin.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgPerformActionByAdmin>, I>>(object: I): MsgPerformActionByAdmin {
    const message = createBaseMsgPerformActionByAdmin();
    message.creator = object.creator ?? "";
    message.nftSchemaCode = object.nftSchemaCode ?? "";
    message.tokenId = object.tokenId ?? "";
    message.action = object.action ?? "";
    message.refId = object.refId ?? "";
    message.parameters = object.parameters?.map((e) => ActionParameter.fromPartial(e)) || [];
    return message;
  },
};

function createBaseMsgPerformActionByAdminResponse(): MsgPerformActionByAdminResponse {
  return { nftSchemaCode: "", tokenId: "" };
}

export const MsgPerformActionByAdminResponse: MessageFns<MsgPerformActionByAdminResponse> = {
  encode(message: MsgPerformActionByAdminResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.nftSchemaCode !== "") {
      writer.uint32(10).string(message.nftSchemaCode);
    }
    if (message.tokenId !== "") {
      writer.uint32(18).string(message.tokenId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgPerformActionByAdminResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgPerformActionByAdminResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.nftSchemaCode = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.tokenId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgPerformActionByAdminResponse {
    return {
      nftSchemaCode: isSet(object.nftSchemaCode) ? globalThis.String(object.nftSchemaCode) : "",
      tokenId: isSet(object.tokenId) ? globalThis.String(object.tokenId) : "",
    };
  },

  toJSON(message: MsgPerformActionByAdminResponse): unknown {
    const obj: any = {};
    if (message.nftSchemaCode !== "") {
      obj.nftSchemaCode = message.nftSchemaCode;
    }
    if (message.tokenId !== "") {
      obj.tokenId = message.tokenId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgPerformActionByAdminResponse>, I>>(base?: I): MsgPerformActionByAdminResponse {
    return MsgPerformActionByAdminResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgPerformActionByAdminResponse>, I>>(
    object: I,
  ): MsgPerformActionByAdminResponse {
    const message = createBaseMsgPerformActionByAdminResponse();
    message.nftSchemaCode = object.nftSchemaCode ?? "";
    message.tokenId = object.tokenId ?? "";
    return message;
  },
};

function createBaseMsgAddAttribute(): MsgAddAttribute {
  return { creator: "", code: "", location: 0, base64NewAttriuteDefenition: "" };
}

export const MsgAddAttribute: MessageFns<MsgAddAttribute> = {
  encode(message: MsgAddAttribute, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.creator !== "") {
      writer.uint32(10).string(message.creator);
    }
    if (message.code !== "") {
      writer.uint32(18).string(message.code);
    }
    if (message.location !== 0) {
      writer.uint32(24).int32(message.location);
    }
    if (message.base64NewAttriuteDefenition !== "") {
      writer.uint32(34).string(message.base64NewAttriuteDefenition);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgAddAttribute {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgAddAttribute();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.creator = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.code = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.location = reader.int32() as any;
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.base64NewAttriuteDefenition = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgAddAttribute {
    return {
      creator: isSet(object.creator) ? globalThis.String(object.creator) : "",
      code: isSet(object.code) ? globalThis.String(object.code) : "",
      location: isSet(object.location) ? attributeLocationFromJSON(object.location) : 0,
      base64NewAttriuteDefenition: isSet(object.base64NewAttriuteDefenition)
        ? globalThis.String(object.base64NewAttriuteDefenition)
        : "",
    };
  },

  toJSON(message: MsgAddAttribute): unknown {
    const obj: any = {};
    if (message.creator !== "") {
      obj.creator = message.creator;
    }
    if (message.code !== "") {
      obj.code = message.code;
    }
    if (message.location !== 0) {
      obj.location = attributeLocationToJSON(message.location);
    }
    if (message.base64NewAttriuteDefenition !== "") {
      obj.base64NewAttriuteDefenition = message.base64NewAttriuteDefenition;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgAddAttribute>, I>>(base?: I): MsgAddAttribute {
    return MsgAddAttribute.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgAddAttribute>, I>>(object: I): MsgAddAttribute {
    const message = createBaseMsgAddAttribute();
    message.creator = object.creator ?? "";
    message.code = object.code ?? "";
    message.location = object.location ?? 0;
    message.base64NewAttriuteDefenition = object.base64NewAttriuteDefenition ?? "";
    return message;
  },
};

function createBaseMsgAddAttributeResponse(): MsgAddAttributeResponse {
  return { code: "", name: "" };
}

export const MsgAddAttributeResponse: MessageFns<MsgAddAttributeResponse> = {
  encode(message: MsgAddAttributeResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.code !== "") {
      writer.uint32(10).string(message.code);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgAddAttributeResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgAddAttributeResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.code = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgAddAttributeResponse {
    return {
      code: isSet(object.code) ? globalThis.String(object.code) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
    };
  },

  toJSON(message: MsgAddAttributeResponse): unknown {
    const obj: any = {};
    if (message.code !== "") {
      obj.code = message.code;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgAddAttributeResponse>, I>>(base?: I): MsgAddAttributeResponse {
    return MsgAddAttributeResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgAddAttributeResponse>, I>>(object: I): MsgAddAttributeResponse {
    const message = createBaseMsgAddAttributeResponse();
    message.code = object.code ?? "";
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseMsgAddAction(): MsgAddAction {
  return { creator: "", code: "", base64NewAction: "" };
}

export const MsgAddAction: MessageFns<MsgAddAction> = {
  encode(message: MsgAddAction, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.creator !== "") {
      writer.uint32(10).string(message.creator);
    }
    if (message.code !== "") {
      writer.uint32(18).string(message.code);
    }
    if (message.base64NewAction !== "") {
      writer.uint32(26).string(message.base64NewAction);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgAddAction {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgAddAction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.creator = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.code = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.base64NewAction = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgAddAction {
    return {
      creator: isSet(object.creator) ? globalThis.String(object.creator) : "",
      code: isSet(object.code) ? globalThis.String(object.code) : "",
      base64NewAction: isSet(object.base64NewAction) ? globalThis.String(object.base64NewAction) : "",
    };
  },

  toJSON(message: MsgAddAction): unknown {
    const obj: any = {};
    if (message.creator !== "") {
      obj.creator = message.creator;
    }
    if (message.code !== "") {
      obj.code = message.code;
    }
    if (message.base64NewAction !== "") {
      obj.base64NewAction = message.base64NewAction;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgAddAction>, I>>(base?: I): MsgAddAction {
    return MsgAddAction.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgAddAction>, I>>(object: I): MsgAddAction {
    const message = createBaseMsgAddAction();
    message.creator = object.creator ?? "";
    message.code = object.code ?? "";
    message.base64NewAction = object.base64NewAction ?? "";
    return message;
  },
};

function createBaseMsgAddActionResponse(): MsgAddActionResponse {
  return { code: "", name: "" };
}

export const MsgAddActionResponse: MessageFns<MsgAddActionResponse> = {
  encode(message: MsgAddActionResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.code !== "") {
      writer.uint32(10).string(message.code);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgAddActionResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgAddActionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.code = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgAddActionResponse {
    return {
      code: isSet(object.code) ? globalThis.String(object.code) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
    };
  },

  toJSON(message: MsgAddActionResponse): unknown {
    const obj: any = {};
    if (message.code !== "") {
      obj.code = message.code;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgAddActionResponse>, I>>(base?: I): MsgAddActionResponse {
    return MsgAddActionResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgAddActionResponse>, I>>(object: I): MsgAddActionResponse {
    const message = createBaseMsgAddActionResponse();
    message.code = object.code ?? "";
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseMsgSetBaseUri(): MsgSetBaseUri {
  return { creator: "", code: "", newBaseUri: "" };
}

export const MsgSetBaseUri: MessageFns<MsgSetBaseUri> = {
  encode(message: MsgSetBaseUri, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.creator !== "") {
      writer.uint32(10).string(message.creator);
    }
    if (message.code !== "") {
      writer.uint32(18).string(message.code);
    }
    if (message.newBaseUri !== "") {
      writer.uint32(26).string(message.newBaseUri);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgSetBaseUri {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgSetBaseUri();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.creator = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.code = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.newBaseUri = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgSetBaseUri {
    return {
      creator: isSet(object.creator) ? globalThis.String(object.creator) : "",
      code: isSet(object.code) ? globalThis.String(object.code) : "",
      newBaseUri: isSet(object.newBaseUri) ? globalThis.String(object.newBaseUri) : "",
    };
  },

  toJSON(message: MsgSetBaseUri): unknown {
    const obj: any = {};
    if (message.creator !== "") {
      obj.creator = message.creator;
    }
    if (message.code !== "") {
      obj.code = message.code;
    }
    if (message.newBaseUri !== "") {
      obj.newBaseUri = message.newBaseUri;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgSetBaseUri>, I>>(base?: I): MsgSetBaseUri {
    return MsgSetBaseUri.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgSetBaseUri>, I>>(object: I): MsgSetBaseUri {
    const message = createBaseMsgSetBaseUri();
    message.creator = object.creator ?? "";
    message.code = object.code ?? "";
    message.newBaseUri = object.newBaseUri ?? "";
    return message;
  },
};

function createBaseMsgSetBaseUriResponse(): MsgSetBaseUriResponse {
  return { code: "", uri: "" };
}

export const MsgSetBaseUriResponse: MessageFns<MsgSetBaseUriResponse> = {
  encode(message: MsgSetBaseUriResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.code !== "") {
      writer.uint32(10).string(message.code);
    }
    if (message.uri !== "") {
      writer.uint32(18).string(message.uri);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgSetBaseUriResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgSetBaseUriResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.code = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.uri = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgSetBaseUriResponse {
    return {
      code: isSet(object.code) ? globalThis.String(object.code) : "",
      uri: isSet(object.uri) ? globalThis.String(object.uri) : "",
    };
  },

  toJSON(message: MsgSetBaseUriResponse): unknown {
    const obj: any = {};
    if (message.code !== "") {
      obj.code = message.code;
    }
    if (message.uri !== "") {
      obj.uri = message.uri;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgSetBaseUriResponse>, I>>(base?: I): MsgSetBaseUriResponse {
    return MsgSetBaseUriResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgSetBaseUriResponse>, I>>(object: I): MsgSetBaseUriResponse {
    const message = createBaseMsgSetBaseUriResponse();
    message.code = object.code ?? "";
    message.uri = object.uri ?? "";
    return message;
  },
};

function createBaseMsgToggleAction(): MsgToggleAction {
  return { creator: "", code: "", action: "", status: false };
}

export const MsgToggleAction: MessageFns<MsgToggleAction> = {
  encode(message: MsgToggleAction, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.creator !== "") {
      writer.uint32(10).string(message.creator);
    }
    if (message.code !== "") {
      writer.uint32(18).string(message.code);
    }
    if (message.action !== "") {
      writer.uint32(26).string(message.action);
    }
    if (message.status !== false) {
      writer.uint32(32).bool(message.status);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgToggleAction {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgToggleAction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.creator = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.code = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.action = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.status = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgToggleAction {
    return {
      creator: isSet(object.creator) ? globalThis.String(object.creator) : "",
      code: isSet(object.code) ? globalThis.String(object.code) : "",
      action: isSet(object.action) ? globalThis.String(object.action) : "",
      status: isSet(object.status) ? globalThis.Boolean(object.status) : false,
    };
  },

  toJSON(message: MsgToggleAction): unknown {
    const obj: any = {};
    if (message.creator !== "") {
      obj.creator = message.creator;
    }
    if (message.code !== "") {
      obj.code = message.code;
    }
    if (message.action !== "") {
      obj.action = message.action;
    }
    if (message.status !== false) {
      obj.status = message.status;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgToggleAction>, I>>(base?: I): MsgToggleAction {
    return MsgToggleAction.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgToggleAction>, I>>(object: I): MsgToggleAction {
    const message = createBaseMsgToggleAction();
    message.creator = object.creator ?? "";
    message.code = object.code ?? "";
    message.action = object.action ?? "";
    message.status = object.status ?? false;
    return message;
  },
};

function createBaseMsgToggleActionResponse(): MsgToggleActionResponse {
  return { code: "", name: "", status: false };
}

export const MsgToggleActionResponse: MessageFns<MsgToggleActionResponse> = {
  encode(message: MsgToggleActionResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.code !== "") {
      writer.uint32(10).string(message.code);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.status !== false) {
      writer.uint32(24).bool(message.status);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgToggleActionResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgToggleActionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.code = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.status = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgToggleActionResponse {
    return {
      code: isSet(object.code) ? globalThis.String(object.code) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      status: isSet(object.status) ? globalThis.Boolean(object.status) : false,
    };
  },

  toJSON(message: MsgToggleActionResponse): unknown {
    const obj: any = {};
    if (message.code !== "") {
      obj.code = message.code;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.status !== false) {
      obj.status = message.status;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgToggleActionResponse>, I>>(base?: I): MsgToggleActionResponse {
    return MsgToggleActionResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgToggleActionResponse>, I>>(object: I): MsgToggleActionResponse {
    const message = createBaseMsgToggleActionResponse();
    message.code = object.code ?? "";
    message.name = object.name ?? "";
    message.status = object.status ?? false;
    return message;
  },
};

function createBaseMsgChangeSchemaOwner(): MsgChangeSchemaOwner {
  return { creator: "", nftSchemaCode: "", newOwner: "" };
}

export const MsgChangeSchemaOwner: MessageFns<MsgChangeSchemaOwner> = {
  encode(message: MsgChangeSchemaOwner, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.creator !== "") {
      writer.uint32(10).string(message.creator);
    }
    if (message.nftSchemaCode !== "") {
      writer.uint32(18).string(message.nftSchemaCode);
    }
    if (message.newOwner !== "") {
      writer.uint32(26).string(message.newOwner);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgChangeSchemaOwner {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgChangeSchemaOwner();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.creator = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.nftSchemaCode = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.newOwner = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgChangeSchemaOwner {
    return {
      creator: isSet(object.creator) ? globalThis.String(object.creator) : "",
      nftSchemaCode: isSet(object.nftSchemaCode) ? globalThis.String(object.nftSchemaCode) : "",
      newOwner: isSet(object.newOwner) ? globalThis.String(object.newOwner) : "",
    };
  },

  toJSON(message: MsgChangeSchemaOwner): unknown {
    const obj: any = {};
    if (message.creator !== "") {
      obj.creator = message.creator;
    }
    if (message.nftSchemaCode !== "") {
      obj.nftSchemaCode = message.nftSchemaCode;
    }
    if (message.newOwner !== "") {
      obj.newOwner = message.newOwner;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgChangeSchemaOwner>, I>>(base?: I): MsgChangeSchemaOwner {
    return MsgChangeSchemaOwner.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgChangeSchemaOwner>, I>>(object: I): MsgChangeSchemaOwner {
    const message = createBaseMsgChangeSchemaOwner();
    message.creator = object.creator ?? "";
    message.nftSchemaCode = object.nftSchemaCode ?? "";
    message.newOwner = object.newOwner ?? "";
    return message;
  },
};

function createBaseMsgChangeSchemaOwnerResponse(): MsgChangeSchemaOwnerResponse {
  return { nftSchemaCode: "", newOwner: "" };
}

export const MsgChangeSchemaOwnerResponse: MessageFns<MsgChangeSchemaOwnerResponse> = {
  encode(message: MsgChangeSchemaOwnerResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.nftSchemaCode !== "") {
      writer.uint32(10).string(message.nftSchemaCode);
    }
    if (message.newOwner !== "") {
      writer.uint32(18).string(message.newOwner);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgChangeSchemaOwnerResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgChangeSchemaOwnerResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.nftSchemaCode = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.newOwner = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgChangeSchemaOwnerResponse {
    return {
      nftSchemaCode: isSet(object.nftSchemaCode) ? globalThis.String(object.nftSchemaCode) : "",
      newOwner: isSet(object.newOwner) ? globalThis.String(object.newOwner) : "",
    };
  },

  toJSON(message: MsgChangeSchemaOwnerResponse): unknown {
    const obj: any = {};
    if (message.nftSchemaCode !== "") {
      obj.nftSchemaCode = message.nftSchemaCode;
    }
    if (message.newOwner !== "") {
      obj.newOwner = message.newOwner;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgChangeSchemaOwnerResponse>, I>>(base?: I): MsgChangeSchemaOwnerResponse {
    return MsgChangeSchemaOwnerResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgChangeSchemaOwnerResponse>, I>>(object: I): MsgChangeSchemaOwnerResponse {
    const message = createBaseMsgChangeSchemaOwnerResponse();
    message.nftSchemaCode = object.nftSchemaCode ?? "";
    message.newOwner = object.newOwner ?? "";
    return message;
  },
};

function createBaseMsgResyncAttributesResponse(): MsgResyncAttributesResponse {
  return { nftSchemaCode: "", tokenId: "" };
}

export const MsgResyncAttributesResponse: MessageFns<MsgResyncAttributesResponse> = {
  encode(message: MsgResyncAttributesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.nftSchemaCode !== "") {
      writer.uint32(10).string(message.nftSchemaCode);
    }
    if (message.tokenId !== "") {
      writer.uint32(18).string(message.tokenId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgResyncAttributesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgResyncAttributesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.nftSchemaCode = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.tokenId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgResyncAttributesResponse {
    return {
      nftSchemaCode: isSet(object.nftSchemaCode) ? globalThis.String(object.nftSchemaCode) : "",
      tokenId: isSet(object.tokenId) ? globalThis.String(object.tokenId) : "",
    };
  },

  toJSON(message: MsgResyncAttributesResponse): unknown {
    const obj: any = {};
    if (message.nftSchemaCode !== "") {
      obj.nftSchemaCode = message.nftSchemaCode;
    }
    if (message.tokenId !== "") {
      obj.tokenId = message.tokenId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgResyncAttributesResponse>, I>>(base?: I): MsgResyncAttributesResponse {
    return MsgResyncAttributesResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgResyncAttributesResponse>, I>>(object: I): MsgResyncAttributesResponse {
    const message = createBaseMsgResyncAttributesResponse();
    message.nftSchemaCode = object.nftSchemaCode ?? "";
    message.tokenId = object.tokenId ?? "";
    return message;
  },
};

function createBaseMsgShowAttributes(): MsgShowAttributes {
  return { creator: "", nftSchemaCode: "", show: false, attributeNames: [] };
}

export const MsgShowAttributes: MessageFns<MsgShowAttributes> = {
  encode(message: MsgShowAttributes, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.creator !== "") {
      writer.uint32(10).string(message.creator);
    }
    if (message.nftSchemaCode !== "") {
      writer.uint32(18).string(message.nftSchemaCode);
    }
    if (message.show !== false) {
      writer.uint32(24).bool(message.show);
    }
    for (const v of message.attributeNames) {
      writer.uint32(34).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgShowAttributes {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgShowAttributes();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.creator = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.nftSchemaCode = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.show = reader.bool();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.attributeNames.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgShowAttributes {
    return {
      creator: isSet(object.creator) ? globalThis.String(object.creator) : "",
      nftSchemaCode: isSet(object.nftSchemaCode) ? globalThis.String(object.nftSchemaCode) : "",
      show: isSet(object.show) ? globalThis.Boolean(object.show) : false,
      attributeNames: globalThis.Array.isArray(object?.attributeNames)
        ? object.attributeNames.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: MsgShowAttributes): unknown {
    const obj: any = {};
    if (message.creator !== "") {
      obj.creator = message.creator;
    }
    if (message.nftSchemaCode !== "") {
      obj.nftSchemaCode = message.nftSchemaCode;
    }
    if (message.show !== false) {
      obj.show = message.show;
    }
    if (message.attributeNames?.length) {
      obj.attributeNames = message.attributeNames;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgShowAttributes>, I>>(base?: I): MsgShowAttributes {
    return MsgShowAttributes.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgShowAttributes>, I>>(object: I): MsgShowAttributes {
    const message = createBaseMsgShowAttributes();
    message.creator = object.creator ?? "";
    message.nftSchemaCode = object.nftSchemaCode ?? "";
    message.show = object.show ?? false;
    message.attributeNames = object.attributeNames?.map((e) => e) || [];
    return message;
  },
};

function createBaseMsgShowAttributesResponse(): MsgShowAttributesResponse {
  return { nftSchema: "" };
}

export const MsgShowAttributesResponse: MessageFns<MsgShowAttributesResponse> = {
  encode(message: MsgShowAttributesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.nftSchema !== "") {
      writer.uint32(10).string(message.nftSchema);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgShowAttributesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgShowAttributesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.nftSchema = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgShowAttributesResponse {
    return { nftSchema: isSet(object.nftSchema) ? globalThis.String(object.nftSchema) : "" };
  },

  toJSON(message: MsgShowAttributesResponse): unknown {
    const obj: any = {};
    if (message.nftSchema !== "") {
      obj.nftSchema = message.nftSchema;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgShowAttributesResponse>, I>>(base?: I): MsgShowAttributesResponse {
    return MsgShowAttributesResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgShowAttributesResponse>, I>>(object: I): MsgShowAttributesResponse {
    const message = createBaseMsgShowAttributesResponse();
    message.nftSchema = object.nftSchema ?? "";
    return message;
  },
};

function createBaseMsgResyncAttributes(): MsgResyncAttributes {
  return { creator: "", nftSchemaCode: "", tokenId: "" };
}

export const MsgResyncAttributes: MessageFns<MsgResyncAttributes> = {
  encode(message: MsgResyncAttributes, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.creator !== "") {
      writer.uint32(10).string(message.creator);
    }
    if (message.nftSchemaCode !== "") {
      writer.uint32(18).string(message.nftSchemaCode);
    }
    if (message.tokenId !== "") {
      writer.uint32(26).string(message.tokenId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgResyncAttributes {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgResyncAttributes();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.creator = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.nftSchemaCode = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.tokenId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgResyncAttributes {
    return {
      creator: isSet(object.creator) ? globalThis.String(object.creator) : "",
      nftSchemaCode: isSet(object.nftSchemaCode) ? globalThis.String(object.nftSchemaCode) : "",
      tokenId: isSet(object.tokenId) ? globalThis.String(object.tokenId) : "",
    };
  },

  toJSON(message: MsgResyncAttributes): unknown {
    const obj: any = {};
    if (message.creator !== "") {
      obj.creator = message.creator;
    }
    if (message.nftSchemaCode !== "") {
      obj.nftSchemaCode = message.nftSchemaCode;
    }
    if (message.tokenId !== "") {
      obj.tokenId = message.tokenId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgResyncAttributes>, I>>(base?: I): MsgResyncAttributes {
    return MsgResyncAttributes.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgResyncAttributes>, I>>(object: I): MsgResyncAttributes {
    const message = createBaseMsgResyncAttributes();
    message.creator = object.creator ?? "";
    message.nftSchemaCode = object.nftSchemaCode ?? "";
    message.tokenId = object.tokenId ?? "";
    return message;
  },
};

function createBaseMsgSetFeeConfig(): MsgSetFeeConfig {
  return { creator: "", feeConfig: undefined };
}

export const MsgSetFeeConfig: MessageFns<MsgSetFeeConfig> = {
  encode(message: MsgSetFeeConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.creator !== "") {
      writer.uint32(10).string(message.creator);
    }
    if (message.feeConfig !== undefined) {
      FeeConfig.encode(message.feeConfig, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgSetFeeConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgSetFeeConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.creator = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.feeConfig = FeeConfig.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgSetFeeConfig {
    return {
      creator: isSet(object.creator) ? globalThis.String(object.creator) : "",
      feeConfig: isSet(object.feeConfig) ? FeeConfig.fromJSON(object.feeConfig) : undefined,
    };
  },

  toJSON(message: MsgSetFeeConfig): unknown {
    const obj: any = {};
    if (message.creator !== "") {
      obj.creator = message.creator;
    }
    if (message.feeConfig !== undefined) {
      obj.feeConfig = FeeConfig.toJSON(message.feeConfig);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgSetFeeConfig>, I>>(base?: I): MsgSetFeeConfig {
    return MsgSetFeeConfig.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgSetFeeConfig>, I>>(object: I): MsgSetFeeConfig {
    const message = createBaseMsgSetFeeConfig();
    message.creator = object.creator ?? "";
    message.feeConfig = (object.feeConfig !== undefined && object.feeConfig !== null)
      ? FeeConfig.fromPartial(object.feeConfig)
      : undefined;
    return message;
  },
};

function createBaseMsgSetFeeConfigResponse(): MsgSetFeeConfigResponse {
  return {};
}

export const MsgSetFeeConfigResponse: MessageFns<MsgSetFeeConfigResponse> = {
  encode(_: MsgSetFeeConfigResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgSetFeeConfigResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgSetFeeConfigResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgSetFeeConfigResponse {
    return {};
  },

  toJSON(_: MsgSetFeeConfigResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgSetFeeConfigResponse>, I>>(base?: I): MsgSetFeeConfigResponse {
    return MsgSetFeeConfigResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgSetFeeConfigResponse>, I>>(_: I): MsgSetFeeConfigResponse {
    const message = createBaseMsgSetFeeConfigResponse();
    return message;
  },
};

function createBaseMsgSetMintauth(): MsgSetMintauth {
  return { creator: "", nftSchemaCode: "", authorizeTo: 0 };
}

export const MsgSetMintauth: MessageFns<MsgSetMintauth> = {
  encode(message: MsgSetMintauth, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.creator !== "") {
      writer.uint32(10).string(message.creator);
    }
    if (message.nftSchemaCode !== "") {
      writer.uint32(18).string(message.nftSchemaCode);
    }
    if (message.authorizeTo !== 0) {
      writer.uint32(24).int32(message.authorizeTo);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgSetMintauth {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgSetMintauth();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.creator = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.nftSchemaCode = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.authorizeTo = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgSetMintauth {
    return {
      creator: isSet(object.creator) ? globalThis.String(object.creator) : "",
      nftSchemaCode: isSet(object.nftSchemaCode) ? globalThis.String(object.nftSchemaCode) : "",
      authorizeTo: isSet(object.authorizeTo) ? authorizeToFromJSON(object.authorizeTo) : 0,
    };
  },

  toJSON(message: MsgSetMintauth): unknown {
    const obj: any = {};
    if (message.creator !== "") {
      obj.creator = message.creator;
    }
    if (message.nftSchemaCode !== "") {
      obj.nftSchemaCode = message.nftSchemaCode;
    }
    if (message.authorizeTo !== 0) {
      obj.authorizeTo = authorizeToToJSON(message.authorizeTo);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgSetMintauth>, I>>(base?: I): MsgSetMintauth {
    return MsgSetMintauth.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgSetMintauth>, I>>(object: I): MsgSetMintauth {
    const message = createBaseMsgSetMintauth();
    message.creator = object.creator ?? "";
    message.nftSchemaCode = object.nftSchemaCode ?? "";
    message.authorizeTo = object.authorizeTo ?? 0;
    return message;
  },
};

function createBaseMsgSetMintauthResponse(): MsgSetMintauthResponse {
  return { nftSchemaCode: "" };
}

export const MsgSetMintauthResponse: MessageFns<MsgSetMintauthResponse> = {
  encode(message: MsgSetMintauthResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.nftSchemaCode !== "") {
      writer.uint32(10).string(message.nftSchemaCode);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgSetMintauthResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgSetMintauthResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.nftSchemaCode = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgSetMintauthResponse {
    return { nftSchemaCode: isSet(object.nftSchemaCode) ? globalThis.String(object.nftSchemaCode) : "" };
  },

  toJSON(message: MsgSetMintauthResponse): unknown {
    const obj: any = {};
    if (message.nftSchemaCode !== "") {
      obj.nftSchemaCode = message.nftSchemaCode;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgSetMintauthResponse>, I>>(base?: I): MsgSetMintauthResponse {
    return MsgSetMintauthResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgSetMintauthResponse>, I>>(object: I): MsgSetMintauthResponse {
    const message = createBaseMsgSetMintauthResponse();
    message.nftSchemaCode = object.nftSchemaCode ?? "";
    return message;
  },
};

function createBaseMsgChangeOrgOwner(): MsgChangeOrgOwner {
  return { creator: "", orgName: "", toNewOwner: "" };
}

export const MsgChangeOrgOwner: MessageFns<MsgChangeOrgOwner> = {
  encode(message: MsgChangeOrgOwner, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.creator !== "") {
      writer.uint32(10).string(message.creator);
    }
    if (message.orgName !== "") {
      writer.uint32(18).string(message.orgName);
    }
    if (message.toNewOwner !== "") {
      writer.uint32(26).string(message.toNewOwner);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgChangeOrgOwner {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgChangeOrgOwner();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.creator = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.orgName = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.toNewOwner = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgChangeOrgOwner {
    return {
      creator: isSet(object.creator) ? globalThis.String(object.creator) : "",
      orgName: isSet(object.orgName) ? globalThis.String(object.orgName) : "",
      toNewOwner: isSet(object.toNewOwner) ? globalThis.String(object.toNewOwner) : "",
    };
  },

  toJSON(message: MsgChangeOrgOwner): unknown {
    const obj: any = {};
    if (message.creator !== "") {
      obj.creator = message.creator;
    }
    if (message.orgName !== "") {
      obj.orgName = message.orgName;
    }
    if (message.toNewOwner !== "") {
      obj.toNewOwner = message.toNewOwner;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgChangeOrgOwner>, I>>(base?: I): MsgChangeOrgOwner {
    return MsgChangeOrgOwner.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgChangeOrgOwner>, I>>(object: I): MsgChangeOrgOwner {
    const message = createBaseMsgChangeOrgOwner();
    message.creator = object.creator ?? "";
    message.orgName = object.orgName ?? "";
    message.toNewOwner = object.toNewOwner ?? "";
    return message;
  },
};

function createBaseMsgChangeOrgOwnerResponse(): MsgChangeOrgOwnerResponse {
  return { orgName: "", oldOwner: "", newOwner: "" };
}

export const MsgChangeOrgOwnerResponse: MessageFns<MsgChangeOrgOwnerResponse> = {
  encode(message: MsgChangeOrgOwnerResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.orgName !== "") {
      writer.uint32(10).string(message.orgName);
    }
    if (message.oldOwner !== "") {
      writer.uint32(18).string(message.oldOwner);
    }
    if (message.newOwner !== "") {
      writer.uint32(26).string(message.newOwner);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgChangeOrgOwnerResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgChangeOrgOwnerResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.orgName = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.oldOwner = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.newOwner = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgChangeOrgOwnerResponse {
    return {
      orgName: isSet(object.orgName) ? globalThis.String(object.orgName) : "",
      oldOwner: isSet(object.oldOwner) ? globalThis.String(object.oldOwner) : "",
      newOwner: isSet(object.newOwner) ? globalThis.String(object.newOwner) : "",
    };
  },

  toJSON(message: MsgChangeOrgOwnerResponse): unknown {
    const obj: any = {};
    if (message.orgName !== "") {
      obj.orgName = message.orgName;
    }
    if (message.oldOwner !== "") {
      obj.oldOwner = message.oldOwner;
    }
    if (message.newOwner !== "") {
      obj.newOwner = message.newOwner;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgChangeOrgOwnerResponse>, I>>(base?: I): MsgChangeOrgOwnerResponse {
    return MsgChangeOrgOwnerResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgChangeOrgOwnerResponse>, I>>(object: I): MsgChangeOrgOwnerResponse {
    const message = createBaseMsgChangeOrgOwnerResponse();
    message.orgName = object.orgName ?? "";
    message.oldOwner = object.oldOwner ?? "";
    message.newOwner = object.newOwner ?? "";
    return message;
  },
};

function createBaseMsgSetUriRetrievalMethod(): MsgSetUriRetrievalMethod {
  return { creator: "", schemaCode: "", newMethod: 0 };
}

export const MsgSetUriRetrievalMethod: MessageFns<MsgSetUriRetrievalMethod> = {
  encode(message: MsgSetUriRetrievalMethod, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.creator !== "") {
      writer.uint32(10).string(message.creator);
    }
    if (message.schemaCode !== "") {
      writer.uint32(18).string(message.schemaCode);
    }
    if (message.newMethod !== 0) {
      writer.uint32(24).int32(message.newMethod);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgSetUriRetrievalMethod {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgSetUriRetrievalMethod();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.creator = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.schemaCode = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.newMethod = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgSetUriRetrievalMethod {
    return {
      creator: isSet(object.creator) ? globalThis.String(object.creator) : "",
      schemaCode: isSet(object.schemaCode) ? globalThis.String(object.schemaCode) : "",
      newMethod: isSet(object.newMethod) ? globalThis.Number(object.newMethod) : 0,
    };
  },

  toJSON(message: MsgSetUriRetrievalMethod): unknown {
    const obj: any = {};
    if (message.creator !== "") {
      obj.creator = message.creator;
    }
    if (message.schemaCode !== "") {
      obj.schemaCode = message.schemaCode;
    }
    if (message.newMethod !== 0) {
      obj.newMethod = Math.round(message.newMethod);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgSetUriRetrievalMethod>, I>>(base?: I): MsgSetUriRetrievalMethod {
    return MsgSetUriRetrievalMethod.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgSetUriRetrievalMethod>, I>>(object: I): MsgSetUriRetrievalMethod {
    const message = createBaseMsgSetUriRetrievalMethod();
    message.creator = object.creator ?? "";
    message.schemaCode = object.schemaCode ?? "";
    message.newMethod = object.newMethod ?? 0;
    return message;
  },
};

function createBaseMsgSetUriRetrievalMethodResponse(): MsgSetUriRetrievalMethodResponse {
  return { schemaCode: "", newMethod: "" };
}

export const MsgSetUriRetrievalMethodResponse: MessageFns<MsgSetUriRetrievalMethodResponse> = {
  encode(message: MsgSetUriRetrievalMethodResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.schemaCode !== "") {
      writer.uint32(10).string(message.schemaCode);
    }
    if (message.newMethod !== "") {
      writer.uint32(18).string(message.newMethod);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgSetUriRetrievalMethodResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgSetUriRetrievalMethodResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.schemaCode = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.newMethod = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgSetUriRetrievalMethodResponse {
    return {
      schemaCode: isSet(object.schemaCode) ? globalThis.String(object.schemaCode) : "",
      newMethod: isSet(object.newMethod) ? globalThis.String(object.newMethod) : "",
    };
  },

  toJSON(message: MsgSetUriRetrievalMethodResponse): unknown {
    const obj: any = {};
    if (message.schemaCode !== "") {
      obj.schemaCode = message.schemaCode;
    }
    if (message.newMethod !== "") {
      obj.newMethod = message.newMethod;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgSetUriRetrievalMethodResponse>, I>>(
    base?: I,
  ): MsgSetUriRetrievalMethodResponse {
    return MsgSetUriRetrievalMethodResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgSetUriRetrievalMethodResponse>, I>>(
    object: I,
  ): MsgSetUriRetrievalMethodResponse {
    const message = createBaseMsgSetUriRetrievalMethodResponse();
    message.schemaCode = object.schemaCode ?? "";
    message.newMethod = object.newMethod ?? "";
    return message;
  },
};

function createBaseMsgSetOriginChain(): MsgSetOriginChain {
  return { creator: "", schemaCode: "", newOriginChain: "" };
}

export const MsgSetOriginChain: MessageFns<MsgSetOriginChain> = {
  encode(message: MsgSetOriginChain, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.creator !== "") {
      writer.uint32(10).string(message.creator);
    }
    if (message.schemaCode !== "") {
      writer.uint32(18).string(message.schemaCode);
    }
    if (message.newOriginChain !== "") {
      writer.uint32(26).string(message.newOriginChain);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgSetOriginChain {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgSetOriginChain();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.creator = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.schemaCode = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.newOriginChain = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgSetOriginChain {
    return {
      creator: isSet(object.creator) ? globalThis.String(object.creator) : "",
      schemaCode: isSet(object.schemaCode) ? globalThis.String(object.schemaCode) : "",
      newOriginChain: isSet(object.newOriginChain) ? globalThis.String(object.newOriginChain) : "",
    };
  },

  toJSON(message: MsgSetOriginChain): unknown {
    const obj: any = {};
    if (message.creator !== "") {
      obj.creator = message.creator;
    }
    if (message.schemaCode !== "") {
      obj.schemaCode = message.schemaCode;
    }
    if (message.newOriginChain !== "") {
      obj.newOriginChain = message.newOriginChain;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgSetOriginChain>, I>>(base?: I): MsgSetOriginChain {
    return MsgSetOriginChain.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgSetOriginChain>, I>>(object: I): MsgSetOriginChain {
    const message = createBaseMsgSetOriginChain();
    message.creator = object.creator ?? "";
    message.schemaCode = object.schemaCode ?? "";
    message.newOriginChain = object.newOriginChain ?? "";
    return message;
  },
};

function createBaseMsgSetOriginChainResponse(): MsgSetOriginChainResponse {
  return { schemaCode: "", newOriginChain: "" };
}

export const MsgSetOriginChainResponse: MessageFns<MsgSetOriginChainResponse> = {
  encode(message: MsgSetOriginChainResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.schemaCode !== "") {
      writer.uint32(10).string(message.schemaCode);
    }
    if (message.newOriginChain !== "") {
      writer.uint32(18).string(message.newOriginChain);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgSetOriginChainResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgSetOriginChainResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.schemaCode = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.newOriginChain = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgSetOriginChainResponse {
    return {
      schemaCode: isSet(object.schemaCode) ? globalThis.String(object.schemaCode) : "",
      newOriginChain: isSet(object.newOriginChain) ? globalThis.String(object.newOriginChain) : "",
    };
  },

  toJSON(message: MsgSetOriginChainResponse): unknown {
    const obj: any = {};
    if (message.schemaCode !== "") {
      obj.schemaCode = message.schemaCode;
    }
    if (message.newOriginChain !== "") {
      obj.newOriginChain = message.newOriginChain;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgSetOriginChainResponse>, I>>(base?: I): MsgSetOriginChainResponse {
    return MsgSetOriginChainResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgSetOriginChainResponse>, I>>(object: I): MsgSetOriginChainResponse {
    const message = createBaseMsgSetOriginChainResponse();
    message.schemaCode = object.schemaCode ?? "";
    message.newOriginChain = object.newOriginChain ?? "";
    return message;
  },
};

function createBaseMsgSetOriginContract(): MsgSetOriginContract {
  return { creator: "", schemaCode: "", newContractAddress: "" };
}

export const MsgSetOriginContract: MessageFns<MsgSetOriginContract> = {
  encode(message: MsgSetOriginContract, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.creator !== "") {
      writer.uint32(10).string(message.creator);
    }
    if (message.schemaCode !== "") {
      writer.uint32(18).string(message.schemaCode);
    }
    if (message.newContractAddress !== "") {
      writer.uint32(26).string(message.newContractAddress);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgSetOriginContract {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgSetOriginContract();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.creator = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.schemaCode = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.newContractAddress = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgSetOriginContract {
    return {
      creator: isSet(object.creator) ? globalThis.String(object.creator) : "",
      schemaCode: isSet(object.schemaCode) ? globalThis.String(object.schemaCode) : "",
      newContractAddress: isSet(object.newContractAddress) ? globalThis.String(object.newContractAddress) : "",
    };
  },

  toJSON(message: MsgSetOriginContract): unknown {
    const obj: any = {};
    if (message.creator !== "") {
      obj.creator = message.creator;
    }
    if (message.schemaCode !== "") {
      obj.schemaCode = message.schemaCode;
    }
    if (message.newContractAddress !== "") {
      obj.newContractAddress = message.newContractAddress;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgSetOriginContract>, I>>(base?: I): MsgSetOriginContract {
    return MsgSetOriginContract.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgSetOriginContract>, I>>(object: I): MsgSetOriginContract {
    const message = createBaseMsgSetOriginContract();
    message.creator = object.creator ?? "";
    message.schemaCode = object.schemaCode ?? "";
    message.newContractAddress = object.newContractAddress ?? "";
    return message;
  },
};

function createBaseMsgSetOriginContractResponse(): MsgSetOriginContractResponse {
  return { schemaCode: "", newContractAddress: "" };
}

export const MsgSetOriginContractResponse: MessageFns<MsgSetOriginContractResponse> = {
  encode(message: MsgSetOriginContractResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.schemaCode !== "") {
      writer.uint32(10).string(message.schemaCode);
    }
    if (message.newContractAddress !== "") {
      writer.uint32(18).string(message.newContractAddress);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgSetOriginContractResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgSetOriginContractResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.schemaCode = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.newContractAddress = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgSetOriginContractResponse {
    return {
      schemaCode: isSet(object.schemaCode) ? globalThis.String(object.schemaCode) : "",
      newContractAddress: isSet(object.newContractAddress) ? globalThis.String(object.newContractAddress) : "",
    };
  },

  toJSON(message: MsgSetOriginContractResponse): unknown {
    const obj: any = {};
    if (message.schemaCode !== "") {
      obj.schemaCode = message.schemaCode;
    }
    if (message.newContractAddress !== "") {
      obj.newContractAddress = message.newContractAddress;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgSetOriginContractResponse>, I>>(base?: I): MsgSetOriginContractResponse {
    return MsgSetOriginContractResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgSetOriginContractResponse>, I>>(object: I): MsgSetOriginContractResponse {
    const message = createBaseMsgSetOriginContractResponse();
    message.schemaCode = object.schemaCode ?? "";
    message.newContractAddress = object.newContractAddress ?? "";
    return message;
  },
};

function createBaseMsgSetAttributeOveriding(): MsgSetAttributeOveriding {
  return { creator: "", schemaCode: "", newOveridingType: 0 };
}

export const MsgSetAttributeOveriding: MessageFns<MsgSetAttributeOveriding> = {
  encode(message: MsgSetAttributeOveriding, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.creator !== "") {
      writer.uint32(10).string(message.creator);
    }
    if (message.schemaCode !== "") {
      writer.uint32(18).string(message.schemaCode);
    }
    if (message.newOveridingType !== 0) {
      writer.uint32(24).int32(message.newOveridingType);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgSetAttributeOveriding {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgSetAttributeOveriding();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.creator = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.schemaCode = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.newOveridingType = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgSetAttributeOveriding {
    return {
      creator: isSet(object.creator) ? globalThis.String(object.creator) : "",
      schemaCode: isSet(object.schemaCode) ? globalThis.String(object.schemaCode) : "",
      newOveridingType: isSet(object.newOveridingType) ? globalThis.Number(object.newOveridingType) : 0,
    };
  },

  toJSON(message: MsgSetAttributeOveriding): unknown {
    const obj: any = {};
    if (message.creator !== "") {
      obj.creator = message.creator;
    }
    if (message.schemaCode !== "") {
      obj.schemaCode = message.schemaCode;
    }
    if (message.newOveridingType !== 0) {
      obj.newOveridingType = Math.round(message.newOveridingType);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgSetAttributeOveriding>, I>>(base?: I): MsgSetAttributeOveriding {
    return MsgSetAttributeOveriding.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgSetAttributeOveriding>, I>>(object: I): MsgSetAttributeOveriding {
    const message = createBaseMsgSetAttributeOveriding();
    message.creator = object.creator ?? "";
    message.schemaCode = object.schemaCode ?? "";
    message.newOveridingType = object.newOveridingType ?? 0;
    return message;
  },
};

function createBaseMsgSetAttributeOveridingResponse(): MsgSetAttributeOveridingResponse {
  return { schemaCode: "", newOveriding: "" };
}

export const MsgSetAttributeOveridingResponse: MessageFns<MsgSetAttributeOveridingResponse> = {
  encode(message: MsgSetAttributeOveridingResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.schemaCode !== "") {
      writer.uint32(10).string(message.schemaCode);
    }
    if (message.newOveriding !== "") {
      writer.uint32(18).string(message.newOveriding);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgSetAttributeOveridingResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgSetAttributeOveridingResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.schemaCode = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.newOveriding = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgSetAttributeOveridingResponse {
    return {
      schemaCode: isSet(object.schemaCode) ? globalThis.String(object.schemaCode) : "",
      newOveriding: isSet(object.newOveriding) ? globalThis.String(object.newOveriding) : "",
    };
  },

  toJSON(message: MsgSetAttributeOveridingResponse): unknown {
    const obj: any = {};
    if (message.schemaCode !== "") {
      obj.schemaCode = message.schemaCode;
    }
    if (message.newOveriding !== "") {
      obj.newOveriding = message.newOveriding;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgSetAttributeOveridingResponse>, I>>(
    base?: I,
  ): MsgSetAttributeOveridingResponse {
    return MsgSetAttributeOveridingResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgSetAttributeOveridingResponse>, I>>(
    object: I,
  ): MsgSetAttributeOveridingResponse {
    const message = createBaseMsgSetAttributeOveridingResponse();
    message.schemaCode = object.schemaCode ?? "";
    message.newOveriding = object.newOveriding ?? "";
    return message;
  },
};

function createBaseMsgSetMetadataFormat(): MsgSetMetadataFormat {
  return { creator: "", schemaCode: "", newFormat: "" };
}

export const MsgSetMetadataFormat: MessageFns<MsgSetMetadataFormat> = {
  encode(message: MsgSetMetadataFormat, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.creator !== "") {
      writer.uint32(10).string(message.creator);
    }
    if (message.schemaCode !== "") {
      writer.uint32(18).string(message.schemaCode);
    }
    if (message.newFormat !== "") {
      writer.uint32(26).string(message.newFormat);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgSetMetadataFormat {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgSetMetadataFormat();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.creator = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.schemaCode = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.newFormat = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgSetMetadataFormat {
    return {
      creator: isSet(object.creator) ? globalThis.String(object.creator) : "",
      schemaCode: isSet(object.schemaCode) ? globalThis.String(object.schemaCode) : "",
      newFormat: isSet(object.newFormat) ? globalThis.String(object.newFormat) : "",
    };
  },

  toJSON(message: MsgSetMetadataFormat): unknown {
    const obj: any = {};
    if (message.creator !== "") {
      obj.creator = message.creator;
    }
    if (message.schemaCode !== "") {
      obj.schemaCode = message.schemaCode;
    }
    if (message.newFormat !== "") {
      obj.newFormat = message.newFormat;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgSetMetadataFormat>, I>>(base?: I): MsgSetMetadataFormat {
    return MsgSetMetadataFormat.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgSetMetadataFormat>, I>>(object: I): MsgSetMetadataFormat {
    const message = createBaseMsgSetMetadataFormat();
    message.creator = object.creator ?? "";
    message.schemaCode = object.schemaCode ?? "";
    message.newFormat = object.newFormat ?? "";
    return message;
  },
};

function createBaseMsgSetMetadataFormatResponse(): MsgSetMetadataFormatResponse {
  return { schemaCode: "", newFormat: "" };
}

export const MsgSetMetadataFormatResponse: MessageFns<MsgSetMetadataFormatResponse> = {
  encode(message: MsgSetMetadataFormatResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.schemaCode !== "") {
      writer.uint32(10).string(message.schemaCode);
    }
    if (message.newFormat !== "") {
      writer.uint32(18).string(message.newFormat);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgSetMetadataFormatResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgSetMetadataFormatResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.schemaCode = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.newFormat = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgSetMetadataFormatResponse {
    return {
      schemaCode: isSet(object.schemaCode) ? globalThis.String(object.schemaCode) : "",
      newFormat: isSet(object.newFormat) ? globalThis.String(object.newFormat) : "",
    };
  },

  toJSON(message: MsgSetMetadataFormatResponse): unknown {
    const obj: any = {};
    if (message.schemaCode !== "") {
      obj.schemaCode = message.schemaCode;
    }
    if (message.newFormat !== "") {
      obj.newFormat = message.newFormat;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgSetMetadataFormatResponse>, I>>(base?: I): MsgSetMetadataFormatResponse {
    return MsgSetMetadataFormatResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgSetMetadataFormatResponse>, I>>(object: I): MsgSetMetadataFormatResponse {
    const message = createBaseMsgSetMetadataFormatResponse();
    message.schemaCode = object.schemaCode ?? "";
    message.newFormat = object.newFormat ?? "";
    return message;
  },
};

function createBaseMsgCreateActionExecutor(): MsgCreateActionExecutor {
  return { creator: "", nftSchemaCode: "", executorAddress: "" };
}

export const MsgCreateActionExecutor: MessageFns<MsgCreateActionExecutor> = {
  encode(message: MsgCreateActionExecutor, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.creator !== "") {
      writer.uint32(10).string(message.creator);
    }
    if (message.nftSchemaCode !== "") {
      writer.uint32(18).string(message.nftSchemaCode);
    }
    if (message.executorAddress !== "") {
      writer.uint32(26).string(message.executorAddress);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgCreateActionExecutor {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgCreateActionExecutor();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.creator = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.nftSchemaCode = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.executorAddress = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgCreateActionExecutor {
    return {
      creator: isSet(object.creator) ? globalThis.String(object.creator) : "",
      nftSchemaCode: isSet(object.nftSchemaCode) ? globalThis.String(object.nftSchemaCode) : "",
      executorAddress: isSet(object.executorAddress) ? globalThis.String(object.executorAddress) : "",
    };
  },

  toJSON(message: MsgCreateActionExecutor): unknown {
    const obj: any = {};
    if (message.creator !== "") {
      obj.creator = message.creator;
    }
    if (message.nftSchemaCode !== "") {
      obj.nftSchemaCode = message.nftSchemaCode;
    }
    if (message.executorAddress !== "") {
      obj.executorAddress = message.executorAddress;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgCreateActionExecutor>, I>>(base?: I): MsgCreateActionExecutor {
    return MsgCreateActionExecutor.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgCreateActionExecutor>, I>>(object: I): MsgCreateActionExecutor {
    const message = createBaseMsgCreateActionExecutor();
    message.creator = object.creator ?? "";
    message.nftSchemaCode = object.nftSchemaCode ?? "";
    message.executorAddress = object.executorAddress ?? "";
    return message;
  },
};

function createBaseMsgCreateActionExecutorResponse(): MsgCreateActionExecutorResponse {
  return { nftSchemaCode: "", executorAddress: "" };
}

export const MsgCreateActionExecutorResponse: MessageFns<MsgCreateActionExecutorResponse> = {
  encode(message: MsgCreateActionExecutorResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.nftSchemaCode !== "") {
      writer.uint32(10).string(message.nftSchemaCode);
    }
    if (message.executorAddress !== "") {
      writer.uint32(18).string(message.executorAddress);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgCreateActionExecutorResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgCreateActionExecutorResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.nftSchemaCode = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.executorAddress = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgCreateActionExecutorResponse {
    return {
      nftSchemaCode: isSet(object.nftSchemaCode) ? globalThis.String(object.nftSchemaCode) : "",
      executorAddress: isSet(object.executorAddress) ? globalThis.String(object.executorAddress) : "",
    };
  },

  toJSON(message: MsgCreateActionExecutorResponse): unknown {
    const obj: any = {};
    if (message.nftSchemaCode !== "") {
      obj.nftSchemaCode = message.nftSchemaCode;
    }
    if (message.executorAddress !== "") {
      obj.executorAddress = message.executorAddress;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgCreateActionExecutorResponse>, I>>(base?: I): MsgCreateActionExecutorResponse {
    return MsgCreateActionExecutorResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgCreateActionExecutorResponse>, I>>(
    object: I,
  ): MsgCreateActionExecutorResponse {
    const message = createBaseMsgCreateActionExecutorResponse();
    message.nftSchemaCode = object.nftSchemaCode ?? "";
    message.executorAddress = object.executorAddress ?? "";
    return message;
  },
};

function createBaseMsgUpdateActionExecutor(): MsgUpdateActionExecutor {
  return { creator: "", nftSchemaCode: "", executorAddress: "" };
}

export const MsgUpdateActionExecutor: MessageFns<MsgUpdateActionExecutor> = {
  encode(message: MsgUpdateActionExecutor, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.creator !== "") {
      writer.uint32(10).string(message.creator);
    }
    if (message.nftSchemaCode !== "") {
      writer.uint32(18).string(message.nftSchemaCode);
    }
    if (message.executorAddress !== "") {
      writer.uint32(26).string(message.executorAddress);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgUpdateActionExecutor {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgUpdateActionExecutor();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.creator = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.nftSchemaCode = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.executorAddress = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgUpdateActionExecutor {
    return {
      creator: isSet(object.creator) ? globalThis.String(object.creator) : "",
      nftSchemaCode: isSet(object.nftSchemaCode) ? globalThis.String(object.nftSchemaCode) : "",
      executorAddress: isSet(object.executorAddress) ? globalThis.String(object.executorAddress) : "",
    };
  },

  toJSON(message: MsgUpdateActionExecutor): unknown {
    const obj: any = {};
    if (message.creator !== "") {
      obj.creator = message.creator;
    }
    if (message.nftSchemaCode !== "") {
      obj.nftSchemaCode = message.nftSchemaCode;
    }
    if (message.executorAddress !== "") {
      obj.executorAddress = message.executorAddress;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgUpdateActionExecutor>, I>>(base?: I): MsgUpdateActionExecutor {
    return MsgUpdateActionExecutor.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgUpdateActionExecutor>, I>>(object: I): MsgUpdateActionExecutor {
    const message = createBaseMsgUpdateActionExecutor();
    message.creator = object.creator ?? "";
    message.nftSchemaCode = object.nftSchemaCode ?? "";
    message.executorAddress = object.executorAddress ?? "";
    return message;
  },
};

function createBaseMsgUpdateActionExecutorResponse(): MsgUpdateActionExecutorResponse {
  return { nftSchemaCode: "", executorAddress: "" };
}

export const MsgUpdateActionExecutorResponse: MessageFns<MsgUpdateActionExecutorResponse> = {
  encode(message: MsgUpdateActionExecutorResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.nftSchemaCode !== "") {
      writer.uint32(10).string(message.nftSchemaCode);
    }
    if (message.executorAddress !== "") {
      writer.uint32(18).string(message.executorAddress);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgUpdateActionExecutorResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgUpdateActionExecutorResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.nftSchemaCode = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.executorAddress = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgUpdateActionExecutorResponse {
    return {
      nftSchemaCode: isSet(object.nftSchemaCode) ? globalThis.String(object.nftSchemaCode) : "",
      executorAddress: isSet(object.executorAddress) ? globalThis.String(object.executorAddress) : "",
    };
  },

  toJSON(message: MsgUpdateActionExecutorResponse): unknown {
    const obj: any = {};
    if (message.nftSchemaCode !== "") {
      obj.nftSchemaCode = message.nftSchemaCode;
    }
    if (message.executorAddress !== "") {
      obj.executorAddress = message.executorAddress;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgUpdateActionExecutorResponse>, I>>(base?: I): MsgUpdateActionExecutorResponse {
    return MsgUpdateActionExecutorResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgUpdateActionExecutorResponse>, I>>(
    object: I,
  ): MsgUpdateActionExecutorResponse {
    const message = createBaseMsgUpdateActionExecutorResponse();
    message.nftSchemaCode = object.nftSchemaCode ?? "";
    message.executorAddress = object.executorAddress ?? "";
    return message;
  },
};

function createBaseMsgDeleteActionExecutor(): MsgDeleteActionExecutor {
  return { creator: "", nftSchemaCode: "", executorAddress: "" };
}

export const MsgDeleteActionExecutor: MessageFns<MsgDeleteActionExecutor> = {
  encode(message: MsgDeleteActionExecutor, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.creator !== "") {
      writer.uint32(10).string(message.creator);
    }
    if (message.nftSchemaCode !== "") {
      writer.uint32(18).string(message.nftSchemaCode);
    }
    if (message.executorAddress !== "") {
      writer.uint32(26).string(message.executorAddress);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgDeleteActionExecutor {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgDeleteActionExecutor();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.creator = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.nftSchemaCode = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.executorAddress = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgDeleteActionExecutor {
    return {
      creator: isSet(object.creator) ? globalThis.String(object.creator) : "",
      nftSchemaCode: isSet(object.nftSchemaCode) ? globalThis.String(object.nftSchemaCode) : "",
      executorAddress: isSet(object.executorAddress) ? globalThis.String(object.executorAddress) : "",
    };
  },

  toJSON(message: MsgDeleteActionExecutor): unknown {
    const obj: any = {};
    if (message.creator !== "") {
      obj.creator = message.creator;
    }
    if (message.nftSchemaCode !== "") {
      obj.nftSchemaCode = message.nftSchemaCode;
    }
    if (message.executorAddress !== "") {
      obj.executorAddress = message.executorAddress;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgDeleteActionExecutor>, I>>(base?: I): MsgDeleteActionExecutor {
    return MsgDeleteActionExecutor.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgDeleteActionExecutor>, I>>(object: I): MsgDeleteActionExecutor {
    const message = createBaseMsgDeleteActionExecutor();
    message.creator = object.creator ?? "";
    message.nftSchemaCode = object.nftSchemaCode ?? "";
    message.executorAddress = object.executorAddress ?? "";
    return message;
  },
};

function createBaseMsgDeleteActionExecutorResponse(): MsgDeleteActionExecutorResponse {
  return { nftSchemaCode: "", executorAddress: "" };
}

export const MsgDeleteActionExecutorResponse: MessageFns<MsgDeleteActionExecutorResponse> = {
  encode(message: MsgDeleteActionExecutorResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.nftSchemaCode !== "") {
      writer.uint32(10).string(message.nftSchemaCode);
    }
    if (message.executorAddress !== "") {
      writer.uint32(18).string(message.executorAddress);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgDeleteActionExecutorResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgDeleteActionExecutorResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.nftSchemaCode = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.executorAddress = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgDeleteActionExecutorResponse {
    return {
      nftSchemaCode: isSet(object.nftSchemaCode) ? globalThis.String(object.nftSchemaCode) : "",
      executorAddress: isSet(object.executorAddress) ? globalThis.String(object.executorAddress) : "",
    };
  },

  toJSON(message: MsgDeleteActionExecutorResponse): unknown {
    const obj: any = {};
    if (message.nftSchemaCode !== "") {
      obj.nftSchemaCode = message.nftSchemaCode;
    }
    if (message.executorAddress !== "") {
      obj.executorAddress = message.executorAddress;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgDeleteActionExecutorResponse>, I>>(base?: I): MsgDeleteActionExecutorResponse {
    return MsgDeleteActionExecutorResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgDeleteActionExecutorResponse>, I>>(
    object: I,
  ): MsgDeleteActionExecutorResponse {
    const message = createBaseMsgDeleteActionExecutorResponse();
    message.nftSchemaCode = object.nftSchemaCode ?? "";
    message.executorAddress = object.executorAddress ?? "";
    return message;
  },
};

function createBaseMsgUpdateSchemaAttribute(): MsgUpdateSchemaAttribute {
  return { creator: "", nftSchemaCode: "", Base64UpdateAttriuteDefenition: "" };
}

export const MsgUpdateSchemaAttribute: MessageFns<MsgUpdateSchemaAttribute> = {
  encode(message: MsgUpdateSchemaAttribute, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.creator !== "") {
      writer.uint32(10).string(message.creator);
    }
    if (message.nftSchemaCode !== "") {
      writer.uint32(18).string(message.nftSchemaCode);
    }
    if (message.Base64UpdateAttriuteDefenition !== "") {
      writer.uint32(26).string(message.Base64UpdateAttriuteDefenition);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgUpdateSchemaAttribute {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgUpdateSchemaAttribute();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.creator = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.nftSchemaCode = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.Base64UpdateAttriuteDefenition = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgUpdateSchemaAttribute {
    return {
      creator: isSet(object.creator) ? globalThis.String(object.creator) : "",
      nftSchemaCode: isSet(object.nftSchemaCode) ? globalThis.String(object.nftSchemaCode) : "",
      Base64UpdateAttriuteDefenition: isSet(object.Base64UpdateAttriuteDefenition)
        ? globalThis.String(object.Base64UpdateAttriuteDefenition)
        : "",
    };
  },

  toJSON(message: MsgUpdateSchemaAttribute): unknown {
    const obj: any = {};
    if (message.creator !== "") {
      obj.creator = message.creator;
    }
    if (message.nftSchemaCode !== "") {
      obj.nftSchemaCode = message.nftSchemaCode;
    }
    if (message.Base64UpdateAttriuteDefenition !== "") {
      obj.Base64UpdateAttriuteDefenition = message.Base64UpdateAttriuteDefenition;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgUpdateSchemaAttribute>, I>>(base?: I): MsgUpdateSchemaAttribute {
    return MsgUpdateSchemaAttribute.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgUpdateSchemaAttribute>, I>>(object: I): MsgUpdateSchemaAttribute {
    const message = createBaseMsgUpdateSchemaAttribute();
    message.creator = object.creator ?? "";
    message.nftSchemaCode = object.nftSchemaCode ?? "";
    message.Base64UpdateAttriuteDefenition = object.Base64UpdateAttriuteDefenition ?? "";
    return message;
  },
};

function createBaseMsgUpdateSchemaAttributeResponse(): MsgUpdateSchemaAttributeResponse {
  return { nftSchemaCode: "", name: "" };
}

export const MsgUpdateSchemaAttributeResponse: MessageFns<MsgUpdateSchemaAttributeResponse> = {
  encode(message: MsgUpdateSchemaAttributeResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.nftSchemaCode !== "") {
      writer.uint32(10).string(message.nftSchemaCode);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgUpdateSchemaAttributeResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgUpdateSchemaAttributeResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.nftSchemaCode = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgUpdateSchemaAttributeResponse {
    return {
      nftSchemaCode: isSet(object.nftSchemaCode) ? globalThis.String(object.nftSchemaCode) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
    };
  },

  toJSON(message: MsgUpdateSchemaAttributeResponse): unknown {
    const obj: any = {};
    if (message.nftSchemaCode !== "") {
      obj.nftSchemaCode = message.nftSchemaCode;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgUpdateSchemaAttributeResponse>, I>>(
    base?: I,
  ): MsgUpdateSchemaAttributeResponse {
    return MsgUpdateSchemaAttributeResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgUpdateSchemaAttributeResponse>, I>>(
    object: I,
  ): MsgUpdateSchemaAttributeResponse {
    const message = createBaseMsgUpdateSchemaAttributeResponse();
    message.nftSchemaCode = object.nftSchemaCode ?? "";
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseMsgUpdateAction(): MsgUpdateAction {
  return { creator: "", nftSchemaCode: "", base64UpdateAction: "" };
}

export const MsgUpdateAction: MessageFns<MsgUpdateAction> = {
  encode(message: MsgUpdateAction, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.creator !== "") {
      writer.uint32(10).string(message.creator);
    }
    if (message.nftSchemaCode !== "") {
      writer.uint32(18).string(message.nftSchemaCode);
    }
    if (message.base64UpdateAction !== "") {
      writer.uint32(26).string(message.base64UpdateAction);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgUpdateAction {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgUpdateAction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.creator = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.nftSchemaCode = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.base64UpdateAction = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgUpdateAction {
    return {
      creator: isSet(object.creator) ? globalThis.String(object.creator) : "",
      nftSchemaCode: isSet(object.nftSchemaCode) ? globalThis.String(object.nftSchemaCode) : "",
      base64UpdateAction: isSet(object.base64UpdateAction) ? globalThis.String(object.base64UpdateAction) : "",
    };
  },

  toJSON(message: MsgUpdateAction): unknown {
    const obj: any = {};
    if (message.creator !== "") {
      obj.creator = message.creator;
    }
    if (message.nftSchemaCode !== "") {
      obj.nftSchemaCode = message.nftSchemaCode;
    }
    if (message.base64UpdateAction !== "") {
      obj.base64UpdateAction = message.base64UpdateAction;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgUpdateAction>, I>>(base?: I): MsgUpdateAction {
    return MsgUpdateAction.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgUpdateAction>, I>>(object: I): MsgUpdateAction {
    const message = createBaseMsgUpdateAction();
    message.creator = object.creator ?? "";
    message.nftSchemaCode = object.nftSchemaCode ?? "";
    message.base64UpdateAction = object.base64UpdateAction ?? "";
    return message;
  },
};

function createBaseMsgUpdateActionResponse(): MsgUpdateActionResponse {
  return { nftSchemaCode: "", name: "" };
}

export const MsgUpdateActionResponse: MessageFns<MsgUpdateActionResponse> = {
  encode(message: MsgUpdateActionResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.nftSchemaCode !== "") {
      writer.uint32(10).string(message.nftSchemaCode);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgUpdateActionResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgUpdateActionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.nftSchemaCode = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgUpdateActionResponse {
    return {
      nftSchemaCode: isSet(object.nftSchemaCode) ? globalThis.String(object.nftSchemaCode) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
    };
  },

  toJSON(message: MsgUpdateActionResponse): unknown {
    const obj: any = {};
    if (message.nftSchemaCode !== "") {
      obj.nftSchemaCode = message.nftSchemaCode;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgUpdateActionResponse>, I>>(base?: I): MsgUpdateActionResponse {
    return MsgUpdateActionResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgUpdateActionResponse>, I>>(object: I): MsgUpdateActionResponse {
    const message = createBaseMsgUpdateActionResponse();
    message.nftSchemaCode = object.nftSchemaCode ?? "";
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseMsgCreateVirtualAction(): MsgCreateVirtualAction {
  return { creator: "", nftSchemaCode: "", newActions: [] };
}

export const MsgCreateVirtualAction: MessageFns<MsgCreateVirtualAction> = {
  encode(message: MsgCreateVirtualAction, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.creator !== "") {
      writer.uint32(10).string(message.creator);
    }
    if (message.nftSchemaCode !== "") {
      writer.uint32(18).string(message.nftSchemaCode);
    }
    for (const v of message.newActions) {
      Action.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgCreateVirtualAction {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgCreateVirtualAction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.creator = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.nftSchemaCode = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.newActions.push(Action.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgCreateVirtualAction {
    return {
      creator: isSet(object.creator) ? globalThis.String(object.creator) : "",
      nftSchemaCode: isSet(object.nftSchemaCode) ? globalThis.String(object.nftSchemaCode) : "",
      newActions: globalThis.Array.isArray(object?.newActions)
        ? object.newActions.map((e: any) => Action.fromJSON(e))
        : [],
    };
  },

  toJSON(message: MsgCreateVirtualAction): unknown {
    const obj: any = {};
    if (message.creator !== "") {
      obj.creator = message.creator;
    }
    if (message.nftSchemaCode !== "") {
      obj.nftSchemaCode = message.nftSchemaCode;
    }
    if (message.newActions?.length) {
      obj.newActions = message.newActions.map((e) => Action.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgCreateVirtualAction>, I>>(base?: I): MsgCreateVirtualAction {
    return MsgCreateVirtualAction.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgCreateVirtualAction>, I>>(object: I): MsgCreateVirtualAction {
    const message = createBaseMsgCreateVirtualAction();
    message.creator = object.creator ?? "";
    message.nftSchemaCode = object.nftSchemaCode ?? "";
    message.newActions = object.newActions?.map((e) => Action.fromPartial(e)) || [];
    return message;
  },
};

function createBaseMsgCreateVirtualActionResponse(): MsgCreateVirtualActionResponse {
  return { nftSchemaCode: "", virtualAction: [] };
}

export const MsgCreateVirtualActionResponse: MessageFns<MsgCreateVirtualActionResponse> = {
  encode(message: MsgCreateVirtualActionResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.nftSchemaCode !== "") {
      writer.uint32(10).string(message.nftSchemaCode);
    }
    for (const v of message.virtualAction) {
      VirtualAction.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgCreateVirtualActionResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgCreateVirtualActionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.nftSchemaCode = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.virtualAction.push(VirtualAction.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgCreateVirtualActionResponse {
    return {
      nftSchemaCode: isSet(object.nftSchemaCode) ? globalThis.String(object.nftSchemaCode) : "",
      virtualAction: globalThis.Array.isArray(object?.virtualAction)
        ? object.virtualAction.map((e: any) => VirtualAction.fromJSON(e))
        : [],
    };
  },

  toJSON(message: MsgCreateVirtualActionResponse): unknown {
    const obj: any = {};
    if (message.nftSchemaCode !== "") {
      obj.nftSchemaCode = message.nftSchemaCode;
    }
    if (message.virtualAction?.length) {
      obj.virtualAction = message.virtualAction.map((e) => VirtualAction.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgCreateVirtualActionResponse>, I>>(base?: I): MsgCreateVirtualActionResponse {
    return MsgCreateVirtualActionResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgCreateVirtualActionResponse>, I>>(
    object: I,
  ): MsgCreateVirtualActionResponse {
    const message = createBaseMsgCreateVirtualActionResponse();
    message.nftSchemaCode = object.nftSchemaCode ?? "";
    message.virtualAction = object.virtualAction?.map((e) => VirtualAction.fromPartial(e)) || [];
    return message;
  },
};

function createBaseMsgUpdateVirtualAction(): MsgUpdateVirtualAction {
  return { creator: "", nftSchemaCode: "", newActions: [] };
}

export const MsgUpdateVirtualAction: MessageFns<MsgUpdateVirtualAction> = {
  encode(message: MsgUpdateVirtualAction, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.creator !== "") {
      writer.uint32(10).string(message.creator);
    }
    if (message.nftSchemaCode !== "") {
      writer.uint32(18).string(message.nftSchemaCode);
    }
    for (const v of message.newActions) {
      Action.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgUpdateVirtualAction {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgUpdateVirtualAction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.creator = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.nftSchemaCode = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.newActions.push(Action.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgUpdateVirtualAction {
    return {
      creator: isSet(object.creator) ? globalThis.String(object.creator) : "",
      nftSchemaCode: isSet(object.nftSchemaCode) ? globalThis.String(object.nftSchemaCode) : "",
      newActions: globalThis.Array.isArray(object?.newActions)
        ? object.newActions.map((e: any) => Action.fromJSON(e))
        : [],
    };
  },

  toJSON(message: MsgUpdateVirtualAction): unknown {
    const obj: any = {};
    if (message.creator !== "") {
      obj.creator = message.creator;
    }
    if (message.nftSchemaCode !== "") {
      obj.nftSchemaCode = message.nftSchemaCode;
    }
    if (message.newActions?.length) {
      obj.newActions = message.newActions.map((e) => Action.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgUpdateVirtualAction>, I>>(base?: I): MsgUpdateVirtualAction {
    return MsgUpdateVirtualAction.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgUpdateVirtualAction>, I>>(object: I): MsgUpdateVirtualAction {
    const message = createBaseMsgUpdateVirtualAction();
    message.creator = object.creator ?? "";
    message.nftSchemaCode = object.nftSchemaCode ?? "";
    message.newActions = object.newActions?.map((e) => Action.fromPartial(e)) || [];
    return message;
  },
};

function createBaseMsgUpdateVirtualActionResponse(): MsgUpdateVirtualActionResponse {
  return { nftSchemaCode: "", virtualAction: [] };
}

export const MsgUpdateVirtualActionResponse: MessageFns<MsgUpdateVirtualActionResponse> = {
  encode(message: MsgUpdateVirtualActionResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.nftSchemaCode !== "") {
      writer.uint32(10).string(message.nftSchemaCode);
    }
    for (const v of message.virtualAction) {
      VirtualAction.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgUpdateVirtualActionResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgUpdateVirtualActionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.nftSchemaCode = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.virtualAction.push(VirtualAction.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgUpdateVirtualActionResponse {
    return {
      nftSchemaCode: isSet(object.nftSchemaCode) ? globalThis.String(object.nftSchemaCode) : "",
      virtualAction: globalThis.Array.isArray(object?.virtualAction)
        ? object.virtualAction.map((e: any) => VirtualAction.fromJSON(e))
        : [],
    };
  },

  toJSON(message: MsgUpdateVirtualActionResponse): unknown {
    const obj: any = {};
    if (message.nftSchemaCode !== "") {
      obj.nftSchemaCode = message.nftSchemaCode;
    }
    if (message.virtualAction?.length) {
      obj.virtualAction = message.virtualAction.map((e) => VirtualAction.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgUpdateVirtualActionResponse>, I>>(base?: I): MsgUpdateVirtualActionResponse {
    return MsgUpdateVirtualActionResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgUpdateVirtualActionResponse>, I>>(
    object: I,
  ): MsgUpdateVirtualActionResponse {
    const message = createBaseMsgUpdateVirtualActionResponse();
    message.nftSchemaCode = object.nftSchemaCode ?? "";
    message.virtualAction = object.virtualAction?.map((e) => VirtualAction.fromPartial(e)) || [];
    return message;
  },
};

function createBaseMsgDeleteVirtualAction(): MsgDeleteVirtualAction {
  return { creator: "", nftSchemaCode: "", name: "" };
}

export const MsgDeleteVirtualAction: MessageFns<MsgDeleteVirtualAction> = {
  encode(message: MsgDeleteVirtualAction, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.creator !== "") {
      writer.uint32(10).string(message.creator);
    }
    if (message.nftSchemaCode !== "") {
      writer.uint32(18).string(message.nftSchemaCode);
    }
    if (message.name !== "") {
      writer.uint32(26).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgDeleteVirtualAction {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgDeleteVirtualAction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.creator = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.nftSchemaCode = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.name = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgDeleteVirtualAction {
    return {
      creator: isSet(object.creator) ? globalThis.String(object.creator) : "",
      nftSchemaCode: isSet(object.nftSchemaCode) ? globalThis.String(object.nftSchemaCode) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
    };
  },

  toJSON(message: MsgDeleteVirtualAction): unknown {
    const obj: any = {};
    if (message.creator !== "") {
      obj.creator = message.creator;
    }
    if (message.nftSchemaCode !== "") {
      obj.nftSchemaCode = message.nftSchemaCode;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgDeleteVirtualAction>, I>>(base?: I): MsgDeleteVirtualAction {
    return MsgDeleteVirtualAction.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgDeleteVirtualAction>, I>>(object: I): MsgDeleteVirtualAction {
    const message = createBaseMsgDeleteVirtualAction();
    message.creator = object.creator ?? "";
    message.nftSchemaCode = object.nftSchemaCode ?? "";
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseMsgDeleteVirtualActionResponse(): MsgDeleteVirtualActionResponse {
  return { creator: "", status: "" };
}

export const MsgDeleteVirtualActionResponse: MessageFns<MsgDeleteVirtualActionResponse> = {
  encode(message: MsgDeleteVirtualActionResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.creator !== "") {
      writer.uint32(10).string(message.creator);
    }
    if (message.status !== "") {
      writer.uint32(18).string(message.status);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgDeleteVirtualActionResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgDeleteVirtualActionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.creator = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.status = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgDeleteVirtualActionResponse {
    return {
      creator: isSet(object.creator) ? globalThis.String(object.creator) : "",
      status: isSet(object.status) ? globalThis.String(object.status) : "",
    };
  },

  toJSON(message: MsgDeleteVirtualActionResponse): unknown {
    const obj: any = {};
    if (message.creator !== "") {
      obj.creator = message.creator;
    }
    if (message.status !== "") {
      obj.status = message.status;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgDeleteVirtualActionResponse>, I>>(base?: I): MsgDeleteVirtualActionResponse {
    return MsgDeleteVirtualActionResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgDeleteVirtualActionResponse>, I>>(
    object: I,
  ): MsgDeleteVirtualActionResponse {
    const message = createBaseMsgDeleteVirtualActionResponse();
    message.creator = object.creator ?? "";
    message.status = object.status ?? "";
    return message;
  },
};

function createBaseMsgPerformVirtualAction(): MsgPerformVirtualAction {
  return { creator: "", nftSchemaName: "", tokenIdMap: [], action: "", refId: "", parameters: [] };
}

export const MsgPerformVirtualAction: MessageFns<MsgPerformVirtualAction> = {
  encode(message: MsgPerformVirtualAction, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.creator !== "") {
      writer.uint32(10).string(message.creator);
    }
    if (message.nftSchemaName !== "") {
      writer.uint32(18).string(message.nftSchemaName);
    }
    for (const v of message.tokenIdMap) {
      TokenIdMap.encode(v!, writer.uint32(26).fork()).join();
    }
    if (message.action !== "") {
      writer.uint32(34).string(message.action);
    }
    if (message.refId !== "") {
      writer.uint32(42).string(message.refId);
    }
    for (const v of message.parameters) {
      ActionParameter.encode(v!, writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgPerformVirtualAction {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgPerformVirtualAction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.creator = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.nftSchemaName = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.tokenIdMap.push(TokenIdMap.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.action = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.refId = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.parameters.push(ActionParameter.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgPerformVirtualAction {
    return {
      creator: isSet(object.creator) ? globalThis.String(object.creator) : "",
      nftSchemaName: isSet(object.nftSchemaName) ? globalThis.String(object.nftSchemaName) : "",
      tokenIdMap: globalThis.Array.isArray(object?.tokenIdMap)
        ? object.tokenIdMap.map((e: any) => TokenIdMap.fromJSON(e))
        : [],
      action: isSet(object.action) ? globalThis.String(object.action) : "",
      refId: isSet(object.refId) ? globalThis.String(object.refId) : "",
      parameters: globalThis.Array.isArray(object?.parameters)
        ? object.parameters.map((e: any) => ActionParameter.fromJSON(e))
        : [],
    };
  },

  toJSON(message: MsgPerformVirtualAction): unknown {
    const obj: any = {};
    if (message.creator !== "") {
      obj.creator = message.creator;
    }
    if (message.nftSchemaName !== "") {
      obj.nftSchemaName = message.nftSchemaName;
    }
    if (message.tokenIdMap?.length) {
      obj.tokenIdMap = message.tokenIdMap.map((e) => TokenIdMap.toJSON(e));
    }
    if (message.action !== "") {
      obj.action = message.action;
    }
    if (message.refId !== "") {
      obj.refId = message.refId;
    }
    if (message.parameters?.length) {
      obj.parameters = message.parameters.map((e) => ActionParameter.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgPerformVirtualAction>, I>>(base?: I): MsgPerformVirtualAction {
    return MsgPerformVirtualAction.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgPerformVirtualAction>, I>>(object: I): MsgPerformVirtualAction {
    const message = createBaseMsgPerformVirtualAction();
    message.creator = object.creator ?? "";
    message.nftSchemaName = object.nftSchemaName ?? "";
    message.tokenIdMap = object.tokenIdMap?.map((e) => TokenIdMap.fromPartial(e)) || [];
    message.action = object.action ?? "";
    message.refId = object.refId ?? "";
    message.parameters = object.parameters?.map((e) => ActionParameter.fromPartial(e)) || [];
    return message;
  },
};

function createBaseMsgPerformVirtualActionResponse(): MsgPerformVirtualActionResponse {
  return { nftSchemaName: "" };
}

export const MsgPerformVirtualActionResponse: MessageFns<MsgPerformVirtualActionResponse> = {
  encode(message: MsgPerformVirtualActionResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.nftSchemaName !== "") {
      writer.uint32(18).string(message.nftSchemaName);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgPerformVirtualActionResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgPerformVirtualActionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.nftSchemaName = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgPerformVirtualActionResponse {
    return { nftSchemaName: isSet(object.nftSchemaName) ? globalThis.String(object.nftSchemaName) : "" };
  },

  toJSON(message: MsgPerformVirtualActionResponse): unknown {
    const obj: any = {};
    if (message.nftSchemaName !== "") {
      obj.nftSchemaName = message.nftSchemaName;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgPerformVirtualActionResponse>, I>>(base?: I): MsgPerformVirtualActionResponse {
    return MsgPerformVirtualActionResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgPerformVirtualActionResponse>, I>>(
    object: I,
  ): MsgPerformVirtualActionResponse {
    const message = createBaseMsgPerformVirtualActionResponse();
    message.nftSchemaName = object.nftSchemaName ?? "";
    return message;
  },
};

function createBaseTokenIdMap(): TokenIdMap {
  return { nftSchemaName: "", tokenId: "" };
}

export const TokenIdMap: MessageFns<TokenIdMap> = {
  encode(message: TokenIdMap, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.nftSchemaName !== "") {
      writer.uint32(10).string(message.nftSchemaName);
    }
    if (message.tokenId !== "") {
      writer.uint32(18).string(message.tokenId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TokenIdMap {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTokenIdMap();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.nftSchemaName = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.tokenId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TokenIdMap {
    return {
      nftSchemaName: isSet(object.nftSchemaName) ? globalThis.String(object.nftSchemaName) : "",
      tokenId: isSet(object.tokenId) ? globalThis.String(object.tokenId) : "",
    };
  },

  toJSON(message: TokenIdMap): unknown {
    const obj: any = {};
    if (message.nftSchemaName !== "") {
      obj.nftSchemaName = message.nftSchemaName;
    }
    if (message.tokenId !== "") {
      obj.tokenId = message.tokenId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TokenIdMap>, I>>(base?: I): TokenIdMap {
    return TokenIdMap.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TokenIdMap>, I>>(object: I): TokenIdMap {
    const message = createBaseTokenIdMap();
    message.nftSchemaName = object.nftSchemaName ?? "";
    message.tokenId = object.tokenId ?? "";
    return message;
  },
};

function createBaseMsgProposalVirtualSchema(): MsgProposalVirtualSchema {
  return {
    creator: "",
    virtualNftSchemaCode: "",
    proposalType: 0,
    registry: [],
    actions: [],
    executors: [],
    enable: false,
  };
}

export const MsgProposalVirtualSchema: MessageFns<MsgProposalVirtualSchema> = {
  encode(message: MsgProposalVirtualSchema, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.creator !== "") {
      writer.uint32(10).string(message.creator);
    }
    if (message.virtualNftSchemaCode !== "") {
      writer.uint32(18).string(message.virtualNftSchemaCode);
    }
    if (message.proposalType !== 0) {
      writer.uint32(24).int32(message.proposalType);
    }
    for (const v of message.registry) {
      VirtualSchemaRegistryRequest.encode(v!, writer.uint32(34).fork()).join();
    }
    for (const v of message.actions) {
      Action.encode(v!, writer.uint32(42).fork()).join();
    }
    for (const v of message.executors) {
      writer.uint32(50).string(v!);
    }
    if (message.enable !== false) {
      writer.uint32(56).bool(message.enable);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgProposalVirtualSchema {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgProposalVirtualSchema();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.creator = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.virtualNftSchemaCode = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.proposalType = reader.int32() as any;
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.registry.push(VirtualSchemaRegistryRequest.decode(reader, reader.uint32()));
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.actions.push(Action.decode(reader, reader.uint32()));
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.executors.push(reader.string());
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.enable = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgProposalVirtualSchema {
    return {
      creator: isSet(object.creator) ? globalThis.String(object.creator) : "",
      virtualNftSchemaCode: isSet(object.virtualNftSchemaCode) ? globalThis.String(object.virtualNftSchemaCode) : "",
      proposalType: isSet(object.proposalType) ? proposalTypeFromJSON(object.proposalType) : 0,
      registry: globalThis.Array.isArray(object?.registry)
        ? object.registry.map((e: any) => VirtualSchemaRegistryRequest.fromJSON(e))
        : [],
      actions: globalThis.Array.isArray(object?.actions) ? object.actions.map((e: any) => Action.fromJSON(e)) : [],
      executors: globalThis.Array.isArray(object?.executors)
        ? object.executors.map((e: any) => globalThis.String(e))
        : [],
      enable: isSet(object.enable) ? globalThis.Boolean(object.enable) : false,
    };
  },

  toJSON(message: MsgProposalVirtualSchema): unknown {
    const obj: any = {};
    if (message.creator !== "") {
      obj.creator = message.creator;
    }
    if (message.virtualNftSchemaCode !== "") {
      obj.virtualNftSchemaCode = message.virtualNftSchemaCode;
    }
    if (message.proposalType !== 0) {
      obj.proposalType = proposalTypeToJSON(message.proposalType);
    }
    if (message.registry?.length) {
      obj.registry = message.registry.map((e) => VirtualSchemaRegistryRequest.toJSON(e));
    }
    if (message.actions?.length) {
      obj.actions = message.actions.map((e) => Action.toJSON(e));
    }
    if (message.executors?.length) {
      obj.executors = message.executors;
    }
    if (message.enable !== false) {
      obj.enable = message.enable;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgProposalVirtualSchema>, I>>(base?: I): MsgProposalVirtualSchema {
    return MsgProposalVirtualSchema.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgProposalVirtualSchema>, I>>(object: I): MsgProposalVirtualSchema {
    const message = createBaseMsgProposalVirtualSchema();
    message.creator = object.creator ?? "";
    message.virtualNftSchemaCode = object.virtualNftSchemaCode ?? "";
    message.proposalType = object.proposalType ?? 0;
    message.registry = object.registry?.map((e) => VirtualSchemaRegistryRequest.fromPartial(e)) || [];
    message.actions = object.actions?.map((e) => Action.fromPartial(e)) || [];
    message.executors = object.executors?.map((e) => e) || [];
    message.enable = object.enable ?? false;
    return message;
  },
};

function createBaseMsgProposalVirtualSchemaResponse(): MsgProposalVirtualSchemaResponse {
  return { id: "", virtualNftSchemaCode: "", proposalType: 0 };
}

export const MsgProposalVirtualSchemaResponse: MessageFns<MsgProposalVirtualSchemaResponse> = {
  encode(message: MsgProposalVirtualSchemaResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.virtualNftSchemaCode !== "") {
      writer.uint32(18).string(message.virtualNftSchemaCode);
    }
    if (message.proposalType !== 0) {
      writer.uint32(24).int32(message.proposalType);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgProposalVirtualSchemaResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgProposalVirtualSchemaResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.virtualNftSchemaCode = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.proposalType = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgProposalVirtualSchemaResponse {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      virtualNftSchemaCode: isSet(object.virtualNftSchemaCode) ? globalThis.String(object.virtualNftSchemaCode) : "",
      proposalType: isSet(object.proposalType) ? proposalTypeFromJSON(object.proposalType) : 0,
    };
  },

  toJSON(message: MsgProposalVirtualSchemaResponse): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.virtualNftSchemaCode !== "") {
      obj.virtualNftSchemaCode = message.virtualNftSchemaCode;
    }
    if (message.proposalType !== 0) {
      obj.proposalType = proposalTypeToJSON(message.proposalType);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgProposalVirtualSchemaResponse>, I>>(
    base?: I,
  ): MsgProposalVirtualSchemaResponse {
    return MsgProposalVirtualSchemaResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgProposalVirtualSchemaResponse>, I>>(
    object: I,
  ): MsgProposalVirtualSchemaResponse {
    const message = createBaseMsgProposalVirtualSchemaResponse();
    message.id = object.id ?? "";
    message.virtualNftSchemaCode = object.virtualNftSchemaCode ?? "";
    message.proposalType = object.proposalType ?? 0;
    return message;
  },
};

function createBaseMsgVoteVirtualSchemaProposal(): MsgVoteVirtualSchemaProposal {
  return { creator: "", id: "", nftSchemaCode: "", option: 0 };
}

export const MsgVoteVirtualSchemaProposal: MessageFns<MsgVoteVirtualSchemaProposal> = {
  encode(message: MsgVoteVirtualSchemaProposal, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.creator !== "") {
      writer.uint32(10).string(message.creator);
    }
    if (message.id !== "") {
      writer.uint32(18).string(message.id);
    }
    if (message.nftSchemaCode !== "") {
      writer.uint32(26).string(message.nftSchemaCode);
    }
    if (message.option !== 0) {
      writer.uint32(32).int32(message.option);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgVoteVirtualSchemaProposal {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgVoteVirtualSchemaProposal();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.creator = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.nftSchemaCode = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.option = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgVoteVirtualSchemaProposal {
    return {
      creator: isSet(object.creator) ? globalThis.String(object.creator) : "",
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      nftSchemaCode: isSet(object.nftSchemaCode) ? globalThis.String(object.nftSchemaCode) : "",
      option: isSet(object.option) ? registryStatusFromJSON(object.option) : 0,
    };
  },

  toJSON(message: MsgVoteVirtualSchemaProposal): unknown {
    const obj: any = {};
    if (message.creator !== "") {
      obj.creator = message.creator;
    }
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.nftSchemaCode !== "") {
      obj.nftSchemaCode = message.nftSchemaCode;
    }
    if (message.option !== 0) {
      obj.option = registryStatusToJSON(message.option);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgVoteVirtualSchemaProposal>, I>>(base?: I): MsgVoteVirtualSchemaProposal {
    return MsgVoteVirtualSchemaProposal.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgVoteVirtualSchemaProposal>, I>>(object: I): MsgVoteVirtualSchemaProposal {
    const message = createBaseMsgVoteVirtualSchemaProposal();
    message.creator = object.creator ?? "";
    message.id = object.id ?? "";
    message.nftSchemaCode = object.nftSchemaCode ?? "";
    message.option = object.option ?? 0;
    return message;
  },
};

function createBaseMsgVoteVirtualSchemaProposalResponse(): MsgVoteVirtualSchemaProposalResponse {
  return {};
}

export const MsgVoteVirtualSchemaProposalResponse: MessageFns<MsgVoteVirtualSchemaProposalResponse> = {
  encode(_: MsgVoteVirtualSchemaProposalResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgVoteVirtualSchemaProposalResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgVoteVirtualSchemaProposalResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgVoteVirtualSchemaProposalResponse {
    return {};
  },

  toJSON(_: MsgVoteVirtualSchemaProposalResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgVoteVirtualSchemaProposalResponse>, I>>(
    base?: I,
  ): MsgVoteVirtualSchemaProposalResponse {
    return MsgVoteVirtualSchemaProposalResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgVoteVirtualSchemaProposalResponse>, I>>(
    _: I,
  ): MsgVoteVirtualSchemaProposalResponse {
    const message = createBaseMsgVoteVirtualSchemaProposalResponse();
    return message;
  },
};

/** Msg defines the Msg service. */
export interface Msg {
  /**
   * UpdateParams defines a (governance) operation for updating the module
   * parameters. The authority defaults to the x/gov module account.
   */
  UpdateParams(request: MsgUpdateParams): Promise<MsgUpdateParamsResponse>;
  CreateNFTSchema(request: MsgCreateNFTSchema): Promise<MsgCreateNFTSchemaResponse>;
  CreateMetadata(request: MsgCreateMetadata): Promise<MsgCreateMetadataResponse>;
  PerformActionByAdmin(request: MsgPerformActionByAdmin): Promise<MsgPerformActionByAdminResponse>;
  AddAttribute(request: MsgAddAttribute): Promise<MsgAddAttributeResponse>;
  AddAction(request: MsgAddAction): Promise<MsgAddActionResponse>;
  SetBaseUri(request: MsgSetBaseUri): Promise<MsgSetBaseUriResponse>;
  ToggleAction(request: MsgToggleAction): Promise<MsgToggleActionResponse>;
  ChangeSchemaOwner(request: MsgChangeSchemaOwner): Promise<MsgChangeSchemaOwnerResponse>;
  ResyncAttributes(request: MsgResyncAttributes): Promise<MsgResyncAttributesResponse>;
  ShowAttributes(request: MsgShowAttributes): Promise<MsgShowAttributesResponse>;
  SetFeeConfig(request: MsgSetFeeConfig): Promise<MsgSetFeeConfigResponse>;
  SetMintauth(request: MsgSetMintauth): Promise<MsgSetMintauthResponse>;
  ChangeOrgOwner(request: MsgChangeOrgOwner): Promise<MsgChangeOrgOwnerResponse>;
  SetUriRetrievalMethod(request: MsgSetUriRetrievalMethod): Promise<MsgSetUriRetrievalMethodResponse>;
  SetOriginChain(request: MsgSetOriginChain): Promise<MsgSetOriginChainResponse>;
  SetOriginContract(request: MsgSetOriginContract): Promise<MsgSetOriginContractResponse>;
  SetAttributeOveriding(request: MsgSetAttributeOveriding): Promise<MsgSetAttributeOveridingResponse>;
  SetMetadataFormat(request: MsgSetMetadataFormat): Promise<MsgSetMetadataFormatResponse>;
  CreateActionExecutor(request: MsgCreateActionExecutor): Promise<MsgCreateActionExecutorResponse>;
  DeleteActionExecutor(request: MsgDeleteActionExecutor): Promise<MsgDeleteActionExecutorResponse>;
  UpdateSchemaAttribute(request: MsgUpdateSchemaAttribute): Promise<MsgUpdateSchemaAttributeResponse>;
  UpdateAction(request: MsgUpdateAction): Promise<MsgUpdateActionResponse>;
  ProposalVirtualSchema(request: MsgProposalVirtualSchema): Promise<MsgProposalVirtualSchemaResponse>;
  PerformVirtualAction(request: MsgPerformVirtualAction): Promise<MsgPerformVirtualActionResponse>;
  VoteVirtualSchemaProposal(request: MsgVoteVirtualSchemaProposal): Promise<MsgVoteVirtualSchemaProposalResponse>;
}

export const MsgServiceName = "sixprotocol.nftmngr.Msg";
export class MsgClientImpl implements Msg {
  private readonly rpc: Rpc;
  private readonly service: string;
  constructor(rpc: Rpc, opts?: { service?: string }) {
    this.service = opts?.service || MsgServiceName;
    this.rpc = rpc;
    this.UpdateParams = this.UpdateParams.bind(this);
    this.CreateNFTSchema = this.CreateNFTSchema.bind(this);
    this.CreateMetadata = this.CreateMetadata.bind(this);
    this.PerformActionByAdmin = this.PerformActionByAdmin.bind(this);
    this.AddAttribute = this.AddAttribute.bind(this);
    this.AddAction = this.AddAction.bind(this);
    this.SetBaseUri = this.SetBaseUri.bind(this);
    this.ToggleAction = this.ToggleAction.bind(this);
    this.ChangeSchemaOwner = this.ChangeSchemaOwner.bind(this);
    this.ResyncAttributes = this.ResyncAttributes.bind(this);
    this.ShowAttributes = this.ShowAttributes.bind(this);
    this.SetFeeConfig = this.SetFeeConfig.bind(this);
    this.SetMintauth = this.SetMintauth.bind(this);
    this.ChangeOrgOwner = this.ChangeOrgOwner.bind(this);
    this.SetUriRetrievalMethod = this.SetUriRetrievalMethod.bind(this);
    this.SetOriginChain = this.SetOriginChain.bind(this);
    this.SetOriginContract = this.SetOriginContract.bind(this);
    this.SetAttributeOveriding = this.SetAttributeOveriding.bind(this);
    this.SetMetadataFormat = this.SetMetadataFormat.bind(this);
    this.CreateActionExecutor = this.CreateActionExecutor.bind(this);
    this.DeleteActionExecutor = this.DeleteActionExecutor.bind(this);
    this.UpdateSchemaAttribute = this.UpdateSchemaAttribute.bind(this);
    this.UpdateAction = this.UpdateAction.bind(this);
    this.ProposalVirtualSchema = this.ProposalVirtualSchema.bind(this);
    this.PerformVirtualAction = this.PerformVirtualAction.bind(this);
    this.VoteVirtualSchemaProposal = this.VoteVirtualSchemaProposal.bind(this);
  }
  UpdateParams(request: MsgUpdateParams): Promise<MsgUpdateParamsResponse> {
    const data = MsgUpdateParams.encode(request).finish();
    const promise = this.rpc.request(this.service, "UpdateParams", data);
    return promise.then((data) => MsgUpdateParamsResponse.decode(new BinaryReader(data)));
  }

  CreateNFTSchema(request: MsgCreateNFTSchema): Promise<MsgCreateNFTSchemaResponse> {
    const data = MsgCreateNFTSchema.encode(request).finish();
    const promise = this.rpc.request(this.service, "CreateNFTSchema", data);
    return promise.then((data) => MsgCreateNFTSchemaResponse.decode(new BinaryReader(data)));
  }

  CreateMetadata(request: MsgCreateMetadata): Promise<MsgCreateMetadataResponse> {
    const data = MsgCreateMetadata.encode(request).finish();
    const promise = this.rpc.request(this.service, "CreateMetadata", data);
    return promise.then((data) => MsgCreateMetadataResponse.decode(new BinaryReader(data)));
  }

  PerformActionByAdmin(request: MsgPerformActionByAdmin): Promise<MsgPerformActionByAdminResponse> {
    const data = MsgPerformActionByAdmin.encode(request).finish();
    const promise = this.rpc.request(this.service, "PerformActionByAdmin", data);
    return promise.then((data) => MsgPerformActionByAdminResponse.decode(new BinaryReader(data)));
  }

  AddAttribute(request: MsgAddAttribute): Promise<MsgAddAttributeResponse> {
    const data = MsgAddAttribute.encode(request).finish();
    const promise = this.rpc.request(this.service, "AddAttribute", data);
    return promise.then((data) => MsgAddAttributeResponse.decode(new BinaryReader(data)));
  }

  AddAction(request: MsgAddAction): Promise<MsgAddActionResponse> {
    const data = MsgAddAction.encode(request).finish();
    const promise = this.rpc.request(this.service, "AddAction", data);
    return promise.then((data) => MsgAddActionResponse.decode(new BinaryReader(data)));
  }

  SetBaseUri(request: MsgSetBaseUri): Promise<MsgSetBaseUriResponse> {
    const data = MsgSetBaseUri.encode(request).finish();
    const promise = this.rpc.request(this.service, "SetBaseUri", data);
    return promise.then((data) => MsgSetBaseUriResponse.decode(new BinaryReader(data)));
  }

  ToggleAction(request: MsgToggleAction): Promise<MsgToggleActionResponse> {
    const data = MsgToggleAction.encode(request).finish();
    const promise = this.rpc.request(this.service, "ToggleAction", data);
    return promise.then((data) => MsgToggleActionResponse.decode(new BinaryReader(data)));
  }

  ChangeSchemaOwner(request: MsgChangeSchemaOwner): Promise<MsgChangeSchemaOwnerResponse> {
    const data = MsgChangeSchemaOwner.encode(request).finish();
    const promise = this.rpc.request(this.service, "ChangeSchemaOwner", data);
    return promise.then((data) => MsgChangeSchemaOwnerResponse.decode(new BinaryReader(data)));
  }

  ResyncAttributes(request: MsgResyncAttributes): Promise<MsgResyncAttributesResponse> {
    const data = MsgResyncAttributes.encode(request).finish();
    const promise = this.rpc.request(this.service, "ResyncAttributes", data);
    return promise.then((data) => MsgResyncAttributesResponse.decode(new BinaryReader(data)));
  }

  ShowAttributes(request: MsgShowAttributes): Promise<MsgShowAttributesResponse> {
    const data = MsgShowAttributes.encode(request).finish();
    const promise = this.rpc.request(this.service, "ShowAttributes", data);
    return promise.then((data) => MsgShowAttributesResponse.decode(new BinaryReader(data)));
  }

  SetFeeConfig(request: MsgSetFeeConfig): Promise<MsgSetFeeConfigResponse> {
    const data = MsgSetFeeConfig.encode(request).finish();
    const promise = this.rpc.request(this.service, "SetFeeConfig", data);
    return promise.then((data) => MsgSetFeeConfigResponse.decode(new BinaryReader(data)));
  }

  SetMintauth(request: MsgSetMintauth): Promise<MsgSetMintauthResponse> {
    const data = MsgSetMintauth.encode(request).finish();
    const promise = this.rpc.request(this.service, "SetMintauth", data);
    return promise.then((data) => MsgSetMintauthResponse.decode(new BinaryReader(data)));
  }

  ChangeOrgOwner(request: MsgChangeOrgOwner): Promise<MsgChangeOrgOwnerResponse> {
    const data = MsgChangeOrgOwner.encode(request).finish();
    const promise = this.rpc.request(this.service, "ChangeOrgOwner", data);
    return promise.then((data) => MsgChangeOrgOwnerResponse.decode(new BinaryReader(data)));
  }

  SetUriRetrievalMethod(request: MsgSetUriRetrievalMethod): Promise<MsgSetUriRetrievalMethodResponse> {
    const data = MsgSetUriRetrievalMethod.encode(request).finish();
    const promise = this.rpc.request(this.service, "SetUriRetrievalMethod", data);
    return promise.then((data) => MsgSetUriRetrievalMethodResponse.decode(new BinaryReader(data)));
  }

  SetOriginChain(request: MsgSetOriginChain): Promise<MsgSetOriginChainResponse> {
    const data = MsgSetOriginChain.encode(request).finish();
    const promise = this.rpc.request(this.service, "SetOriginChain", data);
    return promise.then((data) => MsgSetOriginChainResponse.decode(new BinaryReader(data)));
  }

  SetOriginContract(request: MsgSetOriginContract): Promise<MsgSetOriginContractResponse> {
    const data = MsgSetOriginContract.encode(request).finish();
    const promise = this.rpc.request(this.service, "SetOriginContract", data);
    return promise.then((data) => MsgSetOriginContractResponse.decode(new BinaryReader(data)));
  }

  SetAttributeOveriding(request: MsgSetAttributeOveriding): Promise<MsgSetAttributeOveridingResponse> {
    const data = MsgSetAttributeOveriding.encode(request).finish();
    const promise = this.rpc.request(this.service, "SetAttributeOveriding", data);
    return promise.then((data) => MsgSetAttributeOveridingResponse.decode(new BinaryReader(data)));
  }

  SetMetadataFormat(request: MsgSetMetadataFormat): Promise<MsgSetMetadataFormatResponse> {
    const data = MsgSetMetadataFormat.encode(request).finish();
    const promise = this.rpc.request(this.service, "SetMetadataFormat", data);
    return promise.then((data) => MsgSetMetadataFormatResponse.decode(new BinaryReader(data)));
  }

  CreateActionExecutor(request: MsgCreateActionExecutor): Promise<MsgCreateActionExecutorResponse> {
    const data = MsgCreateActionExecutor.encode(request).finish();
    const promise = this.rpc.request(this.service, "CreateActionExecutor", data);
    return promise.then((data) => MsgCreateActionExecutorResponse.decode(new BinaryReader(data)));
  }

  DeleteActionExecutor(request: MsgDeleteActionExecutor): Promise<MsgDeleteActionExecutorResponse> {
    const data = MsgDeleteActionExecutor.encode(request).finish();
    const promise = this.rpc.request(this.service, "DeleteActionExecutor", data);
    return promise.then((data) => MsgDeleteActionExecutorResponse.decode(new BinaryReader(data)));
  }

  UpdateSchemaAttribute(request: MsgUpdateSchemaAttribute): Promise<MsgUpdateSchemaAttributeResponse> {
    const data = MsgUpdateSchemaAttribute.encode(request).finish();
    const promise = this.rpc.request(this.service, "UpdateSchemaAttribute", data);
    return promise.then((data) => MsgUpdateSchemaAttributeResponse.decode(new BinaryReader(data)));
  }

  UpdateAction(request: MsgUpdateAction): Promise<MsgUpdateActionResponse> {
    const data = MsgUpdateAction.encode(request).finish();
    const promise = this.rpc.request(this.service, "UpdateAction", data);
    return promise.then((data) => MsgUpdateActionResponse.decode(new BinaryReader(data)));
  }

  ProposalVirtualSchema(request: MsgProposalVirtualSchema): Promise<MsgProposalVirtualSchemaResponse> {
    const data = MsgProposalVirtualSchema.encode(request).finish();
    const promise = this.rpc.request(this.service, "ProposalVirtualSchema", data);
    return promise.then((data) => MsgProposalVirtualSchemaResponse.decode(new BinaryReader(data)));
  }

  PerformVirtualAction(request: MsgPerformVirtualAction): Promise<MsgPerformVirtualActionResponse> {
    const data = MsgPerformVirtualAction.encode(request).finish();
    const promise = this.rpc.request(this.service, "PerformVirtualAction", data);
    return promise.then((data) => MsgPerformVirtualActionResponse.decode(new BinaryReader(data)));
  }

  VoteVirtualSchemaProposal(request: MsgVoteVirtualSchemaProposal): Promise<MsgVoteVirtualSchemaProposalResponse> {
    const data = MsgVoteVirtualSchemaProposal.encode(request).finish();
    const promise = this.rpc.request(this.service, "VoteVirtualSchemaProposal", data);
    return promise.then((data) => MsgVoteVirtualSchemaProposalResponse.decode(new BinaryReader(data)));
  }
}

interface Rpc {
  request(service: string, method: string, data: Uint8Array): Promise<Uint8Array>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
