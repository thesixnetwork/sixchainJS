// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.6.1
//   protoc               unknown
// source: sixprotocol/tokenmngr/tx.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { Coin } from "../../cosmos/base/v1beta1/coin";
import { Params } from "./params";

export const protobufPackage = "sixprotocol.tokenmngr";

/** MsgUpdateParams is the Msg/UpdateParams request type. */
export interface MsgUpdateParams {
  /**
   * authority is the address that controls the module (defaults to x/gov unless
   * overwritten).
   */
  authority: string;
  /** NOTE: All parameters must be supplied. */
  params: Params | undefined;
}

/**
 * MsgUpdateParamsResponse defines the response structure for executing a
 * MsgUpdateParams message.
 */
export interface MsgUpdateParamsResponse {
}

export interface MsgCreateToken {
  creator: string;
  name: string;
  maxSupply: Coin | undefined;
  denomMetaData: string;
  mintee: string;
}

export interface MsgCreateTokenResponse {
}

export interface MsgUpdateToken {
  creator: string;
  name: string;
  maxSupply: Coin | undefined;
  mintee: string;
}

export interface MsgUpdateTokenResponse {
}

export interface MsgDeleteToken {
  creator: string;
  name: string;
}

export interface MsgDeleteTokenResponse {
}

export interface MsgCreateMintperm {
  creator: string;
  token: string;
  address: string;
}

export interface MsgCreateMintpermResponse {
}

export interface MsgUpdateMintperm {
  creator: string;
  token: string;
  address: string;
}

export interface MsgUpdateMintpermResponse {
}

export interface MsgDeleteMintperm {
  creator: string;
  token: string;
  address: string;
}

export interface MsgDeleteMintpermResponse {
}

export interface MsgCreateOptions {
  creator: string;
  defaultMintee: string;
}

export interface MsgCreateOptionsResponse {
}

export interface MsgUpdateOptions {
  creator: string;
  defaultMintee: string;
}

export interface MsgUpdateOptionsResponse {
}

export interface MsgDeleteOptions {
  creator: string;
}

export interface MsgDeleteOptionsResponse {
}

export interface MsgBurn {
  creator: string;
  amount: Coin | undefined;
}

export interface MsgBurnResponse {
  id: number;
}

export interface MsgWrapToken {
  creator: string;
  amount: Coin | undefined;
  receiver: string;
}

export interface MsgWrapTokenResponse {
  amount: Coin | undefined;
}

export interface MsgUnwrapToken {
  creator: string;
  amount: Coin | undefined;
  receiver: string;
}

export interface MsgUnwrapTokenResponse {
  amount: Coin | undefined;
}

export interface MsgSendWrapToken {
  creator: string;
  ethAddress: string;
  amount: Coin | undefined;
}

export interface MsgSendWrapTokenResponse {
  receiver: string;
  amount: string;
}

function createBaseMsgUpdateParams(): MsgUpdateParams {
  return { authority: "", params: undefined };
}

export const MsgUpdateParams: MessageFns<MsgUpdateParams> = {
  encode(message: MsgUpdateParams, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.authority !== "") {
      writer.uint32(10).string(message.authority);
    }
    if (message.params !== undefined) {
      Params.encode(message.params, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgUpdateParams {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgUpdateParams();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.authority = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.params = Params.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgUpdateParams {
    return {
      authority: isSet(object.authority) ? globalThis.String(object.authority) : "",
      params: isSet(object.params) ? Params.fromJSON(object.params) : undefined,
    };
  },

  toJSON(message: MsgUpdateParams): unknown {
    const obj: any = {};
    if (message.authority !== "") {
      obj.authority = message.authority;
    }
    if (message.params !== undefined) {
      obj.params = Params.toJSON(message.params);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgUpdateParams>, I>>(base?: I): MsgUpdateParams {
    return MsgUpdateParams.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgUpdateParams>, I>>(object: I): MsgUpdateParams {
    const message = createBaseMsgUpdateParams();
    message.authority = object.authority ?? "";
    message.params = (object.params !== undefined && object.params !== null)
      ? Params.fromPartial(object.params)
      : undefined;
    return message;
  },
};

function createBaseMsgUpdateParamsResponse(): MsgUpdateParamsResponse {
  return {};
}

export const MsgUpdateParamsResponse: MessageFns<MsgUpdateParamsResponse> = {
  encode(_: MsgUpdateParamsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgUpdateParamsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgUpdateParamsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgUpdateParamsResponse {
    return {};
  },

  toJSON(_: MsgUpdateParamsResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgUpdateParamsResponse>, I>>(base?: I): MsgUpdateParamsResponse {
    return MsgUpdateParamsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgUpdateParamsResponse>, I>>(_: I): MsgUpdateParamsResponse {
    const message = createBaseMsgUpdateParamsResponse();
    return message;
  },
};

function createBaseMsgCreateToken(): MsgCreateToken {
  return { creator: "", name: "", maxSupply: undefined, denomMetaData: "", mintee: "" };
}

export const MsgCreateToken: MessageFns<MsgCreateToken> = {
  encode(message: MsgCreateToken, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.creator !== "") {
      writer.uint32(10).string(message.creator);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.maxSupply !== undefined) {
      Coin.encode(message.maxSupply, writer.uint32(26).fork()).join();
    }
    if (message.denomMetaData !== "") {
      writer.uint32(34).string(message.denomMetaData);
    }
    if (message.mintee !== "") {
      writer.uint32(42).string(message.mintee);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgCreateToken {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgCreateToken();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.creator = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.maxSupply = Coin.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.denomMetaData = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.mintee = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgCreateToken {
    return {
      creator: isSet(object.creator) ? globalThis.String(object.creator) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      maxSupply: isSet(object.maxSupply) ? Coin.fromJSON(object.maxSupply) : undefined,
      denomMetaData: isSet(object.denomMetaData) ? globalThis.String(object.denomMetaData) : "",
      mintee: isSet(object.mintee) ? globalThis.String(object.mintee) : "",
    };
  },

  toJSON(message: MsgCreateToken): unknown {
    const obj: any = {};
    if (message.creator !== "") {
      obj.creator = message.creator;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.maxSupply !== undefined) {
      obj.maxSupply = Coin.toJSON(message.maxSupply);
    }
    if (message.denomMetaData !== "") {
      obj.denomMetaData = message.denomMetaData;
    }
    if (message.mintee !== "") {
      obj.mintee = message.mintee;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgCreateToken>, I>>(base?: I): MsgCreateToken {
    return MsgCreateToken.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgCreateToken>, I>>(object: I): MsgCreateToken {
    const message = createBaseMsgCreateToken();
    message.creator = object.creator ?? "";
    message.name = object.name ?? "";
    message.maxSupply = (object.maxSupply !== undefined && object.maxSupply !== null)
      ? Coin.fromPartial(object.maxSupply)
      : undefined;
    message.denomMetaData = object.denomMetaData ?? "";
    message.mintee = object.mintee ?? "";
    return message;
  },
};

function createBaseMsgCreateTokenResponse(): MsgCreateTokenResponse {
  return {};
}

export const MsgCreateTokenResponse: MessageFns<MsgCreateTokenResponse> = {
  encode(_: MsgCreateTokenResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgCreateTokenResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgCreateTokenResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgCreateTokenResponse {
    return {};
  },

  toJSON(_: MsgCreateTokenResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgCreateTokenResponse>, I>>(base?: I): MsgCreateTokenResponse {
    return MsgCreateTokenResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgCreateTokenResponse>, I>>(_: I): MsgCreateTokenResponse {
    const message = createBaseMsgCreateTokenResponse();
    return message;
  },
};

function createBaseMsgUpdateToken(): MsgUpdateToken {
  return { creator: "", name: "", maxSupply: undefined, mintee: "" };
}

export const MsgUpdateToken: MessageFns<MsgUpdateToken> = {
  encode(message: MsgUpdateToken, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.creator !== "") {
      writer.uint32(10).string(message.creator);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.maxSupply !== undefined) {
      Coin.encode(message.maxSupply, writer.uint32(34).fork()).join();
    }
    if (message.mintee !== "") {
      writer.uint32(42).string(message.mintee);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgUpdateToken {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgUpdateToken();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.creator = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.maxSupply = Coin.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.mintee = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgUpdateToken {
    return {
      creator: isSet(object.creator) ? globalThis.String(object.creator) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      maxSupply: isSet(object.maxSupply) ? Coin.fromJSON(object.maxSupply) : undefined,
      mintee: isSet(object.mintee) ? globalThis.String(object.mintee) : "",
    };
  },

  toJSON(message: MsgUpdateToken): unknown {
    const obj: any = {};
    if (message.creator !== "") {
      obj.creator = message.creator;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.maxSupply !== undefined) {
      obj.maxSupply = Coin.toJSON(message.maxSupply);
    }
    if (message.mintee !== "") {
      obj.mintee = message.mintee;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgUpdateToken>, I>>(base?: I): MsgUpdateToken {
    return MsgUpdateToken.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgUpdateToken>, I>>(object: I): MsgUpdateToken {
    const message = createBaseMsgUpdateToken();
    message.creator = object.creator ?? "";
    message.name = object.name ?? "";
    message.maxSupply = (object.maxSupply !== undefined && object.maxSupply !== null)
      ? Coin.fromPartial(object.maxSupply)
      : undefined;
    message.mintee = object.mintee ?? "";
    return message;
  },
};

function createBaseMsgUpdateTokenResponse(): MsgUpdateTokenResponse {
  return {};
}

export const MsgUpdateTokenResponse: MessageFns<MsgUpdateTokenResponse> = {
  encode(_: MsgUpdateTokenResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgUpdateTokenResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgUpdateTokenResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgUpdateTokenResponse {
    return {};
  },

  toJSON(_: MsgUpdateTokenResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgUpdateTokenResponse>, I>>(base?: I): MsgUpdateTokenResponse {
    return MsgUpdateTokenResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgUpdateTokenResponse>, I>>(_: I): MsgUpdateTokenResponse {
    const message = createBaseMsgUpdateTokenResponse();
    return message;
  },
};

function createBaseMsgDeleteToken(): MsgDeleteToken {
  return { creator: "", name: "" };
}

export const MsgDeleteToken: MessageFns<MsgDeleteToken> = {
  encode(message: MsgDeleteToken, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.creator !== "") {
      writer.uint32(10).string(message.creator);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgDeleteToken {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgDeleteToken();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.creator = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgDeleteToken {
    return {
      creator: isSet(object.creator) ? globalThis.String(object.creator) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
    };
  },

  toJSON(message: MsgDeleteToken): unknown {
    const obj: any = {};
    if (message.creator !== "") {
      obj.creator = message.creator;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgDeleteToken>, I>>(base?: I): MsgDeleteToken {
    return MsgDeleteToken.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgDeleteToken>, I>>(object: I): MsgDeleteToken {
    const message = createBaseMsgDeleteToken();
    message.creator = object.creator ?? "";
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseMsgDeleteTokenResponse(): MsgDeleteTokenResponse {
  return {};
}

export const MsgDeleteTokenResponse: MessageFns<MsgDeleteTokenResponse> = {
  encode(_: MsgDeleteTokenResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgDeleteTokenResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgDeleteTokenResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgDeleteTokenResponse {
    return {};
  },

  toJSON(_: MsgDeleteTokenResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgDeleteTokenResponse>, I>>(base?: I): MsgDeleteTokenResponse {
    return MsgDeleteTokenResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgDeleteTokenResponse>, I>>(_: I): MsgDeleteTokenResponse {
    const message = createBaseMsgDeleteTokenResponse();
    return message;
  },
};

function createBaseMsgCreateMintperm(): MsgCreateMintperm {
  return { creator: "", token: "", address: "" };
}

export const MsgCreateMintperm: MessageFns<MsgCreateMintperm> = {
  encode(message: MsgCreateMintperm, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.creator !== "") {
      writer.uint32(10).string(message.creator);
    }
    if (message.token !== "") {
      writer.uint32(18).string(message.token);
    }
    if (message.address !== "") {
      writer.uint32(26).string(message.address);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgCreateMintperm {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgCreateMintperm();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.creator = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.token = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.address = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgCreateMintperm {
    return {
      creator: isSet(object.creator) ? globalThis.String(object.creator) : "",
      token: isSet(object.token) ? globalThis.String(object.token) : "",
      address: isSet(object.address) ? globalThis.String(object.address) : "",
    };
  },

  toJSON(message: MsgCreateMintperm): unknown {
    const obj: any = {};
    if (message.creator !== "") {
      obj.creator = message.creator;
    }
    if (message.token !== "") {
      obj.token = message.token;
    }
    if (message.address !== "") {
      obj.address = message.address;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgCreateMintperm>, I>>(base?: I): MsgCreateMintperm {
    return MsgCreateMintperm.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgCreateMintperm>, I>>(object: I): MsgCreateMintperm {
    const message = createBaseMsgCreateMintperm();
    message.creator = object.creator ?? "";
    message.token = object.token ?? "";
    message.address = object.address ?? "";
    return message;
  },
};

function createBaseMsgCreateMintpermResponse(): MsgCreateMintpermResponse {
  return {};
}

export const MsgCreateMintpermResponse: MessageFns<MsgCreateMintpermResponse> = {
  encode(_: MsgCreateMintpermResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgCreateMintpermResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgCreateMintpermResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgCreateMintpermResponse {
    return {};
  },

  toJSON(_: MsgCreateMintpermResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgCreateMintpermResponse>, I>>(base?: I): MsgCreateMintpermResponse {
    return MsgCreateMintpermResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgCreateMintpermResponse>, I>>(_: I): MsgCreateMintpermResponse {
    const message = createBaseMsgCreateMintpermResponse();
    return message;
  },
};

function createBaseMsgUpdateMintperm(): MsgUpdateMintperm {
  return { creator: "", token: "", address: "" };
}

export const MsgUpdateMintperm: MessageFns<MsgUpdateMintperm> = {
  encode(message: MsgUpdateMintperm, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.creator !== "") {
      writer.uint32(10).string(message.creator);
    }
    if (message.token !== "") {
      writer.uint32(18).string(message.token);
    }
    if (message.address !== "") {
      writer.uint32(26).string(message.address);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgUpdateMintperm {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgUpdateMintperm();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.creator = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.token = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.address = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgUpdateMintperm {
    return {
      creator: isSet(object.creator) ? globalThis.String(object.creator) : "",
      token: isSet(object.token) ? globalThis.String(object.token) : "",
      address: isSet(object.address) ? globalThis.String(object.address) : "",
    };
  },

  toJSON(message: MsgUpdateMintperm): unknown {
    const obj: any = {};
    if (message.creator !== "") {
      obj.creator = message.creator;
    }
    if (message.token !== "") {
      obj.token = message.token;
    }
    if (message.address !== "") {
      obj.address = message.address;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgUpdateMintperm>, I>>(base?: I): MsgUpdateMintperm {
    return MsgUpdateMintperm.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgUpdateMintperm>, I>>(object: I): MsgUpdateMintperm {
    const message = createBaseMsgUpdateMintperm();
    message.creator = object.creator ?? "";
    message.token = object.token ?? "";
    message.address = object.address ?? "";
    return message;
  },
};

function createBaseMsgUpdateMintpermResponse(): MsgUpdateMintpermResponse {
  return {};
}

export const MsgUpdateMintpermResponse: MessageFns<MsgUpdateMintpermResponse> = {
  encode(_: MsgUpdateMintpermResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgUpdateMintpermResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgUpdateMintpermResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgUpdateMintpermResponse {
    return {};
  },

  toJSON(_: MsgUpdateMintpermResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgUpdateMintpermResponse>, I>>(base?: I): MsgUpdateMintpermResponse {
    return MsgUpdateMintpermResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgUpdateMintpermResponse>, I>>(_: I): MsgUpdateMintpermResponse {
    const message = createBaseMsgUpdateMintpermResponse();
    return message;
  },
};

function createBaseMsgDeleteMintperm(): MsgDeleteMintperm {
  return { creator: "", token: "", address: "" };
}

export const MsgDeleteMintperm: MessageFns<MsgDeleteMintperm> = {
  encode(message: MsgDeleteMintperm, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.creator !== "") {
      writer.uint32(10).string(message.creator);
    }
    if (message.token !== "") {
      writer.uint32(18).string(message.token);
    }
    if (message.address !== "") {
      writer.uint32(26).string(message.address);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgDeleteMintperm {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgDeleteMintperm();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.creator = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.token = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.address = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgDeleteMintperm {
    return {
      creator: isSet(object.creator) ? globalThis.String(object.creator) : "",
      token: isSet(object.token) ? globalThis.String(object.token) : "",
      address: isSet(object.address) ? globalThis.String(object.address) : "",
    };
  },

  toJSON(message: MsgDeleteMintperm): unknown {
    const obj: any = {};
    if (message.creator !== "") {
      obj.creator = message.creator;
    }
    if (message.token !== "") {
      obj.token = message.token;
    }
    if (message.address !== "") {
      obj.address = message.address;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgDeleteMintperm>, I>>(base?: I): MsgDeleteMintperm {
    return MsgDeleteMintperm.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgDeleteMintperm>, I>>(object: I): MsgDeleteMintperm {
    const message = createBaseMsgDeleteMintperm();
    message.creator = object.creator ?? "";
    message.token = object.token ?? "";
    message.address = object.address ?? "";
    return message;
  },
};

function createBaseMsgDeleteMintpermResponse(): MsgDeleteMintpermResponse {
  return {};
}

export const MsgDeleteMintpermResponse: MessageFns<MsgDeleteMintpermResponse> = {
  encode(_: MsgDeleteMintpermResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgDeleteMintpermResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgDeleteMintpermResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgDeleteMintpermResponse {
    return {};
  },

  toJSON(_: MsgDeleteMintpermResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgDeleteMintpermResponse>, I>>(base?: I): MsgDeleteMintpermResponse {
    return MsgDeleteMintpermResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgDeleteMintpermResponse>, I>>(_: I): MsgDeleteMintpermResponse {
    const message = createBaseMsgDeleteMintpermResponse();
    return message;
  },
};

function createBaseMsgCreateOptions(): MsgCreateOptions {
  return { creator: "", defaultMintee: "" };
}

export const MsgCreateOptions: MessageFns<MsgCreateOptions> = {
  encode(message: MsgCreateOptions, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.creator !== "") {
      writer.uint32(10).string(message.creator);
    }
    if (message.defaultMintee !== "") {
      writer.uint32(26).string(message.defaultMintee);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgCreateOptions {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgCreateOptions();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.creator = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.defaultMintee = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgCreateOptions {
    return {
      creator: isSet(object.creator) ? globalThis.String(object.creator) : "",
      defaultMintee: isSet(object.defaultMintee) ? globalThis.String(object.defaultMintee) : "",
    };
  },

  toJSON(message: MsgCreateOptions): unknown {
    const obj: any = {};
    if (message.creator !== "") {
      obj.creator = message.creator;
    }
    if (message.defaultMintee !== "") {
      obj.defaultMintee = message.defaultMintee;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgCreateOptions>, I>>(base?: I): MsgCreateOptions {
    return MsgCreateOptions.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgCreateOptions>, I>>(object: I): MsgCreateOptions {
    const message = createBaseMsgCreateOptions();
    message.creator = object.creator ?? "";
    message.defaultMintee = object.defaultMintee ?? "";
    return message;
  },
};

function createBaseMsgCreateOptionsResponse(): MsgCreateOptionsResponse {
  return {};
}

export const MsgCreateOptionsResponse: MessageFns<MsgCreateOptionsResponse> = {
  encode(_: MsgCreateOptionsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgCreateOptionsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgCreateOptionsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgCreateOptionsResponse {
    return {};
  },

  toJSON(_: MsgCreateOptionsResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgCreateOptionsResponse>, I>>(base?: I): MsgCreateOptionsResponse {
    return MsgCreateOptionsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgCreateOptionsResponse>, I>>(_: I): MsgCreateOptionsResponse {
    const message = createBaseMsgCreateOptionsResponse();
    return message;
  },
};

function createBaseMsgUpdateOptions(): MsgUpdateOptions {
  return { creator: "", defaultMintee: "" };
}

export const MsgUpdateOptions: MessageFns<MsgUpdateOptions> = {
  encode(message: MsgUpdateOptions, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.creator !== "") {
      writer.uint32(10).string(message.creator);
    }
    if (message.defaultMintee !== "") {
      writer.uint32(26).string(message.defaultMintee);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgUpdateOptions {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgUpdateOptions();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.creator = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.defaultMintee = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgUpdateOptions {
    return {
      creator: isSet(object.creator) ? globalThis.String(object.creator) : "",
      defaultMintee: isSet(object.defaultMintee) ? globalThis.String(object.defaultMintee) : "",
    };
  },

  toJSON(message: MsgUpdateOptions): unknown {
    const obj: any = {};
    if (message.creator !== "") {
      obj.creator = message.creator;
    }
    if (message.defaultMintee !== "") {
      obj.defaultMintee = message.defaultMintee;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgUpdateOptions>, I>>(base?: I): MsgUpdateOptions {
    return MsgUpdateOptions.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgUpdateOptions>, I>>(object: I): MsgUpdateOptions {
    const message = createBaseMsgUpdateOptions();
    message.creator = object.creator ?? "";
    message.defaultMintee = object.defaultMintee ?? "";
    return message;
  },
};

function createBaseMsgUpdateOptionsResponse(): MsgUpdateOptionsResponse {
  return {};
}

export const MsgUpdateOptionsResponse: MessageFns<MsgUpdateOptionsResponse> = {
  encode(_: MsgUpdateOptionsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgUpdateOptionsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgUpdateOptionsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgUpdateOptionsResponse {
    return {};
  },

  toJSON(_: MsgUpdateOptionsResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgUpdateOptionsResponse>, I>>(base?: I): MsgUpdateOptionsResponse {
    return MsgUpdateOptionsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgUpdateOptionsResponse>, I>>(_: I): MsgUpdateOptionsResponse {
    const message = createBaseMsgUpdateOptionsResponse();
    return message;
  },
};

function createBaseMsgDeleteOptions(): MsgDeleteOptions {
  return { creator: "" };
}

export const MsgDeleteOptions: MessageFns<MsgDeleteOptions> = {
  encode(message: MsgDeleteOptions, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.creator !== "") {
      writer.uint32(10).string(message.creator);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgDeleteOptions {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgDeleteOptions();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.creator = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgDeleteOptions {
    return { creator: isSet(object.creator) ? globalThis.String(object.creator) : "" };
  },

  toJSON(message: MsgDeleteOptions): unknown {
    const obj: any = {};
    if (message.creator !== "") {
      obj.creator = message.creator;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgDeleteOptions>, I>>(base?: I): MsgDeleteOptions {
    return MsgDeleteOptions.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgDeleteOptions>, I>>(object: I): MsgDeleteOptions {
    const message = createBaseMsgDeleteOptions();
    message.creator = object.creator ?? "";
    return message;
  },
};

function createBaseMsgDeleteOptionsResponse(): MsgDeleteOptionsResponse {
  return {};
}

export const MsgDeleteOptionsResponse: MessageFns<MsgDeleteOptionsResponse> = {
  encode(_: MsgDeleteOptionsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgDeleteOptionsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgDeleteOptionsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgDeleteOptionsResponse {
    return {};
  },

  toJSON(_: MsgDeleteOptionsResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgDeleteOptionsResponse>, I>>(base?: I): MsgDeleteOptionsResponse {
    return MsgDeleteOptionsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgDeleteOptionsResponse>, I>>(_: I): MsgDeleteOptionsResponse {
    const message = createBaseMsgDeleteOptionsResponse();
    return message;
  },
};

function createBaseMsgBurn(): MsgBurn {
  return { creator: "", amount: undefined };
}

export const MsgBurn: MessageFns<MsgBurn> = {
  encode(message: MsgBurn, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.creator !== "") {
      writer.uint32(10).string(message.creator);
    }
    if (message.amount !== undefined) {
      Coin.encode(message.amount, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgBurn {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgBurn();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.creator = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.amount = Coin.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgBurn {
    return {
      creator: isSet(object.creator) ? globalThis.String(object.creator) : "",
      amount: isSet(object.amount) ? Coin.fromJSON(object.amount) : undefined,
    };
  },

  toJSON(message: MsgBurn): unknown {
    const obj: any = {};
    if (message.creator !== "") {
      obj.creator = message.creator;
    }
    if (message.amount !== undefined) {
      obj.amount = Coin.toJSON(message.amount);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgBurn>, I>>(base?: I): MsgBurn {
    return MsgBurn.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgBurn>, I>>(object: I): MsgBurn {
    const message = createBaseMsgBurn();
    message.creator = object.creator ?? "";
    message.amount = (object.amount !== undefined && object.amount !== null)
      ? Coin.fromPartial(object.amount)
      : undefined;
    return message;
  },
};

function createBaseMsgBurnResponse(): MsgBurnResponse {
  return { id: 0 };
}

export const MsgBurnResponse: MessageFns<MsgBurnResponse> = {
  encode(message: MsgBurnResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== 0) {
      writer.uint32(8).uint64(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgBurnResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgBurnResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgBurnResponse {
    return { id: isSet(object.id) ? globalThis.Number(object.id) : 0 };
  },

  toJSON(message: MsgBurnResponse): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgBurnResponse>, I>>(base?: I): MsgBurnResponse {
    return MsgBurnResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgBurnResponse>, I>>(object: I): MsgBurnResponse {
    const message = createBaseMsgBurnResponse();
    message.id = object.id ?? 0;
    return message;
  },
};

function createBaseMsgWrapToken(): MsgWrapToken {
  return { creator: "", amount: undefined, receiver: "" };
}

export const MsgWrapToken: MessageFns<MsgWrapToken> = {
  encode(message: MsgWrapToken, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.creator !== "") {
      writer.uint32(10).string(message.creator);
    }
    if (message.amount !== undefined) {
      Coin.encode(message.amount, writer.uint32(18).fork()).join();
    }
    if (message.receiver !== "") {
      writer.uint32(26).string(message.receiver);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgWrapToken {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgWrapToken();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.creator = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.amount = Coin.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.receiver = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgWrapToken {
    return {
      creator: isSet(object.creator) ? globalThis.String(object.creator) : "",
      amount: isSet(object.amount) ? Coin.fromJSON(object.amount) : undefined,
      receiver: isSet(object.receiver) ? globalThis.String(object.receiver) : "",
    };
  },

  toJSON(message: MsgWrapToken): unknown {
    const obj: any = {};
    if (message.creator !== "") {
      obj.creator = message.creator;
    }
    if (message.amount !== undefined) {
      obj.amount = Coin.toJSON(message.amount);
    }
    if (message.receiver !== "") {
      obj.receiver = message.receiver;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgWrapToken>, I>>(base?: I): MsgWrapToken {
    return MsgWrapToken.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgWrapToken>, I>>(object: I): MsgWrapToken {
    const message = createBaseMsgWrapToken();
    message.creator = object.creator ?? "";
    message.amount = (object.amount !== undefined && object.amount !== null)
      ? Coin.fromPartial(object.amount)
      : undefined;
    message.receiver = object.receiver ?? "";
    return message;
  },
};

function createBaseMsgWrapTokenResponse(): MsgWrapTokenResponse {
  return { amount: undefined };
}

export const MsgWrapTokenResponse: MessageFns<MsgWrapTokenResponse> = {
  encode(message: MsgWrapTokenResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.amount !== undefined) {
      Coin.encode(message.amount, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgWrapTokenResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgWrapTokenResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.amount = Coin.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgWrapTokenResponse {
    return { amount: isSet(object.amount) ? Coin.fromJSON(object.amount) : undefined };
  },

  toJSON(message: MsgWrapTokenResponse): unknown {
    const obj: any = {};
    if (message.amount !== undefined) {
      obj.amount = Coin.toJSON(message.amount);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgWrapTokenResponse>, I>>(base?: I): MsgWrapTokenResponse {
    return MsgWrapTokenResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgWrapTokenResponse>, I>>(object: I): MsgWrapTokenResponse {
    const message = createBaseMsgWrapTokenResponse();
    message.amount = (object.amount !== undefined && object.amount !== null)
      ? Coin.fromPartial(object.amount)
      : undefined;
    return message;
  },
};

function createBaseMsgUnwrapToken(): MsgUnwrapToken {
  return { creator: "", amount: undefined, receiver: "" };
}

export const MsgUnwrapToken: MessageFns<MsgUnwrapToken> = {
  encode(message: MsgUnwrapToken, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.creator !== "") {
      writer.uint32(10).string(message.creator);
    }
    if (message.amount !== undefined) {
      Coin.encode(message.amount, writer.uint32(18).fork()).join();
    }
    if (message.receiver !== "") {
      writer.uint32(26).string(message.receiver);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgUnwrapToken {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgUnwrapToken();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.creator = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.amount = Coin.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.receiver = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgUnwrapToken {
    return {
      creator: isSet(object.creator) ? globalThis.String(object.creator) : "",
      amount: isSet(object.amount) ? Coin.fromJSON(object.amount) : undefined,
      receiver: isSet(object.receiver) ? globalThis.String(object.receiver) : "",
    };
  },

  toJSON(message: MsgUnwrapToken): unknown {
    const obj: any = {};
    if (message.creator !== "") {
      obj.creator = message.creator;
    }
    if (message.amount !== undefined) {
      obj.amount = Coin.toJSON(message.amount);
    }
    if (message.receiver !== "") {
      obj.receiver = message.receiver;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgUnwrapToken>, I>>(base?: I): MsgUnwrapToken {
    return MsgUnwrapToken.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgUnwrapToken>, I>>(object: I): MsgUnwrapToken {
    const message = createBaseMsgUnwrapToken();
    message.creator = object.creator ?? "";
    message.amount = (object.amount !== undefined && object.amount !== null)
      ? Coin.fromPartial(object.amount)
      : undefined;
    message.receiver = object.receiver ?? "";
    return message;
  },
};

function createBaseMsgUnwrapTokenResponse(): MsgUnwrapTokenResponse {
  return { amount: undefined };
}

export const MsgUnwrapTokenResponse: MessageFns<MsgUnwrapTokenResponse> = {
  encode(message: MsgUnwrapTokenResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.amount !== undefined) {
      Coin.encode(message.amount, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgUnwrapTokenResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgUnwrapTokenResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.amount = Coin.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgUnwrapTokenResponse {
    return { amount: isSet(object.amount) ? Coin.fromJSON(object.amount) : undefined };
  },

  toJSON(message: MsgUnwrapTokenResponse): unknown {
    const obj: any = {};
    if (message.amount !== undefined) {
      obj.amount = Coin.toJSON(message.amount);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgUnwrapTokenResponse>, I>>(base?: I): MsgUnwrapTokenResponse {
    return MsgUnwrapTokenResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgUnwrapTokenResponse>, I>>(object: I): MsgUnwrapTokenResponse {
    const message = createBaseMsgUnwrapTokenResponse();
    message.amount = (object.amount !== undefined && object.amount !== null)
      ? Coin.fromPartial(object.amount)
      : undefined;
    return message;
  },
};

function createBaseMsgSendWrapToken(): MsgSendWrapToken {
  return { creator: "", ethAddress: "", amount: undefined };
}

export const MsgSendWrapToken: MessageFns<MsgSendWrapToken> = {
  encode(message: MsgSendWrapToken, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.creator !== "") {
      writer.uint32(10).string(message.creator);
    }
    if (message.ethAddress !== "") {
      writer.uint32(18).string(message.ethAddress);
    }
    if (message.amount !== undefined) {
      Coin.encode(message.amount, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgSendWrapToken {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgSendWrapToken();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.creator = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.ethAddress = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.amount = Coin.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgSendWrapToken {
    return {
      creator: isSet(object.creator) ? globalThis.String(object.creator) : "",
      ethAddress: isSet(object.ethAddress) ? globalThis.String(object.ethAddress) : "",
      amount: isSet(object.amount) ? Coin.fromJSON(object.amount) : undefined,
    };
  },

  toJSON(message: MsgSendWrapToken): unknown {
    const obj: any = {};
    if (message.creator !== "") {
      obj.creator = message.creator;
    }
    if (message.ethAddress !== "") {
      obj.ethAddress = message.ethAddress;
    }
    if (message.amount !== undefined) {
      obj.amount = Coin.toJSON(message.amount);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgSendWrapToken>, I>>(base?: I): MsgSendWrapToken {
    return MsgSendWrapToken.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgSendWrapToken>, I>>(object: I): MsgSendWrapToken {
    const message = createBaseMsgSendWrapToken();
    message.creator = object.creator ?? "";
    message.ethAddress = object.ethAddress ?? "";
    message.amount = (object.amount !== undefined && object.amount !== null)
      ? Coin.fromPartial(object.amount)
      : undefined;
    return message;
  },
};

function createBaseMsgSendWrapTokenResponse(): MsgSendWrapTokenResponse {
  return { receiver: "", amount: "" };
}

export const MsgSendWrapTokenResponse: MessageFns<MsgSendWrapTokenResponse> = {
  encode(message: MsgSendWrapTokenResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.receiver !== "") {
      writer.uint32(10).string(message.receiver);
    }
    if (message.amount !== "") {
      writer.uint32(18).string(message.amount);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgSendWrapTokenResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgSendWrapTokenResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.receiver = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.amount = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgSendWrapTokenResponse {
    return {
      receiver: isSet(object.receiver) ? globalThis.String(object.receiver) : "",
      amount: isSet(object.amount) ? globalThis.String(object.amount) : "",
    };
  },

  toJSON(message: MsgSendWrapTokenResponse): unknown {
    const obj: any = {};
    if (message.receiver !== "") {
      obj.receiver = message.receiver;
    }
    if (message.amount !== "") {
      obj.amount = message.amount;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgSendWrapTokenResponse>, I>>(base?: I): MsgSendWrapTokenResponse {
    return MsgSendWrapTokenResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgSendWrapTokenResponse>, I>>(object: I): MsgSendWrapTokenResponse {
    const message = createBaseMsgSendWrapTokenResponse();
    message.receiver = object.receiver ?? "";
    message.amount = object.amount ?? "";
    return message;
  },
};

/** Msg defines the Msg service. */
export interface Msg {
  /**
   * UpdateParams defines a (governance) operation for updating the module
   * parameters. The authority defaults to the x/gov module account.
   */
  UpdateParams(request: MsgUpdateParams): Promise<MsgUpdateParamsResponse>;
  CreateToken(request: MsgCreateToken): Promise<MsgCreateTokenResponse>;
  UpdateToken(request: MsgUpdateToken): Promise<MsgUpdateTokenResponse>;
  DeleteToken(request: MsgDeleteToken): Promise<MsgDeleteTokenResponse>;
  CreateMintperm(request: MsgCreateMintperm): Promise<MsgCreateMintpermResponse>;
  UpdateMintperm(request: MsgUpdateMintperm): Promise<MsgUpdateMintpermResponse>;
  DeleteMintperm(request: MsgDeleteMintperm): Promise<MsgDeleteMintpermResponse>;
  CreateOptions(request: MsgCreateOptions): Promise<MsgCreateOptionsResponse>;
  UpdateOptions(request: MsgUpdateOptions): Promise<MsgUpdateOptionsResponse>;
  DeleteOptions(request: MsgDeleteOptions): Promise<MsgDeleteOptionsResponse>;
  Burn(request: MsgBurn): Promise<MsgBurnResponse>;
  WrapToken(request: MsgWrapToken): Promise<MsgWrapTokenResponse>;
  UnwrapToken(request: MsgUnwrapToken): Promise<MsgUnwrapTokenResponse>;
  SendWrapToken(request: MsgSendWrapToken): Promise<MsgSendWrapTokenResponse>;
}

export const MsgServiceName = "sixprotocol.tokenmngr.Msg";
export class MsgClientImpl implements Msg {
  private readonly rpc: Rpc;
  private readonly service: string;
  constructor(rpc: Rpc, opts?: { service?: string }) {
    this.service = opts?.service || MsgServiceName;
    this.rpc = rpc;
    this.UpdateParams = this.UpdateParams.bind(this);
    this.CreateToken = this.CreateToken.bind(this);
    this.UpdateToken = this.UpdateToken.bind(this);
    this.DeleteToken = this.DeleteToken.bind(this);
    this.CreateMintperm = this.CreateMintperm.bind(this);
    this.UpdateMintperm = this.UpdateMintperm.bind(this);
    this.DeleteMintperm = this.DeleteMintperm.bind(this);
    this.CreateOptions = this.CreateOptions.bind(this);
    this.UpdateOptions = this.UpdateOptions.bind(this);
    this.DeleteOptions = this.DeleteOptions.bind(this);
    this.Burn = this.Burn.bind(this);
    this.WrapToken = this.WrapToken.bind(this);
    this.UnwrapToken = this.UnwrapToken.bind(this);
    this.SendWrapToken = this.SendWrapToken.bind(this);
  }
  UpdateParams(request: MsgUpdateParams): Promise<MsgUpdateParamsResponse> {
    const data = MsgUpdateParams.encode(request).finish();
    const promise = this.rpc.request(this.service, "UpdateParams", data);
    return promise.then((data) => MsgUpdateParamsResponse.decode(new BinaryReader(data)));
  }

  CreateToken(request: MsgCreateToken): Promise<MsgCreateTokenResponse> {
    const data = MsgCreateToken.encode(request).finish();
    const promise = this.rpc.request(this.service, "CreateToken", data);
    return promise.then((data) => MsgCreateTokenResponse.decode(new BinaryReader(data)));
  }

  UpdateToken(request: MsgUpdateToken): Promise<MsgUpdateTokenResponse> {
    const data = MsgUpdateToken.encode(request).finish();
    const promise = this.rpc.request(this.service, "UpdateToken", data);
    return promise.then((data) => MsgUpdateTokenResponse.decode(new BinaryReader(data)));
  }

  DeleteToken(request: MsgDeleteToken): Promise<MsgDeleteTokenResponse> {
    const data = MsgDeleteToken.encode(request).finish();
    const promise = this.rpc.request(this.service, "DeleteToken", data);
    return promise.then((data) => MsgDeleteTokenResponse.decode(new BinaryReader(data)));
  }

  CreateMintperm(request: MsgCreateMintperm): Promise<MsgCreateMintpermResponse> {
    const data = MsgCreateMintperm.encode(request).finish();
    const promise = this.rpc.request(this.service, "CreateMintperm", data);
    return promise.then((data) => MsgCreateMintpermResponse.decode(new BinaryReader(data)));
  }

  UpdateMintperm(request: MsgUpdateMintperm): Promise<MsgUpdateMintpermResponse> {
    const data = MsgUpdateMintperm.encode(request).finish();
    const promise = this.rpc.request(this.service, "UpdateMintperm", data);
    return promise.then((data) => MsgUpdateMintpermResponse.decode(new BinaryReader(data)));
  }

  DeleteMintperm(request: MsgDeleteMintperm): Promise<MsgDeleteMintpermResponse> {
    const data = MsgDeleteMintperm.encode(request).finish();
    const promise = this.rpc.request(this.service, "DeleteMintperm", data);
    return promise.then((data) => MsgDeleteMintpermResponse.decode(new BinaryReader(data)));
  }

  CreateOptions(request: MsgCreateOptions): Promise<MsgCreateOptionsResponse> {
    const data = MsgCreateOptions.encode(request).finish();
    const promise = this.rpc.request(this.service, "CreateOptions", data);
    return promise.then((data) => MsgCreateOptionsResponse.decode(new BinaryReader(data)));
  }

  UpdateOptions(request: MsgUpdateOptions): Promise<MsgUpdateOptionsResponse> {
    const data = MsgUpdateOptions.encode(request).finish();
    const promise = this.rpc.request(this.service, "UpdateOptions", data);
    return promise.then((data) => MsgUpdateOptionsResponse.decode(new BinaryReader(data)));
  }

  DeleteOptions(request: MsgDeleteOptions): Promise<MsgDeleteOptionsResponse> {
    const data = MsgDeleteOptions.encode(request).finish();
    const promise = this.rpc.request(this.service, "DeleteOptions", data);
    return promise.then((data) => MsgDeleteOptionsResponse.decode(new BinaryReader(data)));
  }

  Burn(request: MsgBurn): Promise<MsgBurnResponse> {
    const data = MsgBurn.encode(request).finish();
    const promise = this.rpc.request(this.service, "Burn", data);
    return promise.then((data) => MsgBurnResponse.decode(new BinaryReader(data)));
  }

  WrapToken(request: MsgWrapToken): Promise<MsgWrapTokenResponse> {
    const data = MsgWrapToken.encode(request).finish();
    const promise = this.rpc.request(this.service, "WrapToken", data);
    return promise.then((data) => MsgWrapTokenResponse.decode(new BinaryReader(data)));
  }

  UnwrapToken(request: MsgUnwrapToken): Promise<MsgUnwrapTokenResponse> {
    const data = MsgUnwrapToken.encode(request).finish();
    const promise = this.rpc.request(this.service, "UnwrapToken", data);
    return promise.then((data) => MsgUnwrapTokenResponse.decode(new BinaryReader(data)));
  }

  SendWrapToken(request: MsgSendWrapToken): Promise<MsgSendWrapTokenResponse> {
    const data = MsgSendWrapToken.encode(request).finish();
    const promise = this.rpc.request(this.service, "SendWrapToken", data);
    return promise.then((data) => MsgSendWrapTokenResponse.decode(new BinaryReader(data)));
  }
}

interface Rpc {
  request(service: string, method: string, data: Uint8Array): Promise<Uint8Array>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function longToNumber(int64: { toString(): string }): number {
  const num = globalThis.Number(int64.toString());
  if (num > globalThis.Number.MAX_SAFE_INTEGER) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (num < globalThis.Number.MIN_SAFE_INTEGER) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return num;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
