// Generated by Ignite ignite.com/cli

import { SigningStargateClient, DeliverTxResponse, StdFee } from "@cosmjs/stargate";
import { EncodeObject, GeneratedType, OfflineSigner, Registry } from "@cosmjs/proto-signing";
import { msgTypes } from './registry';
import { IgniteClient } from "../client"
import { MissingWalletError } from "../helpers"
import { Api } from "./rest";
import { MsgUpdateParams } from "./types/sixprotocol/tokenmngr/tx";
import { MsgCreateToken } from "./types/sixprotocol/tokenmngr/tx";
import { MsgUpdateToken } from "./types/sixprotocol/tokenmngr/tx";
import { MsgDeleteToken } from "./types/sixprotocol/tokenmngr/tx";
import { MsgCreateMintperm } from "./types/sixprotocol/tokenmngr/tx";
import { MsgUpdateMintperm } from "./types/sixprotocol/tokenmngr/tx";
import { MsgDeleteMintperm } from "./types/sixprotocol/tokenmngr/tx";
import { MsgCreateOptions } from "./types/sixprotocol/tokenmngr/tx";
import { MsgUpdateOptions } from "./types/sixprotocol/tokenmngr/tx";
import { MsgDeleteOptions } from "./types/sixprotocol/tokenmngr/tx";
import { MsgBurn } from "./types/sixprotocol/tokenmngr/tx";
import { MsgWrapToken } from "./types/sixprotocol/tokenmngr/tx";
import { MsgUnwrapToken } from "./types/sixprotocol/tokenmngr/tx";
import { MsgSendWrapToken } from "./types/sixprotocol/tokenmngr/tx";

import { Burn as typeBurn} from "./types"
import { Mintperm as typeMintperm} from "./types"
import { Options as typeOptions} from "./types"
import { Params as typeParams} from "./types"
import { Token as typeToken} from "./types"
import { TokenBurn as typeTokenBurn} from "./types"

export { MsgUpdateParams, MsgCreateToken, MsgUpdateToken, MsgDeleteToken, MsgCreateMintperm, MsgUpdateMintperm, MsgDeleteMintperm, MsgCreateOptions, MsgUpdateOptions, MsgDeleteOptions, MsgBurn, MsgWrapToken, MsgUnwrapToken, MsgSendWrapToken };

type sendMsgUpdateParamsParams = {
  value: MsgUpdateParams,
  fee?: StdFee,
  memo?: string
};

type sendMsgCreateTokenParams = {
  value: MsgCreateToken,
  fee?: StdFee,
  memo?: string
};

type sendMsgUpdateTokenParams = {
  value: MsgUpdateToken,
  fee?: StdFee,
  memo?: string
};

type sendMsgDeleteTokenParams = {
  value: MsgDeleteToken,
  fee?: StdFee,
  memo?: string
};

type sendMsgCreateMintpermParams = {
  value: MsgCreateMintperm,
  fee?: StdFee,
  memo?: string
};

type sendMsgUpdateMintpermParams = {
  value: MsgUpdateMintperm,
  fee?: StdFee,
  memo?: string
};

type sendMsgDeleteMintpermParams = {
  value: MsgDeleteMintperm,
  fee?: StdFee,
  memo?: string
};

type sendMsgCreateOptionsParams = {
  value: MsgCreateOptions,
  fee?: StdFee,
  memo?: string
};

type sendMsgUpdateOptionsParams = {
  value: MsgUpdateOptions,
  fee?: StdFee,
  memo?: string
};

type sendMsgDeleteOptionsParams = {
  value: MsgDeleteOptions,
  fee?: StdFee,
  memo?: string
};

type sendMsgBurnParams = {
  value: MsgBurn,
  fee?: StdFee,
  memo?: string
};

type sendMsgWrapTokenParams = {
  value: MsgWrapToken,
  fee?: StdFee,
  memo?: string
};

type sendMsgUnwrapTokenParams = {
  value: MsgUnwrapToken,
  fee?: StdFee,
  memo?: string
};

type sendMsgSendWrapTokenParams = {
  value: MsgSendWrapToken,
  fee?: StdFee,
  memo?: string
};


type msgUpdateParamsParams = {
  value: MsgUpdateParams,
};

type msgCreateTokenParams = {
  value: MsgCreateToken,
};

type msgUpdateTokenParams = {
  value: MsgUpdateToken,
};

type msgDeleteTokenParams = {
  value: MsgDeleteToken,
};

type msgCreateMintpermParams = {
  value: MsgCreateMintperm,
};

type msgUpdateMintpermParams = {
  value: MsgUpdateMintperm,
};

type msgDeleteMintpermParams = {
  value: MsgDeleteMintperm,
};

type msgCreateOptionsParams = {
  value: MsgCreateOptions,
};

type msgUpdateOptionsParams = {
  value: MsgUpdateOptions,
};

type msgDeleteOptionsParams = {
  value: MsgDeleteOptions,
};

type msgBurnParams = {
  value: MsgBurn,
};

type msgWrapTokenParams = {
  value: MsgWrapToken,
};

type msgUnwrapTokenParams = {
  value: MsgUnwrapToken,
};

type msgSendWrapTokenParams = {
  value: MsgSendWrapToken,
};


export const registry = new Registry(msgTypes);

type Field = {
	name: string;
	type: unknown;
}
function getStructure(template) {
	const structure: {fields: Field[]} = { fields: [] }
	for (let [key, value] of Object.entries(template)) {
		let field = { name: key, type: typeof value }
		structure.fields.push(field)
	}
	return structure
}
const defaultFee = {
  amount: [],
  gas: "200000",
};

interface TxClientOptions {
  addr: string
	prefix: string
	signer?: OfflineSigner
}

export const txClient = ({ signer, prefix, addr }: TxClientOptions = { addr: "http://localhost:26657", prefix: "cosmos" }) => {

  return {
		
		async sendMsgUpdateParams({ value, fee, memo }: sendMsgUpdateParamsParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgUpdateParams: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgUpdateParams({ value: MsgUpdateParams.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgUpdateParams: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgCreateToken({ value, fee, memo }: sendMsgCreateTokenParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgCreateToken: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgCreateToken({ value: MsgCreateToken.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgCreateToken: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgUpdateToken({ value, fee, memo }: sendMsgUpdateTokenParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgUpdateToken: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgUpdateToken({ value: MsgUpdateToken.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgUpdateToken: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgDeleteToken({ value, fee, memo }: sendMsgDeleteTokenParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgDeleteToken: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgDeleteToken({ value: MsgDeleteToken.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgDeleteToken: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgCreateMintperm({ value, fee, memo }: sendMsgCreateMintpermParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgCreateMintperm: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgCreateMintperm({ value: MsgCreateMintperm.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgCreateMintperm: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgUpdateMintperm({ value, fee, memo }: sendMsgUpdateMintpermParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgUpdateMintperm: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgUpdateMintperm({ value: MsgUpdateMintperm.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgUpdateMintperm: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgDeleteMintperm({ value, fee, memo }: sendMsgDeleteMintpermParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgDeleteMintperm: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgDeleteMintperm({ value: MsgDeleteMintperm.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgDeleteMintperm: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgCreateOptions({ value, fee, memo }: sendMsgCreateOptionsParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgCreateOptions: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgCreateOptions({ value: MsgCreateOptions.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgCreateOptions: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgUpdateOptions({ value, fee, memo }: sendMsgUpdateOptionsParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgUpdateOptions: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgUpdateOptions({ value: MsgUpdateOptions.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgUpdateOptions: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgDeleteOptions({ value, fee, memo }: sendMsgDeleteOptionsParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgDeleteOptions: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgDeleteOptions({ value: MsgDeleteOptions.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgDeleteOptions: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgBurn({ value, fee, memo }: sendMsgBurnParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgBurn: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgBurn({ value: MsgBurn.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgBurn: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgWrapToken({ value, fee, memo }: sendMsgWrapTokenParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgWrapToken: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgWrapToken({ value: MsgWrapToken.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgWrapToken: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgUnwrapToken({ value, fee, memo }: sendMsgUnwrapTokenParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgUnwrapToken: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgUnwrapToken({ value: MsgUnwrapToken.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgUnwrapToken: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgSendWrapToken({ value, fee, memo }: sendMsgSendWrapTokenParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgSendWrapToken: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgSendWrapToken({ value: MsgSendWrapToken.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgSendWrapToken: Could not broadcast Tx: '+ e.message)
			}
		},
		
		
		msgUpdateParams({ value }: msgUpdateParamsParams): EncodeObject {
			try {
				return { typeUrl: "/sixprotocol.tokenmngr.MsgUpdateParams", value: MsgUpdateParams.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgUpdateParams: Could not create message: ' + e.message)
			}
		},
		
		msgCreateToken({ value }: msgCreateTokenParams): EncodeObject {
			try {
				return { typeUrl: "/sixprotocol.tokenmngr.MsgCreateToken", value: MsgCreateToken.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgCreateToken: Could not create message: ' + e.message)
			}
		},
		
		msgUpdateToken({ value }: msgUpdateTokenParams): EncodeObject {
			try {
				return { typeUrl: "/sixprotocol.tokenmngr.MsgUpdateToken", value: MsgUpdateToken.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgUpdateToken: Could not create message: ' + e.message)
			}
		},
		
		msgDeleteToken({ value }: msgDeleteTokenParams): EncodeObject {
			try {
				return { typeUrl: "/sixprotocol.tokenmngr.MsgDeleteToken", value: MsgDeleteToken.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgDeleteToken: Could not create message: ' + e.message)
			}
		},
		
		msgCreateMintperm({ value }: msgCreateMintpermParams): EncodeObject {
			try {
				return { typeUrl: "/sixprotocol.tokenmngr.MsgCreateMintperm", value: MsgCreateMintperm.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgCreateMintperm: Could not create message: ' + e.message)
			}
		},
		
		msgUpdateMintperm({ value }: msgUpdateMintpermParams): EncodeObject {
			try {
				return { typeUrl: "/sixprotocol.tokenmngr.MsgUpdateMintperm", value: MsgUpdateMintperm.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgUpdateMintperm: Could not create message: ' + e.message)
			}
		},
		
		msgDeleteMintperm({ value }: msgDeleteMintpermParams): EncodeObject {
			try {
				return { typeUrl: "/sixprotocol.tokenmngr.MsgDeleteMintperm", value: MsgDeleteMintperm.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgDeleteMintperm: Could not create message: ' + e.message)
			}
		},
		
		msgCreateOptions({ value }: msgCreateOptionsParams): EncodeObject {
			try {
				return { typeUrl: "/sixprotocol.tokenmngr.MsgCreateOptions", value: MsgCreateOptions.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgCreateOptions: Could not create message: ' + e.message)
			}
		},
		
		msgUpdateOptions({ value }: msgUpdateOptionsParams): EncodeObject {
			try {
				return { typeUrl: "/sixprotocol.tokenmngr.MsgUpdateOptions", value: MsgUpdateOptions.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgUpdateOptions: Could not create message: ' + e.message)
			}
		},
		
		msgDeleteOptions({ value }: msgDeleteOptionsParams): EncodeObject {
			try {
				return { typeUrl: "/sixprotocol.tokenmngr.MsgDeleteOptions", value: MsgDeleteOptions.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgDeleteOptions: Could not create message: ' + e.message)
			}
		},
		
		msgBurn({ value }: msgBurnParams): EncodeObject {
			try {
				return { typeUrl: "/sixprotocol.tokenmngr.MsgBurn", value: MsgBurn.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgBurn: Could not create message: ' + e.message)
			}
		},
		
		msgWrapToken({ value }: msgWrapTokenParams): EncodeObject {
			try {
				return { typeUrl: "/sixprotocol.tokenmngr.MsgWrapToken", value: MsgWrapToken.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgWrapToken: Could not create message: ' + e.message)
			}
		},
		
		msgUnwrapToken({ value }: msgUnwrapTokenParams): EncodeObject {
			try {
				return { typeUrl: "/sixprotocol.tokenmngr.MsgUnwrapToken", value: MsgUnwrapToken.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgUnwrapToken: Could not create message: ' + e.message)
			}
		},
		
		msgSendWrapToken({ value }: msgSendWrapTokenParams): EncodeObject {
			try {
				return { typeUrl: "/sixprotocol.tokenmngr.MsgSendWrapToken", value: MsgSendWrapToken.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgSendWrapToken: Could not create message: ' + e.message)
			}
		},
		
	}
};

interface QueryClientOptions {
  addr: string
}

export const queryClient = ({ addr: addr }: QueryClientOptions = { addr: "http://localhost:1317" }) => {
  return new Api({ baseURL: addr });
};

class SDKModule {
	public query: ReturnType<typeof queryClient>;
	public tx: ReturnType<typeof txClient>;
	public structure: Record<string,unknown>;
	public registry: Array<[string, GeneratedType]> = [];

	constructor(client: IgniteClient) {		
	
		this.query = queryClient({ addr: client.env.apiURL });		
		this.updateTX(client);
		this.structure =  {
						Burn: getStructure(typeBurn.fromPartial({})),
						Mintperm: getStructure(typeMintperm.fromPartial({})),
						Options: getStructure(typeOptions.fromPartial({})),
						Params: getStructure(typeParams.fromPartial({})),
						Token: getStructure(typeToken.fromPartial({})),
						TokenBurn: getStructure(typeTokenBurn.fromPartial({})),
						
		};
		client.on('signer-changed',(signer) => {			
		 this.updateTX(client);
		})
	}
	updateTX(client: IgniteClient) {
    const methods = txClient({
        signer: client.signer,
        addr: client.env.rpcURL,
        prefix: client.env.prefix ?? "cosmos",
    })
	
    this.tx = methods;
    for (let m in methods) {
        this.tx[m] = methods[m].bind(this.tx);
    }
	}
};

const IgntModule = (test: IgniteClient) => {
	return {
		module: {
			SixprotocolTokenmngr: new SDKModule(test)
		},
		registry: msgTypes
  }
}
export default IgntModule;