// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.6.1
//   protoc               unknown
// source: sixprotocol/nftoracle/tx.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { Params } from "./params";

export const protobufPackage = "sixprotocol.nftoracle";

/** MsgUpdateParams is the Msg/UpdateParams request type. */
export interface MsgUpdateParams {
  /**
   * authority is the address that controls the module (defaults to x/gov unless
   * overwritten).
   */
  authority: string;
  /**
   * params defines the module parameters to update.
   *
   * NOTE: All parameters must be supplied.
   */
  params: Params | undefined;
}

/**
 * MsgUpdateParamsResponse defines the response structure for executing a
 * MsgUpdateParams message.
 */
export interface MsgUpdateParamsResponse {
}

export interface MsgCreateMintRequest {
  creator: string;
  nftSchemaCode: string;
  tokenId: string;
  requiredConfirm: number;
}

export interface MsgCreateMintRequestResponse {
  id: number;
  nftSchemaCode: string;
  tokenId: string;
}

export interface MsgSubmitMintResponse {
  creator: string;
  mintRequestID: number;
  base64NftData: string;
}

export interface MsgSubmitMintResponseResponse {
  mintRequestID: string;
}

export interface MsgCreateActionRequest {
  creator: string;
  vm: string;
  base64ActionSignature: string;
  requiredConfirm: number;
}

export interface MsgCreateActionRequestResponse {
  id: number;
}

export interface MsgSubmitActionResponse {
  creator: string;
  actionRequestID: number;
  base64NftData: string;
}

export interface MsgSubmitActionResponseResponse {
  actionRequestID: string;
}

export interface MsgCreateVerifyCollectionOwnerRequest {
  creator: string;
  nftSchemaCode: string;
  base64VerifyRequestorSignature: string;
  requiredConfirm: number;
}

export interface MsgCreateVerifyCollectionOwnerRequestResponse {
  id: number;
  nftSchemaCode: string;
  ownerAddress: string;
}

export interface MsgSubmitVerifyCollectionOwner {
  creator: string;
  verifyRequestID: number;
  nftSchemaCode: string;
  base64OriginContractInfo: string;
}

export interface MsgSubmitVerifyCollectionOwnerResponse {
  verifyRequestID: number;
}

export interface MsgSetMinimumConfirmation {
  creator: string;
  newConfirmation: string;
}

export interface MsgSetMinimumConfirmationResponse {
  newConfirmation: string;
}

export interface MsgCreateActionSigner {
  creator: string;
  base64EncodedSetSignerAction: string;
}

export interface MsgCreateActionSignerResponse {
  ownerAddress: string;
  signerAddress: string;
  expireAt: string;
}

export interface MsgUpdateActionSigner {
  creator: string;
  base64EncodedSetSignerAction: string;
}

export interface MsgUpdateActionSignerResponse {
  ownerAddress: string;
  signerAddress: string;
  expireAt: string;
}

export interface MsgDeleteActionSigner {
  creator: string;
  base64EncodedSetSignerAction: string;
}

export interface MsgDeleteActionSignerResponse {
  ownerAddress: string;
  signerAddress: string;
}

export interface MsgCreateActionSignerConfig {
  creator: string;
  chain: string;
  rpcEndpoint: string;
  contractAddress: string;
  contractName: string;
  contractOwner: string;
}

export interface MsgCreateActionSignerConfigResponse {
  chain: string;
  rpcEndpoint: string;
  contractAddress: string;
  contractName: string;
  contractOwner: string;
}

export interface MsgUpdateActionSignerConfig {
  creator: string;
  chain: string;
  rpcEndpoint: string;
  contractAddress: string;
  contractName: string;
  contractOwner: string;
}

export interface MsgUpdateActionSignerConfigResponse {
  chain: string;
  rpcEndpoint: string;
  newRpcEndpoint: string;
  contractAddress: string;
  newContractAddress: string;
  contractName: string;
  newContractName: string;
  contractOwner: string;
  newContractOwner: string;
}

export interface MsgDeleteActionSignerConfig {
  creator: string;
  chain: string;
}

export interface MsgDeleteActionSignerConfigResponse {
  chain: string;
}

export interface MsgCreateSyncActionSigner {
  creator: string;
  chain: string;
  actorAddress: string;
  ownerAddress: string;
  requiredConfirm: number;
}

export interface MsgCreateSyncActionSignerResponse {
  id: number;
  chain: string;
  ownerAddress: string;
  actorAddress: string;
}

export interface MsgSubmitSyncActionSigner {
  creator: string;
  syncId: number;
  chain: string;
  actorAddress: string;
  ownerAddress: string;
  /**
   * usign epoch because the data will came from smart contract
   * and it is easier to make communication between smart contract and cosmos
   */
  expireEpoch: string;
}

export interface MsgSubmitSyncActionSignerResponse {
  verifyRequestID: number;
  expireAt: string;
}

function createBaseMsgUpdateParams(): MsgUpdateParams {
  return { authority: "", params: undefined };
}

export const MsgUpdateParams: MessageFns<MsgUpdateParams> = {
  encode(message: MsgUpdateParams, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.authority !== "") {
      writer.uint32(10).string(message.authority);
    }
    if (message.params !== undefined) {
      Params.encode(message.params, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgUpdateParams {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgUpdateParams();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.authority = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.params = Params.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgUpdateParams {
    return {
      authority: isSet(object.authority) ? globalThis.String(object.authority) : "",
      params: isSet(object.params) ? Params.fromJSON(object.params) : undefined,
    };
  },

  toJSON(message: MsgUpdateParams): unknown {
    const obj: any = {};
    if (message.authority !== "") {
      obj.authority = message.authority;
    }
    if (message.params !== undefined) {
      obj.params = Params.toJSON(message.params);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgUpdateParams>, I>>(base?: I): MsgUpdateParams {
    return MsgUpdateParams.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgUpdateParams>, I>>(object: I): MsgUpdateParams {
    const message = createBaseMsgUpdateParams();
    message.authority = object.authority ?? "";
    message.params = (object.params !== undefined && object.params !== null)
      ? Params.fromPartial(object.params)
      : undefined;
    return message;
  },
};

function createBaseMsgUpdateParamsResponse(): MsgUpdateParamsResponse {
  return {};
}

export const MsgUpdateParamsResponse: MessageFns<MsgUpdateParamsResponse> = {
  encode(_: MsgUpdateParamsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgUpdateParamsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgUpdateParamsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgUpdateParamsResponse {
    return {};
  },

  toJSON(_: MsgUpdateParamsResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgUpdateParamsResponse>, I>>(base?: I): MsgUpdateParamsResponse {
    return MsgUpdateParamsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgUpdateParamsResponse>, I>>(_: I): MsgUpdateParamsResponse {
    const message = createBaseMsgUpdateParamsResponse();
    return message;
  },
};

function createBaseMsgCreateMintRequest(): MsgCreateMintRequest {
  return { creator: "", nftSchemaCode: "", tokenId: "", requiredConfirm: 0 };
}

export const MsgCreateMintRequest: MessageFns<MsgCreateMintRequest> = {
  encode(message: MsgCreateMintRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.creator !== "") {
      writer.uint32(10).string(message.creator);
    }
    if (message.nftSchemaCode !== "") {
      writer.uint32(18).string(message.nftSchemaCode);
    }
    if (message.tokenId !== "") {
      writer.uint32(26).string(message.tokenId);
    }
    if (message.requiredConfirm !== 0) {
      writer.uint32(32).uint64(message.requiredConfirm);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgCreateMintRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgCreateMintRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.creator = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.nftSchemaCode = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.tokenId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.requiredConfirm = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgCreateMintRequest {
    return {
      creator: isSet(object.creator) ? globalThis.String(object.creator) : "",
      nftSchemaCode: isSet(object.nftSchemaCode) ? globalThis.String(object.nftSchemaCode) : "",
      tokenId: isSet(object.tokenId) ? globalThis.String(object.tokenId) : "",
      requiredConfirm: isSet(object.requiredConfirm) ? globalThis.Number(object.requiredConfirm) : 0,
    };
  },

  toJSON(message: MsgCreateMintRequest): unknown {
    const obj: any = {};
    if (message.creator !== "") {
      obj.creator = message.creator;
    }
    if (message.nftSchemaCode !== "") {
      obj.nftSchemaCode = message.nftSchemaCode;
    }
    if (message.tokenId !== "") {
      obj.tokenId = message.tokenId;
    }
    if (message.requiredConfirm !== 0) {
      obj.requiredConfirm = Math.round(message.requiredConfirm);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgCreateMintRequest>, I>>(base?: I): MsgCreateMintRequest {
    return MsgCreateMintRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgCreateMintRequest>, I>>(object: I): MsgCreateMintRequest {
    const message = createBaseMsgCreateMintRequest();
    message.creator = object.creator ?? "";
    message.nftSchemaCode = object.nftSchemaCode ?? "";
    message.tokenId = object.tokenId ?? "";
    message.requiredConfirm = object.requiredConfirm ?? 0;
    return message;
  },
};

function createBaseMsgCreateMintRequestResponse(): MsgCreateMintRequestResponse {
  return { id: 0, nftSchemaCode: "", tokenId: "" };
}

export const MsgCreateMintRequestResponse: MessageFns<MsgCreateMintRequestResponse> = {
  encode(message: MsgCreateMintRequestResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== 0) {
      writer.uint32(8).uint64(message.id);
    }
    if (message.nftSchemaCode !== "") {
      writer.uint32(18).string(message.nftSchemaCode);
    }
    if (message.tokenId !== "") {
      writer.uint32(26).string(message.tokenId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgCreateMintRequestResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgCreateMintRequestResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = longToNumber(reader.uint64());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.nftSchemaCode = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.tokenId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgCreateMintRequestResponse {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      nftSchemaCode: isSet(object.nftSchemaCode) ? globalThis.String(object.nftSchemaCode) : "",
      tokenId: isSet(object.tokenId) ? globalThis.String(object.tokenId) : "",
    };
  },

  toJSON(message: MsgCreateMintRequestResponse): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.nftSchemaCode !== "") {
      obj.nftSchemaCode = message.nftSchemaCode;
    }
    if (message.tokenId !== "") {
      obj.tokenId = message.tokenId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgCreateMintRequestResponse>, I>>(base?: I): MsgCreateMintRequestResponse {
    return MsgCreateMintRequestResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgCreateMintRequestResponse>, I>>(object: I): MsgCreateMintRequestResponse {
    const message = createBaseMsgCreateMintRequestResponse();
    message.id = object.id ?? 0;
    message.nftSchemaCode = object.nftSchemaCode ?? "";
    message.tokenId = object.tokenId ?? "";
    return message;
  },
};

function createBaseMsgSubmitMintResponse(): MsgSubmitMintResponse {
  return { creator: "", mintRequestID: 0, base64NftData: "" };
}

export const MsgSubmitMintResponse: MessageFns<MsgSubmitMintResponse> = {
  encode(message: MsgSubmitMintResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.creator !== "") {
      writer.uint32(10).string(message.creator);
    }
    if (message.mintRequestID !== 0) {
      writer.uint32(16).uint64(message.mintRequestID);
    }
    if (message.base64NftData !== "") {
      writer.uint32(26).string(message.base64NftData);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgSubmitMintResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgSubmitMintResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.creator = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.mintRequestID = longToNumber(reader.uint64());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.base64NftData = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgSubmitMintResponse {
    return {
      creator: isSet(object.creator) ? globalThis.String(object.creator) : "",
      mintRequestID: isSet(object.mintRequestID) ? globalThis.Number(object.mintRequestID) : 0,
      base64NftData: isSet(object.base64NftData) ? globalThis.String(object.base64NftData) : "",
    };
  },

  toJSON(message: MsgSubmitMintResponse): unknown {
    const obj: any = {};
    if (message.creator !== "") {
      obj.creator = message.creator;
    }
    if (message.mintRequestID !== 0) {
      obj.mintRequestID = Math.round(message.mintRequestID);
    }
    if (message.base64NftData !== "") {
      obj.base64NftData = message.base64NftData;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgSubmitMintResponse>, I>>(base?: I): MsgSubmitMintResponse {
    return MsgSubmitMintResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgSubmitMintResponse>, I>>(object: I): MsgSubmitMintResponse {
    const message = createBaseMsgSubmitMintResponse();
    message.creator = object.creator ?? "";
    message.mintRequestID = object.mintRequestID ?? 0;
    message.base64NftData = object.base64NftData ?? "";
    return message;
  },
};

function createBaseMsgSubmitMintResponseResponse(): MsgSubmitMintResponseResponse {
  return { mintRequestID: "" };
}

export const MsgSubmitMintResponseResponse: MessageFns<MsgSubmitMintResponseResponse> = {
  encode(message: MsgSubmitMintResponseResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.mintRequestID !== "") {
      writer.uint32(10).string(message.mintRequestID);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgSubmitMintResponseResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgSubmitMintResponseResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.mintRequestID = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgSubmitMintResponseResponse {
    return { mintRequestID: isSet(object.mintRequestID) ? globalThis.String(object.mintRequestID) : "" };
  },

  toJSON(message: MsgSubmitMintResponseResponse): unknown {
    const obj: any = {};
    if (message.mintRequestID !== "") {
      obj.mintRequestID = message.mintRequestID;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgSubmitMintResponseResponse>, I>>(base?: I): MsgSubmitMintResponseResponse {
    return MsgSubmitMintResponseResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgSubmitMintResponseResponse>, I>>(
    object: I,
  ): MsgSubmitMintResponseResponse {
    const message = createBaseMsgSubmitMintResponseResponse();
    message.mintRequestID = object.mintRequestID ?? "";
    return message;
  },
};

function createBaseMsgCreateActionRequest(): MsgCreateActionRequest {
  return { creator: "", vm: "", base64ActionSignature: "", requiredConfirm: 0 };
}

export const MsgCreateActionRequest: MessageFns<MsgCreateActionRequest> = {
  encode(message: MsgCreateActionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.creator !== "") {
      writer.uint32(10).string(message.creator);
    }
    if (message.vm !== "") {
      writer.uint32(18).string(message.vm);
    }
    if (message.base64ActionSignature !== "") {
      writer.uint32(26).string(message.base64ActionSignature);
    }
    if (message.requiredConfirm !== 0) {
      writer.uint32(32).uint64(message.requiredConfirm);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgCreateActionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgCreateActionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.creator = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.vm = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.base64ActionSignature = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.requiredConfirm = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgCreateActionRequest {
    return {
      creator: isSet(object.creator) ? globalThis.String(object.creator) : "",
      vm: isSet(object.vm) ? globalThis.String(object.vm) : "",
      base64ActionSignature: isSet(object.base64ActionSignature) ? globalThis.String(object.base64ActionSignature) : "",
      requiredConfirm: isSet(object.requiredConfirm) ? globalThis.Number(object.requiredConfirm) : 0,
    };
  },

  toJSON(message: MsgCreateActionRequest): unknown {
    const obj: any = {};
    if (message.creator !== "") {
      obj.creator = message.creator;
    }
    if (message.vm !== "") {
      obj.vm = message.vm;
    }
    if (message.base64ActionSignature !== "") {
      obj.base64ActionSignature = message.base64ActionSignature;
    }
    if (message.requiredConfirm !== 0) {
      obj.requiredConfirm = Math.round(message.requiredConfirm);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgCreateActionRequest>, I>>(base?: I): MsgCreateActionRequest {
    return MsgCreateActionRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgCreateActionRequest>, I>>(object: I): MsgCreateActionRequest {
    const message = createBaseMsgCreateActionRequest();
    message.creator = object.creator ?? "";
    message.vm = object.vm ?? "";
    message.base64ActionSignature = object.base64ActionSignature ?? "";
    message.requiredConfirm = object.requiredConfirm ?? 0;
    return message;
  },
};

function createBaseMsgCreateActionRequestResponse(): MsgCreateActionRequestResponse {
  return { id: 0 };
}

export const MsgCreateActionRequestResponse: MessageFns<MsgCreateActionRequestResponse> = {
  encode(message: MsgCreateActionRequestResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== 0) {
      writer.uint32(8).uint64(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgCreateActionRequestResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgCreateActionRequestResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgCreateActionRequestResponse {
    return { id: isSet(object.id) ? globalThis.Number(object.id) : 0 };
  },

  toJSON(message: MsgCreateActionRequestResponse): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgCreateActionRequestResponse>, I>>(base?: I): MsgCreateActionRequestResponse {
    return MsgCreateActionRequestResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgCreateActionRequestResponse>, I>>(
    object: I,
  ): MsgCreateActionRequestResponse {
    const message = createBaseMsgCreateActionRequestResponse();
    message.id = object.id ?? 0;
    return message;
  },
};

function createBaseMsgSubmitActionResponse(): MsgSubmitActionResponse {
  return { creator: "", actionRequestID: 0, base64NftData: "" };
}

export const MsgSubmitActionResponse: MessageFns<MsgSubmitActionResponse> = {
  encode(message: MsgSubmitActionResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.creator !== "") {
      writer.uint32(10).string(message.creator);
    }
    if (message.actionRequestID !== 0) {
      writer.uint32(16).uint64(message.actionRequestID);
    }
    if (message.base64NftData !== "") {
      writer.uint32(26).string(message.base64NftData);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgSubmitActionResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgSubmitActionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.creator = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.actionRequestID = longToNumber(reader.uint64());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.base64NftData = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgSubmitActionResponse {
    return {
      creator: isSet(object.creator) ? globalThis.String(object.creator) : "",
      actionRequestID: isSet(object.actionRequestID) ? globalThis.Number(object.actionRequestID) : 0,
      base64NftData: isSet(object.base64NftData) ? globalThis.String(object.base64NftData) : "",
    };
  },

  toJSON(message: MsgSubmitActionResponse): unknown {
    const obj: any = {};
    if (message.creator !== "") {
      obj.creator = message.creator;
    }
    if (message.actionRequestID !== 0) {
      obj.actionRequestID = Math.round(message.actionRequestID);
    }
    if (message.base64NftData !== "") {
      obj.base64NftData = message.base64NftData;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgSubmitActionResponse>, I>>(base?: I): MsgSubmitActionResponse {
    return MsgSubmitActionResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgSubmitActionResponse>, I>>(object: I): MsgSubmitActionResponse {
    const message = createBaseMsgSubmitActionResponse();
    message.creator = object.creator ?? "";
    message.actionRequestID = object.actionRequestID ?? 0;
    message.base64NftData = object.base64NftData ?? "";
    return message;
  },
};

function createBaseMsgSubmitActionResponseResponse(): MsgSubmitActionResponseResponse {
  return { actionRequestID: "" };
}

export const MsgSubmitActionResponseResponse: MessageFns<MsgSubmitActionResponseResponse> = {
  encode(message: MsgSubmitActionResponseResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.actionRequestID !== "") {
      writer.uint32(10).string(message.actionRequestID);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgSubmitActionResponseResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgSubmitActionResponseResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.actionRequestID = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgSubmitActionResponseResponse {
    return { actionRequestID: isSet(object.actionRequestID) ? globalThis.String(object.actionRequestID) : "" };
  },

  toJSON(message: MsgSubmitActionResponseResponse): unknown {
    const obj: any = {};
    if (message.actionRequestID !== "") {
      obj.actionRequestID = message.actionRequestID;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgSubmitActionResponseResponse>, I>>(base?: I): MsgSubmitActionResponseResponse {
    return MsgSubmitActionResponseResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgSubmitActionResponseResponse>, I>>(
    object: I,
  ): MsgSubmitActionResponseResponse {
    const message = createBaseMsgSubmitActionResponseResponse();
    message.actionRequestID = object.actionRequestID ?? "";
    return message;
  },
};

function createBaseMsgCreateVerifyCollectionOwnerRequest(): MsgCreateVerifyCollectionOwnerRequest {
  return { creator: "", nftSchemaCode: "", base64VerifyRequestorSignature: "", requiredConfirm: 0 };
}

export const MsgCreateVerifyCollectionOwnerRequest: MessageFns<MsgCreateVerifyCollectionOwnerRequest> = {
  encode(message: MsgCreateVerifyCollectionOwnerRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.creator !== "") {
      writer.uint32(10).string(message.creator);
    }
    if (message.nftSchemaCode !== "") {
      writer.uint32(18).string(message.nftSchemaCode);
    }
    if (message.base64VerifyRequestorSignature !== "") {
      writer.uint32(26).string(message.base64VerifyRequestorSignature);
    }
    if (message.requiredConfirm !== 0) {
      writer.uint32(32).uint64(message.requiredConfirm);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgCreateVerifyCollectionOwnerRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgCreateVerifyCollectionOwnerRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.creator = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.nftSchemaCode = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.base64VerifyRequestorSignature = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.requiredConfirm = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgCreateVerifyCollectionOwnerRequest {
    return {
      creator: isSet(object.creator) ? globalThis.String(object.creator) : "",
      nftSchemaCode: isSet(object.nftSchemaCode) ? globalThis.String(object.nftSchemaCode) : "",
      base64VerifyRequestorSignature: isSet(object.base64VerifyRequestorSignature)
        ? globalThis.String(object.base64VerifyRequestorSignature)
        : "",
      requiredConfirm: isSet(object.requiredConfirm) ? globalThis.Number(object.requiredConfirm) : 0,
    };
  },

  toJSON(message: MsgCreateVerifyCollectionOwnerRequest): unknown {
    const obj: any = {};
    if (message.creator !== "") {
      obj.creator = message.creator;
    }
    if (message.nftSchemaCode !== "") {
      obj.nftSchemaCode = message.nftSchemaCode;
    }
    if (message.base64VerifyRequestorSignature !== "") {
      obj.base64VerifyRequestorSignature = message.base64VerifyRequestorSignature;
    }
    if (message.requiredConfirm !== 0) {
      obj.requiredConfirm = Math.round(message.requiredConfirm);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgCreateVerifyCollectionOwnerRequest>, I>>(
    base?: I,
  ): MsgCreateVerifyCollectionOwnerRequest {
    return MsgCreateVerifyCollectionOwnerRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgCreateVerifyCollectionOwnerRequest>, I>>(
    object: I,
  ): MsgCreateVerifyCollectionOwnerRequest {
    const message = createBaseMsgCreateVerifyCollectionOwnerRequest();
    message.creator = object.creator ?? "";
    message.nftSchemaCode = object.nftSchemaCode ?? "";
    message.base64VerifyRequestorSignature = object.base64VerifyRequestorSignature ?? "";
    message.requiredConfirm = object.requiredConfirm ?? 0;
    return message;
  },
};

function createBaseMsgCreateVerifyCollectionOwnerRequestResponse(): MsgCreateVerifyCollectionOwnerRequestResponse {
  return { id: 0, nftSchemaCode: "", ownerAddress: "" };
}

export const MsgCreateVerifyCollectionOwnerRequestResponse: MessageFns<MsgCreateVerifyCollectionOwnerRequestResponse> =
  {
    encode(
      message: MsgCreateVerifyCollectionOwnerRequestResponse,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      if (message.id !== 0) {
        writer.uint32(8).uint64(message.id);
      }
      if (message.nftSchemaCode !== "") {
        writer.uint32(18).string(message.nftSchemaCode);
      }
      if (message.ownerAddress !== "") {
        writer.uint32(26).string(message.ownerAddress);
      }
      return writer;
    },

    decode(input: BinaryReader | Uint8Array, length?: number): MsgCreateVerifyCollectionOwnerRequestResponse {
      const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseMsgCreateVerifyCollectionOwnerRequestResponse();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 8) {
              break;
            }

            message.id = longToNumber(reader.uint64());
            continue;
          }
          case 2: {
            if (tag !== 18) {
              break;
            }

            message.nftSchemaCode = reader.string();
            continue;
          }
          case 3: {
            if (tag !== 26) {
              break;
            }

            message.ownerAddress = reader.string();
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): MsgCreateVerifyCollectionOwnerRequestResponse {
      return {
        id: isSet(object.id) ? globalThis.Number(object.id) : 0,
        nftSchemaCode: isSet(object.nftSchemaCode) ? globalThis.String(object.nftSchemaCode) : "",
        ownerAddress: isSet(object.ownerAddress) ? globalThis.String(object.ownerAddress) : "",
      };
    },

    toJSON(message: MsgCreateVerifyCollectionOwnerRequestResponse): unknown {
      const obj: any = {};
      if (message.id !== 0) {
        obj.id = Math.round(message.id);
      }
      if (message.nftSchemaCode !== "") {
        obj.nftSchemaCode = message.nftSchemaCode;
      }
      if (message.ownerAddress !== "") {
        obj.ownerAddress = message.ownerAddress;
      }
      return obj;
    },

    create<I extends Exact<DeepPartial<MsgCreateVerifyCollectionOwnerRequestResponse>, I>>(
      base?: I,
    ): MsgCreateVerifyCollectionOwnerRequestResponse {
      return MsgCreateVerifyCollectionOwnerRequestResponse.fromPartial(base ?? ({} as any));
    },
    fromPartial<I extends Exact<DeepPartial<MsgCreateVerifyCollectionOwnerRequestResponse>, I>>(
      object: I,
    ): MsgCreateVerifyCollectionOwnerRequestResponse {
      const message = createBaseMsgCreateVerifyCollectionOwnerRequestResponse();
      message.id = object.id ?? 0;
      message.nftSchemaCode = object.nftSchemaCode ?? "";
      message.ownerAddress = object.ownerAddress ?? "";
      return message;
    },
  };

function createBaseMsgSubmitVerifyCollectionOwner(): MsgSubmitVerifyCollectionOwner {
  return { creator: "", verifyRequestID: 0, nftSchemaCode: "", base64OriginContractInfo: "" };
}

export const MsgSubmitVerifyCollectionOwner: MessageFns<MsgSubmitVerifyCollectionOwner> = {
  encode(message: MsgSubmitVerifyCollectionOwner, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.creator !== "") {
      writer.uint32(10).string(message.creator);
    }
    if (message.verifyRequestID !== 0) {
      writer.uint32(16).uint64(message.verifyRequestID);
    }
    if (message.nftSchemaCode !== "") {
      writer.uint32(26).string(message.nftSchemaCode);
    }
    if (message.base64OriginContractInfo !== "") {
      writer.uint32(34).string(message.base64OriginContractInfo);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgSubmitVerifyCollectionOwner {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgSubmitVerifyCollectionOwner();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.creator = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.verifyRequestID = longToNumber(reader.uint64());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.nftSchemaCode = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.base64OriginContractInfo = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgSubmitVerifyCollectionOwner {
    return {
      creator: isSet(object.creator) ? globalThis.String(object.creator) : "",
      verifyRequestID: isSet(object.verifyRequestID) ? globalThis.Number(object.verifyRequestID) : 0,
      nftSchemaCode: isSet(object.nftSchemaCode) ? globalThis.String(object.nftSchemaCode) : "",
      base64OriginContractInfo: isSet(object.base64OriginContractInfo)
        ? globalThis.String(object.base64OriginContractInfo)
        : "",
    };
  },

  toJSON(message: MsgSubmitVerifyCollectionOwner): unknown {
    const obj: any = {};
    if (message.creator !== "") {
      obj.creator = message.creator;
    }
    if (message.verifyRequestID !== 0) {
      obj.verifyRequestID = Math.round(message.verifyRequestID);
    }
    if (message.nftSchemaCode !== "") {
      obj.nftSchemaCode = message.nftSchemaCode;
    }
    if (message.base64OriginContractInfo !== "") {
      obj.base64OriginContractInfo = message.base64OriginContractInfo;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgSubmitVerifyCollectionOwner>, I>>(base?: I): MsgSubmitVerifyCollectionOwner {
    return MsgSubmitVerifyCollectionOwner.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgSubmitVerifyCollectionOwner>, I>>(
    object: I,
  ): MsgSubmitVerifyCollectionOwner {
    const message = createBaseMsgSubmitVerifyCollectionOwner();
    message.creator = object.creator ?? "";
    message.verifyRequestID = object.verifyRequestID ?? 0;
    message.nftSchemaCode = object.nftSchemaCode ?? "";
    message.base64OriginContractInfo = object.base64OriginContractInfo ?? "";
    return message;
  },
};

function createBaseMsgSubmitVerifyCollectionOwnerResponse(): MsgSubmitVerifyCollectionOwnerResponse {
  return { verifyRequestID: 0 };
}

export const MsgSubmitVerifyCollectionOwnerResponse: MessageFns<MsgSubmitVerifyCollectionOwnerResponse> = {
  encode(message: MsgSubmitVerifyCollectionOwnerResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.verifyRequestID !== 0) {
      writer.uint32(8).uint64(message.verifyRequestID);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgSubmitVerifyCollectionOwnerResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgSubmitVerifyCollectionOwnerResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.verifyRequestID = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgSubmitVerifyCollectionOwnerResponse {
    return { verifyRequestID: isSet(object.verifyRequestID) ? globalThis.Number(object.verifyRequestID) : 0 };
  },

  toJSON(message: MsgSubmitVerifyCollectionOwnerResponse): unknown {
    const obj: any = {};
    if (message.verifyRequestID !== 0) {
      obj.verifyRequestID = Math.round(message.verifyRequestID);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgSubmitVerifyCollectionOwnerResponse>, I>>(
    base?: I,
  ): MsgSubmitVerifyCollectionOwnerResponse {
    return MsgSubmitVerifyCollectionOwnerResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgSubmitVerifyCollectionOwnerResponse>, I>>(
    object: I,
  ): MsgSubmitVerifyCollectionOwnerResponse {
    const message = createBaseMsgSubmitVerifyCollectionOwnerResponse();
    message.verifyRequestID = object.verifyRequestID ?? 0;
    return message;
  },
};

function createBaseMsgSetMinimumConfirmation(): MsgSetMinimumConfirmation {
  return { creator: "", newConfirmation: "" };
}

export const MsgSetMinimumConfirmation: MessageFns<MsgSetMinimumConfirmation> = {
  encode(message: MsgSetMinimumConfirmation, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.creator !== "") {
      writer.uint32(10).string(message.creator);
    }
    if (message.newConfirmation !== "") {
      writer.uint32(18).string(message.newConfirmation);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgSetMinimumConfirmation {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgSetMinimumConfirmation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.creator = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.newConfirmation = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgSetMinimumConfirmation {
    return {
      creator: isSet(object.creator) ? globalThis.String(object.creator) : "",
      newConfirmation: isSet(object.newConfirmation) ? globalThis.String(object.newConfirmation) : "",
    };
  },

  toJSON(message: MsgSetMinimumConfirmation): unknown {
    const obj: any = {};
    if (message.creator !== "") {
      obj.creator = message.creator;
    }
    if (message.newConfirmation !== "") {
      obj.newConfirmation = message.newConfirmation;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgSetMinimumConfirmation>, I>>(base?: I): MsgSetMinimumConfirmation {
    return MsgSetMinimumConfirmation.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgSetMinimumConfirmation>, I>>(object: I): MsgSetMinimumConfirmation {
    const message = createBaseMsgSetMinimumConfirmation();
    message.creator = object.creator ?? "";
    message.newConfirmation = object.newConfirmation ?? "";
    return message;
  },
};

function createBaseMsgSetMinimumConfirmationResponse(): MsgSetMinimumConfirmationResponse {
  return { newConfirmation: "" };
}

export const MsgSetMinimumConfirmationResponse: MessageFns<MsgSetMinimumConfirmationResponse> = {
  encode(message: MsgSetMinimumConfirmationResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.newConfirmation !== "") {
      writer.uint32(10).string(message.newConfirmation);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgSetMinimumConfirmationResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgSetMinimumConfirmationResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.newConfirmation = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgSetMinimumConfirmationResponse {
    return { newConfirmation: isSet(object.newConfirmation) ? globalThis.String(object.newConfirmation) : "" };
  },

  toJSON(message: MsgSetMinimumConfirmationResponse): unknown {
    const obj: any = {};
    if (message.newConfirmation !== "") {
      obj.newConfirmation = message.newConfirmation;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgSetMinimumConfirmationResponse>, I>>(
    base?: I,
  ): MsgSetMinimumConfirmationResponse {
    return MsgSetMinimumConfirmationResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgSetMinimumConfirmationResponse>, I>>(
    object: I,
  ): MsgSetMinimumConfirmationResponse {
    const message = createBaseMsgSetMinimumConfirmationResponse();
    message.newConfirmation = object.newConfirmation ?? "";
    return message;
  },
};

function createBaseMsgCreateActionSigner(): MsgCreateActionSigner {
  return { creator: "", base64EncodedSetSignerAction: "" };
}

export const MsgCreateActionSigner: MessageFns<MsgCreateActionSigner> = {
  encode(message: MsgCreateActionSigner, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.creator !== "") {
      writer.uint32(10).string(message.creator);
    }
    if (message.base64EncodedSetSignerAction !== "") {
      writer.uint32(18).string(message.base64EncodedSetSignerAction);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgCreateActionSigner {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgCreateActionSigner();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.creator = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.base64EncodedSetSignerAction = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgCreateActionSigner {
    return {
      creator: isSet(object.creator) ? globalThis.String(object.creator) : "",
      base64EncodedSetSignerAction: isSet(object.base64EncodedSetSignerAction)
        ? globalThis.String(object.base64EncodedSetSignerAction)
        : "",
    };
  },

  toJSON(message: MsgCreateActionSigner): unknown {
    const obj: any = {};
    if (message.creator !== "") {
      obj.creator = message.creator;
    }
    if (message.base64EncodedSetSignerAction !== "") {
      obj.base64EncodedSetSignerAction = message.base64EncodedSetSignerAction;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgCreateActionSigner>, I>>(base?: I): MsgCreateActionSigner {
    return MsgCreateActionSigner.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgCreateActionSigner>, I>>(object: I): MsgCreateActionSigner {
    const message = createBaseMsgCreateActionSigner();
    message.creator = object.creator ?? "";
    message.base64EncodedSetSignerAction = object.base64EncodedSetSignerAction ?? "";
    return message;
  },
};

function createBaseMsgCreateActionSignerResponse(): MsgCreateActionSignerResponse {
  return { ownerAddress: "", signerAddress: "", expireAt: "" };
}

export const MsgCreateActionSignerResponse: MessageFns<MsgCreateActionSignerResponse> = {
  encode(message: MsgCreateActionSignerResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.ownerAddress !== "") {
      writer.uint32(10).string(message.ownerAddress);
    }
    if (message.signerAddress !== "") {
      writer.uint32(18).string(message.signerAddress);
    }
    if (message.expireAt !== "") {
      writer.uint32(26).string(message.expireAt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgCreateActionSignerResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgCreateActionSignerResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.ownerAddress = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.signerAddress = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.expireAt = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgCreateActionSignerResponse {
    return {
      ownerAddress: isSet(object.ownerAddress) ? globalThis.String(object.ownerAddress) : "",
      signerAddress: isSet(object.signerAddress) ? globalThis.String(object.signerAddress) : "",
      expireAt: isSet(object.expireAt) ? globalThis.String(object.expireAt) : "",
    };
  },

  toJSON(message: MsgCreateActionSignerResponse): unknown {
    const obj: any = {};
    if (message.ownerAddress !== "") {
      obj.ownerAddress = message.ownerAddress;
    }
    if (message.signerAddress !== "") {
      obj.signerAddress = message.signerAddress;
    }
    if (message.expireAt !== "") {
      obj.expireAt = message.expireAt;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgCreateActionSignerResponse>, I>>(base?: I): MsgCreateActionSignerResponse {
    return MsgCreateActionSignerResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgCreateActionSignerResponse>, I>>(
    object: I,
  ): MsgCreateActionSignerResponse {
    const message = createBaseMsgCreateActionSignerResponse();
    message.ownerAddress = object.ownerAddress ?? "";
    message.signerAddress = object.signerAddress ?? "";
    message.expireAt = object.expireAt ?? "";
    return message;
  },
};

function createBaseMsgUpdateActionSigner(): MsgUpdateActionSigner {
  return { creator: "", base64EncodedSetSignerAction: "" };
}

export const MsgUpdateActionSigner: MessageFns<MsgUpdateActionSigner> = {
  encode(message: MsgUpdateActionSigner, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.creator !== "") {
      writer.uint32(10).string(message.creator);
    }
    if (message.base64EncodedSetSignerAction !== "") {
      writer.uint32(18).string(message.base64EncodedSetSignerAction);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgUpdateActionSigner {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgUpdateActionSigner();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.creator = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.base64EncodedSetSignerAction = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgUpdateActionSigner {
    return {
      creator: isSet(object.creator) ? globalThis.String(object.creator) : "",
      base64EncodedSetSignerAction: isSet(object.base64EncodedSetSignerAction)
        ? globalThis.String(object.base64EncodedSetSignerAction)
        : "",
    };
  },

  toJSON(message: MsgUpdateActionSigner): unknown {
    const obj: any = {};
    if (message.creator !== "") {
      obj.creator = message.creator;
    }
    if (message.base64EncodedSetSignerAction !== "") {
      obj.base64EncodedSetSignerAction = message.base64EncodedSetSignerAction;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgUpdateActionSigner>, I>>(base?: I): MsgUpdateActionSigner {
    return MsgUpdateActionSigner.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgUpdateActionSigner>, I>>(object: I): MsgUpdateActionSigner {
    const message = createBaseMsgUpdateActionSigner();
    message.creator = object.creator ?? "";
    message.base64EncodedSetSignerAction = object.base64EncodedSetSignerAction ?? "";
    return message;
  },
};

function createBaseMsgUpdateActionSignerResponse(): MsgUpdateActionSignerResponse {
  return { ownerAddress: "", signerAddress: "", expireAt: "" };
}

export const MsgUpdateActionSignerResponse: MessageFns<MsgUpdateActionSignerResponse> = {
  encode(message: MsgUpdateActionSignerResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.ownerAddress !== "") {
      writer.uint32(10).string(message.ownerAddress);
    }
    if (message.signerAddress !== "") {
      writer.uint32(18).string(message.signerAddress);
    }
    if (message.expireAt !== "") {
      writer.uint32(26).string(message.expireAt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgUpdateActionSignerResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgUpdateActionSignerResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.ownerAddress = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.signerAddress = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.expireAt = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgUpdateActionSignerResponse {
    return {
      ownerAddress: isSet(object.ownerAddress) ? globalThis.String(object.ownerAddress) : "",
      signerAddress: isSet(object.signerAddress) ? globalThis.String(object.signerAddress) : "",
      expireAt: isSet(object.expireAt) ? globalThis.String(object.expireAt) : "",
    };
  },

  toJSON(message: MsgUpdateActionSignerResponse): unknown {
    const obj: any = {};
    if (message.ownerAddress !== "") {
      obj.ownerAddress = message.ownerAddress;
    }
    if (message.signerAddress !== "") {
      obj.signerAddress = message.signerAddress;
    }
    if (message.expireAt !== "") {
      obj.expireAt = message.expireAt;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgUpdateActionSignerResponse>, I>>(base?: I): MsgUpdateActionSignerResponse {
    return MsgUpdateActionSignerResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgUpdateActionSignerResponse>, I>>(
    object: I,
  ): MsgUpdateActionSignerResponse {
    const message = createBaseMsgUpdateActionSignerResponse();
    message.ownerAddress = object.ownerAddress ?? "";
    message.signerAddress = object.signerAddress ?? "";
    message.expireAt = object.expireAt ?? "";
    return message;
  },
};

function createBaseMsgDeleteActionSigner(): MsgDeleteActionSigner {
  return { creator: "", base64EncodedSetSignerAction: "" };
}

export const MsgDeleteActionSigner: MessageFns<MsgDeleteActionSigner> = {
  encode(message: MsgDeleteActionSigner, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.creator !== "") {
      writer.uint32(10).string(message.creator);
    }
    if (message.base64EncodedSetSignerAction !== "") {
      writer.uint32(18).string(message.base64EncodedSetSignerAction);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgDeleteActionSigner {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgDeleteActionSigner();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.creator = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.base64EncodedSetSignerAction = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgDeleteActionSigner {
    return {
      creator: isSet(object.creator) ? globalThis.String(object.creator) : "",
      base64EncodedSetSignerAction: isSet(object.base64EncodedSetSignerAction)
        ? globalThis.String(object.base64EncodedSetSignerAction)
        : "",
    };
  },

  toJSON(message: MsgDeleteActionSigner): unknown {
    const obj: any = {};
    if (message.creator !== "") {
      obj.creator = message.creator;
    }
    if (message.base64EncodedSetSignerAction !== "") {
      obj.base64EncodedSetSignerAction = message.base64EncodedSetSignerAction;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgDeleteActionSigner>, I>>(base?: I): MsgDeleteActionSigner {
    return MsgDeleteActionSigner.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgDeleteActionSigner>, I>>(object: I): MsgDeleteActionSigner {
    const message = createBaseMsgDeleteActionSigner();
    message.creator = object.creator ?? "";
    message.base64EncodedSetSignerAction = object.base64EncodedSetSignerAction ?? "";
    return message;
  },
};

function createBaseMsgDeleteActionSignerResponse(): MsgDeleteActionSignerResponse {
  return { ownerAddress: "", signerAddress: "" };
}

export const MsgDeleteActionSignerResponse: MessageFns<MsgDeleteActionSignerResponse> = {
  encode(message: MsgDeleteActionSignerResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.ownerAddress !== "") {
      writer.uint32(10).string(message.ownerAddress);
    }
    if (message.signerAddress !== "") {
      writer.uint32(18).string(message.signerAddress);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgDeleteActionSignerResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgDeleteActionSignerResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.ownerAddress = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.signerAddress = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgDeleteActionSignerResponse {
    return {
      ownerAddress: isSet(object.ownerAddress) ? globalThis.String(object.ownerAddress) : "",
      signerAddress: isSet(object.signerAddress) ? globalThis.String(object.signerAddress) : "",
    };
  },

  toJSON(message: MsgDeleteActionSignerResponse): unknown {
    const obj: any = {};
    if (message.ownerAddress !== "") {
      obj.ownerAddress = message.ownerAddress;
    }
    if (message.signerAddress !== "") {
      obj.signerAddress = message.signerAddress;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgDeleteActionSignerResponse>, I>>(base?: I): MsgDeleteActionSignerResponse {
    return MsgDeleteActionSignerResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgDeleteActionSignerResponse>, I>>(
    object: I,
  ): MsgDeleteActionSignerResponse {
    const message = createBaseMsgDeleteActionSignerResponse();
    message.ownerAddress = object.ownerAddress ?? "";
    message.signerAddress = object.signerAddress ?? "";
    return message;
  },
};

function createBaseMsgCreateActionSignerConfig(): MsgCreateActionSignerConfig {
  return { creator: "", chain: "", rpcEndpoint: "", contractAddress: "", contractName: "", contractOwner: "" };
}

export const MsgCreateActionSignerConfig: MessageFns<MsgCreateActionSignerConfig> = {
  encode(message: MsgCreateActionSignerConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.creator !== "") {
      writer.uint32(10).string(message.creator);
    }
    if (message.chain !== "") {
      writer.uint32(18).string(message.chain);
    }
    if (message.rpcEndpoint !== "") {
      writer.uint32(26).string(message.rpcEndpoint);
    }
    if (message.contractAddress !== "") {
      writer.uint32(34).string(message.contractAddress);
    }
    if (message.contractName !== "") {
      writer.uint32(42).string(message.contractName);
    }
    if (message.contractOwner !== "") {
      writer.uint32(50).string(message.contractOwner);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgCreateActionSignerConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgCreateActionSignerConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.creator = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.chain = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.rpcEndpoint = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.contractAddress = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.contractName = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.contractOwner = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgCreateActionSignerConfig {
    return {
      creator: isSet(object.creator) ? globalThis.String(object.creator) : "",
      chain: isSet(object.chain) ? globalThis.String(object.chain) : "",
      rpcEndpoint: isSet(object.rpcEndpoint) ? globalThis.String(object.rpcEndpoint) : "",
      contractAddress: isSet(object.contractAddress) ? globalThis.String(object.contractAddress) : "",
      contractName: isSet(object.contractName) ? globalThis.String(object.contractName) : "",
      contractOwner: isSet(object.contractOwner) ? globalThis.String(object.contractOwner) : "",
    };
  },

  toJSON(message: MsgCreateActionSignerConfig): unknown {
    const obj: any = {};
    if (message.creator !== "") {
      obj.creator = message.creator;
    }
    if (message.chain !== "") {
      obj.chain = message.chain;
    }
    if (message.rpcEndpoint !== "") {
      obj.rpcEndpoint = message.rpcEndpoint;
    }
    if (message.contractAddress !== "") {
      obj.contractAddress = message.contractAddress;
    }
    if (message.contractName !== "") {
      obj.contractName = message.contractName;
    }
    if (message.contractOwner !== "") {
      obj.contractOwner = message.contractOwner;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgCreateActionSignerConfig>, I>>(base?: I): MsgCreateActionSignerConfig {
    return MsgCreateActionSignerConfig.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgCreateActionSignerConfig>, I>>(object: I): MsgCreateActionSignerConfig {
    const message = createBaseMsgCreateActionSignerConfig();
    message.creator = object.creator ?? "";
    message.chain = object.chain ?? "";
    message.rpcEndpoint = object.rpcEndpoint ?? "";
    message.contractAddress = object.contractAddress ?? "";
    message.contractName = object.contractName ?? "";
    message.contractOwner = object.contractOwner ?? "";
    return message;
  },
};

function createBaseMsgCreateActionSignerConfigResponse(): MsgCreateActionSignerConfigResponse {
  return { chain: "", rpcEndpoint: "", contractAddress: "", contractName: "", contractOwner: "" };
}

export const MsgCreateActionSignerConfigResponse: MessageFns<MsgCreateActionSignerConfigResponse> = {
  encode(message: MsgCreateActionSignerConfigResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.chain !== "") {
      writer.uint32(10).string(message.chain);
    }
    if (message.rpcEndpoint !== "") {
      writer.uint32(18).string(message.rpcEndpoint);
    }
    if (message.contractAddress !== "") {
      writer.uint32(26).string(message.contractAddress);
    }
    if (message.contractName !== "") {
      writer.uint32(34).string(message.contractName);
    }
    if (message.contractOwner !== "") {
      writer.uint32(42).string(message.contractOwner);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgCreateActionSignerConfigResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgCreateActionSignerConfigResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.chain = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.rpcEndpoint = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.contractAddress = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.contractName = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.contractOwner = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgCreateActionSignerConfigResponse {
    return {
      chain: isSet(object.chain) ? globalThis.String(object.chain) : "",
      rpcEndpoint: isSet(object.rpcEndpoint) ? globalThis.String(object.rpcEndpoint) : "",
      contractAddress: isSet(object.contractAddress) ? globalThis.String(object.contractAddress) : "",
      contractName: isSet(object.contractName) ? globalThis.String(object.contractName) : "",
      contractOwner: isSet(object.contractOwner) ? globalThis.String(object.contractOwner) : "",
    };
  },

  toJSON(message: MsgCreateActionSignerConfigResponse): unknown {
    const obj: any = {};
    if (message.chain !== "") {
      obj.chain = message.chain;
    }
    if (message.rpcEndpoint !== "") {
      obj.rpcEndpoint = message.rpcEndpoint;
    }
    if (message.contractAddress !== "") {
      obj.contractAddress = message.contractAddress;
    }
    if (message.contractName !== "") {
      obj.contractName = message.contractName;
    }
    if (message.contractOwner !== "") {
      obj.contractOwner = message.contractOwner;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgCreateActionSignerConfigResponse>, I>>(
    base?: I,
  ): MsgCreateActionSignerConfigResponse {
    return MsgCreateActionSignerConfigResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgCreateActionSignerConfigResponse>, I>>(
    object: I,
  ): MsgCreateActionSignerConfigResponse {
    const message = createBaseMsgCreateActionSignerConfigResponse();
    message.chain = object.chain ?? "";
    message.rpcEndpoint = object.rpcEndpoint ?? "";
    message.contractAddress = object.contractAddress ?? "";
    message.contractName = object.contractName ?? "";
    message.contractOwner = object.contractOwner ?? "";
    return message;
  },
};

function createBaseMsgUpdateActionSignerConfig(): MsgUpdateActionSignerConfig {
  return { creator: "", chain: "", rpcEndpoint: "", contractAddress: "", contractName: "", contractOwner: "" };
}

export const MsgUpdateActionSignerConfig: MessageFns<MsgUpdateActionSignerConfig> = {
  encode(message: MsgUpdateActionSignerConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.creator !== "") {
      writer.uint32(10).string(message.creator);
    }
    if (message.chain !== "") {
      writer.uint32(18).string(message.chain);
    }
    if (message.rpcEndpoint !== "") {
      writer.uint32(26).string(message.rpcEndpoint);
    }
    if (message.contractAddress !== "") {
      writer.uint32(34).string(message.contractAddress);
    }
    if (message.contractName !== "") {
      writer.uint32(42).string(message.contractName);
    }
    if (message.contractOwner !== "") {
      writer.uint32(50).string(message.contractOwner);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgUpdateActionSignerConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgUpdateActionSignerConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.creator = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.chain = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.rpcEndpoint = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.contractAddress = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.contractName = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.contractOwner = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgUpdateActionSignerConfig {
    return {
      creator: isSet(object.creator) ? globalThis.String(object.creator) : "",
      chain: isSet(object.chain) ? globalThis.String(object.chain) : "",
      rpcEndpoint: isSet(object.rpcEndpoint) ? globalThis.String(object.rpcEndpoint) : "",
      contractAddress: isSet(object.contractAddress) ? globalThis.String(object.contractAddress) : "",
      contractName: isSet(object.contractName) ? globalThis.String(object.contractName) : "",
      contractOwner: isSet(object.contractOwner) ? globalThis.String(object.contractOwner) : "",
    };
  },

  toJSON(message: MsgUpdateActionSignerConfig): unknown {
    const obj: any = {};
    if (message.creator !== "") {
      obj.creator = message.creator;
    }
    if (message.chain !== "") {
      obj.chain = message.chain;
    }
    if (message.rpcEndpoint !== "") {
      obj.rpcEndpoint = message.rpcEndpoint;
    }
    if (message.contractAddress !== "") {
      obj.contractAddress = message.contractAddress;
    }
    if (message.contractName !== "") {
      obj.contractName = message.contractName;
    }
    if (message.contractOwner !== "") {
      obj.contractOwner = message.contractOwner;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgUpdateActionSignerConfig>, I>>(base?: I): MsgUpdateActionSignerConfig {
    return MsgUpdateActionSignerConfig.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgUpdateActionSignerConfig>, I>>(object: I): MsgUpdateActionSignerConfig {
    const message = createBaseMsgUpdateActionSignerConfig();
    message.creator = object.creator ?? "";
    message.chain = object.chain ?? "";
    message.rpcEndpoint = object.rpcEndpoint ?? "";
    message.contractAddress = object.contractAddress ?? "";
    message.contractName = object.contractName ?? "";
    message.contractOwner = object.contractOwner ?? "";
    return message;
  },
};

function createBaseMsgUpdateActionSignerConfigResponse(): MsgUpdateActionSignerConfigResponse {
  return {
    chain: "",
    rpcEndpoint: "",
    newRpcEndpoint: "",
    contractAddress: "",
    newContractAddress: "",
    contractName: "",
    newContractName: "",
    contractOwner: "",
    newContractOwner: "",
  };
}

export const MsgUpdateActionSignerConfigResponse: MessageFns<MsgUpdateActionSignerConfigResponse> = {
  encode(message: MsgUpdateActionSignerConfigResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.chain !== "") {
      writer.uint32(10).string(message.chain);
    }
    if (message.rpcEndpoint !== "") {
      writer.uint32(18).string(message.rpcEndpoint);
    }
    if (message.newRpcEndpoint !== "") {
      writer.uint32(26).string(message.newRpcEndpoint);
    }
    if (message.contractAddress !== "") {
      writer.uint32(34).string(message.contractAddress);
    }
    if (message.newContractAddress !== "") {
      writer.uint32(42).string(message.newContractAddress);
    }
    if (message.contractName !== "") {
      writer.uint32(50).string(message.contractName);
    }
    if (message.newContractName !== "") {
      writer.uint32(58).string(message.newContractName);
    }
    if (message.contractOwner !== "") {
      writer.uint32(66).string(message.contractOwner);
    }
    if (message.newContractOwner !== "") {
      writer.uint32(74).string(message.newContractOwner);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgUpdateActionSignerConfigResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgUpdateActionSignerConfigResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.chain = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.rpcEndpoint = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.newRpcEndpoint = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.contractAddress = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.newContractAddress = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.contractName = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.newContractName = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.contractOwner = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.newContractOwner = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgUpdateActionSignerConfigResponse {
    return {
      chain: isSet(object.chain) ? globalThis.String(object.chain) : "",
      rpcEndpoint: isSet(object.rpcEndpoint) ? globalThis.String(object.rpcEndpoint) : "",
      newRpcEndpoint: isSet(object.newRpcEndpoint) ? globalThis.String(object.newRpcEndpoint) : "",
      contractAddress: isSet(object.contractAddress) ? globalThis.String(object.contractAddress) : "",
      newContractAddress: isSet(object.newContractAddress) ? globalThis.String(object.newContractAddress) : "",
      contractName: isSet(object.contractName) ? globalThis.String(object.contractName) : "",
      newContractName: isSet(object.newContractName) ? globalThis.String(object.newContractName) : "",
      contractOwner: isSet(object.contractOwner) ? globalThis.String(object.contractOwner) : "",
      newContractOwner: isSet(object.newContractOwner) ? globalThis.String(object.newContractOwner) : "",
    };
  },

  toJSON(message: MsgUpdateActionSignerConfigResponse): unknown {
    const obj: any = {};
    if (message.chain !== "") {
      obj.chain = message.chain;
    }
    if (message.rpcEndpoint !== "") {
      obj.rpcEndpoint = message.rpcEndpoint;
    }
    if (message.newRpcEndpoint !== "") {
      obj.newRpcEndpoint = message.newRpcEndpoint;
    }
    if (message.contractAddress !== "") {
      obj.contractAddress = message.contractAddress;
    }
    if (message.newContractAddress !== "") {
      obj.newContractAddress = message.newContractAddress;
    }
    if (message.contractName !== "") {
      obj.contractName = message.contractName;
    }
    if (message.newContractName !== "") {
      obj.newContractName = message.newContractName;
    }
    if (message.contractOwner !== "") {
      obj.contractOwner = message.contractOwner;
    }
    if (message.newContractOwner !== "") {
      obj.newContractOwner = message.newContractOwner;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgUpdateActionSignerConfigResponse>, I>>(
    base?: I,
  ): MsgUpdateActionSignerConfigResponse {
    return MsgUpdateActionSignerConfigResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgUpdateActionSignerConfigResponse>, I>>(
    object: I,
  ): MsgUpdateActionSignerConfigResponse {
    const message = createBaseMsgUpdateActionSignerConfigResponse();
    message.chain = object.chain ?? "";
    message.rpcEndpoint = object.rpcEndpoint ?? "";
    message.newRpcEndpoint = object.newRpcEndpoint ?? "";
    message.contractAddress = object.contractAddress ?? "";
    message.newContractAddress = object.newContractAddress ?? "";
    message.contractName = object.contractName ?? "";
    message.newContractName = object.newContractName ?? "";
    message.contractOwner = object.contractOwner ?? "";
    message.newContractOwner = object.newContractOwner ?? "";
    return message;
  },
};

function createBaseMsgDeleteActionSignerConfig(): MsgDeleteActionSignerConfig {
  return { creator: "", chain: "" };
}

export const MsgDeleteActionSignerConfig: MessageFns<MsgDeleteActionSignerConfig> = {
  encode(message: MsgDeleteActionSignerConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.creator !== "") {
      writer.uint32(10).string(message.creator);
    }
    if (message.chain !== "") {
      writer.uint32(18).string(message.chain);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgDeleteActionSignerConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgDeleteActionSignerConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.creator = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.chain = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgDeleteActionSignerConfig {
    return {
      creator: isSet(object.creator) ? globalThis.String(object.creator) : "",
      chain: isSet(object.chain) ? globalThis.String(object.chain) : "",
    };
  },

  toJSON(message: MsgDeleteActionSignerConfig): unknown {
    const obj: any = {};
    if (message.creator !== "") {
      obj.creator = message.creator;
    }
    if (message.chain !== "") {
      obj.chain = message.chain;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgDeleteActionSignerConfig>, I>>(base?: I): MsgDeleteActionSignerConfig {
    return MsgDeleteActionSignerConfig.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgDeleteActionSignerConfig>, I>>(object: I): MsgDeleteActionSignerConfig {
    const message = createBaseMsgDeleteActionSignerConfig();
    message.creator = object.creator ?? "";
    message.chain = object.chain ?? "";
    return message;
  },
};

function createBaseMsgDeleteActionSignerConfigResponse(): MsgDeleteActionSignerConfigResponse {
  return { chain: "" };
}

export const MsgDeleteActionSignerConfigResponse: MessageFns<MsgDeleteActionSignerConfigResponse> = {
  encode(message: MsgDeleteActionSignerConfigResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.chain !== "") {
      writer.uint32(10).string(message.chain);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgDeleteActionSignerConfigResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgDeleteActionSignerConfigResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.chain = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgDeleteActionSignerConfigResponse {
    return { chain: isSet(object.chain) ? globalThis.String(object.chain) : "" };
  },

  toJSON(message: MsgDeleteActionSignerConfigResponse): unknown {
    const obj: any = {};
    if (message.chain !== "") {
      obj.chain = message.chain;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgDeleteActionSignerConfigResponse>, I>>(
    base?: I,
  ): MsgDeleteActionSignerConfigResponse {
    return MsgDeleteActionSignerConfigResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgDeleteActionSignerConfigResponse>, I>>(
    object: I,
  ): MsgDeleteActionSignerConfigResponse {
    const message = createBaseMsgDeleteActionSignerConfigResponse();
    message.chain = object.chain ?? "";
    return message;
  },
};

function createBaseMsgCreateSyncActionSigner(): MsgCreateSyncActionSigner {
  return { creator: "", chain: "", actorAddress: "", ownerAddress: "", requiredConfirm: 0 };
}

export const MsgCreateSyncActionSigner: MessageFns<MsgCreateSyncActionSigner> = {
  encode(message: MsgCreateSyncActionSigner, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.creator !== "") {
      writer.uint32(10).string(message.creator);
    }
    if (message.chain !== "") {
      writer.uint32(18).string(message.chain);
    }
    if (message.actorAddress !== "") {
      writer.uint32(26).string(message.actorAddress);
    }
    if (message.ownerAddress !== "") {
      writer.uint32(34).string(message.ownerAddress);
    }
    if (message.requiredConfirm !== 0) {
      writer.uint32(40).uint64(message.requiredConfirm);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgCreateSyncActionSigner {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgCreateSyncActionSigner();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.creator = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.chain = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.actorAddress = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.ownerAddress = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.requiredConfirm = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgCreateSyncActionSigner {
    return {
      creator: isSet(object.creator) ? globalThis.String(object.creator) : "",
      chain: isSet(object.chain) ? globalThis.String(object.chain) : "",
      actorAddress: isSet(object.actorAddress) ? globalThis.String(object.actorAddress) : "",
      ownerAddress: isSet(object.ownerAddress) ? globalThis.String(object.ownerAddress) : "",
      requiredConfirm: isSet(object.requiredConfirm) ? globalThis.Number(object.requiredConfirm) : 0,
    };
  },

  toJSON(message: MsgCreateSyncActionSigner): unknown {
    const obj: any = {};
    if (message.creator !== "") {
      obj.creator = message.creator;
    }
    if (message.chain !== "") {
      obj.chain = message.chain;
    }
    if (message.actorAddress !== "") {
      obj.actorAddress = message.actorAddress;
    }
    if (message.ownerAddress !== "") {
      obj.ownerAddress = message.ownerAddress;
    }
    if (message.requiredConfirm !== 0) {
      obj.requiredConfirm = Math.round(message.requiredConfirm);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgCreateSyncActionSigner>, I>>(base?: I): MsgCreateSyncActionSigner {
    return MsgCreateSyncActionSigner.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgCreateSyncActionSigner>, I>>(object: I): MsgCreateSyncActionSigner {
    const message = createBaseMsgCreateSyncActionSigner();
    message.creator = object.creator ?? "";
    message.chain = object.chain ?? "";
    message.actorAddress = object.actorAddress ?? "";
    message.ownerAddress = object.ownerAddress ?? "";
    message.requiredConfirm = object.requiredConfirm ?? 0;
    return message;
  },
};

function createBaseMsgCreateSyncActionSignerResponse(): MsgCreateSyncActionSignerResponse {
  return { id: 0, chain: "", ownerAddress: "", actorAddress: "" };
}

export const MsgCreateSyncActionSignerResponse: MessageFns<MsgCreateSyncActionSignerResponse> = {
  encode(message: MsgCreateSyncActionSignerResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== 0) {
      writer.uint32(8).uint64(message.id);
    }
    if (message.chain !== "") {
      writer.uint32(18).string(message.chain);
    }
    if (message.ownerAddress !== "") {
      writer.uint32(26).string(message.ownerAddress);
    }
    if (message.actorAddress !== "") {
      writer.uint32(34).string(message.actorAddress);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgCreateSyncActionSignerResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgCreateSyncActionSignerResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = longToNumber(reader.uint64());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.chain = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.ownerAddress = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.actorAddress = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgCreateSyncActionSignerResponse {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      chain: isSet(object.chain) ? globalThis.String(object.chain) : "",
      ownerAddress: isSet(object.ownerAddress) ? globalThis.String(object.ownerAddress) : "",
      actorAddress: isSet(object.actorAddress) ? globalThis.String(object.actorAddress) : "",
    };
  },

  toJSON(message: MsgCreateSyncActionSignerResponse): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.chain !== "") {
      obj.chain = message.chain;
    }
    if (message.ownerAddress !== "") {
      obj.ownerAddress = message.ownerAddress;
    }
    if (message.actorAddress !== "") {
      obj.actorAddress = message.actorAddress;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgCreateSyncActionSignerResponse>, I>>(
    base?: I,
  ): MsgCreateSyncActionSignerResponse {
    return MsgCreateSyncActionSignerResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgCreateSyncActionSignerResponse>, I>>(
    object: I,
  ): MsgCreateSyncActionSignerResponse {
    const message = createBaseMsgCreateSyncActionSignerResponse();
    message.id = object.id ?? 0;
    message.chain = object.chain ?? "";
    message.ownerAddress = object.ownerAddress ?? "";
    message.actorAddress = object.actorAddress ?? "";
    return message;
  },
};

function createBaseMsgSubmitSyncActionSigner(): MsgSubmitSyncActionSigner {
  return { creator: "", syncId: 0, chain: "", actorAddress: "", ownerAddress: "", expireEpoch: "" };
}

export const MsgSubmitSyncActionSigner: MessageFns<MsgSubmitSyncActionSigner> = {
  encode(message: MsgSubmitSyncActionSigner, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.creator !== "") {
      writer.uint32(10).string(message.creator);
    }
    if (message.syncId !== 0) {
      writer.uint32(16).uint64(message.syncId);
    }
    if (message.chain !== "") {
      writer.uint32(26).string(message.chain);
    }
    if (message.actorAddress !== "") {
      writer.uint32(34).string(message.actorAddress);
    }
    if (message.ownerAddress !== "") {
      writer.uint32(42).string(message.ownerAddress);
    }
    if (message.expireEpoch !== "") {
      writer.uint32(50).string(message.expireEpoch);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgSubmitSyncActionSigner {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgSubmitSyncActionSigner();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.creator = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.syncId = longToNumber(reader.uint64());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.chain = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.actorAddress = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.ownerAddress = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.expireEpoch = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgSubmitSyncActionSigner {
    return {
      creator: isSet(object.creator) ? globalThis.String(object.creator) : "",
      syncId: isSet(object.syncId) ? globalThis.Number(object.syncId) : 0,
      chain: isSet(object.chain) ? globalThis.String(object.chain) : "",
      actorAddress: isSet(object.actorAddress) ? globalThis.String(object.actorAddress) : "",
      ownerAddress: isSet(object.ownerAddress) ? globalThis.String(object.ownerAddress) : "",
      expireEpoch: isSet(object.expireEpoch) ? globalThis.String(object.expireEpoch) : "",
    };
  },

  toJSON(message: MsgSubmitSyncActionSigner): unknown {
    const obj: any = {};
    if (message.creator !== "") {
      obj.creator = message.creator;
    }
    if (message.syncId !== 0) {
      obj.syncId = Math.round(message.syncId);
    }
    if (message.chain !== "") {
      obj.chain = message.chain;
    }
    if (message.actorAddress !== "") {
      obj.actorAddress = message.actorAddress;
    }
    if (message.ownerAddress !== "") {
      obj.ownerAddress = message.ownerAddress;
    }
    if (message.expireEpoch !== "") {
      obj.expireEpoch = message.expireEpoch;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgSubmitSyncActionSigner>, I>>(base?: I): MsgSubmitSyncActionSigner {
    return MsgSubmitSyncActionSigner.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgSubmitSyncActionSigner>, I>>(object: I): MsgSubmitSyncActionSigner {
    const message = createBaseMsgSubmitSyncActionSigner();
    message.creator = object.creator ?? "";
    message.syncId = object.syncId ?? 0;
    message.chain = object.chain ?? "";
    message.actorAddress = object.actorAddress ?? "";
    message.ownerAddress = object.ownerAddress ?? "";
    message.expireEpoch = object.expireEpoch ?? "";
    return message;
  },
};

function createBaseMsgSubmitSyncActionSignerResponse(): MsgSubmitSyncActionSignerResponse {
  return { verifyRequestID: 0, expireAt: "" };
}

export const MsgSubmitSyncActionSignerResponse: MessageFns<MsgSubmitSyncActionSignerResponse> = {
  encode(message: MsgSubmitSyncActionSignerResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.verifyRequestID !== 0) {
      writer.uint32(8).uint64(message.verifyRequestID);
    }
    if (message.expireAt !== "") {
      writer.uint32(18).string(message.expireAt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgSubmitSyncActionSignerResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgSubmitSyncActionSignerResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.verifyRequestID = longToNumber(reader.uint64());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.expireAt = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgSubmitSyncActionSignerResponse {
    return {
      verifyRequestID: isSet(object.verifyRequestID) ? globalThis.Number(object.verifyRequestID) : 0,
      expireAt: isSet(object.expireAt) ? globalThis.String(object.expireAt) : "",
    };
  },

  toJSON(message: MsgSubmitSyncActionSignerResponse): unknown {
    const obj: any = {};
    if (message.verifyRequestID !== 0) {
      obj.verifyRequestID = Math.round(message.verifyRequestID);
    }
    if (message.expireAt !== "") {
      obj.expireAt = message.expireAt;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgSubmitSyncActionSignerResponse>, I>>(
    base?: I,
  ): MsgSubmitSyncActionSignerResponse {
    return MsgSubmitSyncActionSignerResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgSubmitSyncActionSignerResponse>, I>>(
    object: I,
  ): MsgSubmitSyncActionSignerResponse {
    const message = createBaseMsgSubmitSyncActionSignerResponse();
    message.verifyRequestID = object.verifyRequestID ?? 0;
    message.expireAt = object.expireAt ?? "";
    return message;
  },
};

/** Msg defines the Msg service. */
export interface Msg {
  /**
   * UpdateParams defines a (governance) operation for updating the module
   * parameters. The authority defaults to the x/gov module account.
   */
  UpdateParams(request: MsgUpdateParams): Promise<MsgUpdateParamsResponse>;
  CreateMintRequest(request: MsgCreateMintRequest): Promise<MsgCreateMintRequestResponse>;
  SubmitMintResponse(request: MsgSubmitMintResponse): Promise<MsgSubmitMintResponseResponse>;
  CreateActionRequest(request: MsgCreateActionRequest): Promise<MsgCreateActionRequestResponse>;
  SubmitActionResponse(request: MsgSubmitActionResponse): Promise<MsgSubmitActionResponseResponse>;
  CreateVerifyCollectionOwnerRequest(
    request: MsgCreateVerifyCollectionOwnerRequest,
  ): Promise<MsgCreateVerifyCollectionOwnerRequestResponse>;
  SubmitVerifyCollectionOwner(request: MsgSubmitVerifyCollectionOwner): Promise<MsgSubmitVerifyCollectionOwnerResponse>;
  SetMinimumConfirmation(request: MsgSetMinimumConfirmation): Promise<MsgSetMinimumConfirmationResponse>;
  CreateActionSigner(request: MsgCreateActionSigner): Promise<MsgCreateActionSignerResponse>;
  UpdateActionSigner(request: MsgUpdateActionSigner): Promise<MsgUpdateActionSignerResponse>;
  DeleteActionSigner(request: MsgDeleteActionSigner): Promise<MsgDeleteActionSignerResponse>;
  CreateActionSignerConfig(request: MsgCreateActionSignerConfig): Promise<MsgCreateActionSignerConfigResponse>;
  UpdateActionSignerConfig(request: MsgUpdateActionSignerConfig): Promise<MsgUpdateActionSignerConfigResponse>;
  DeleteActionSignerConfig(request: MsgDeleteActionSignerConfig): Promise<MsgDeleteActionSignerConfigResponse>;
  CreateSyncActionSigner(request: MsgCreateSyncActionSigner): Promise<MsgCreateSyncActionSignerResponse>;
  SubmitSyncActionSigner(request: MsgSubmitSyncActionSigner): Promise<MsgSubmitSyncActionSignerResponse>;
}

export const MsgServiceName = "sixprotocol.nftoracle.Msg";
export class MsgClientImpl implements Msg {
  private readonly rpc: Rpc;
  private readonly service: string;
  constructor(rpc: Rpc, opts?: { service?: string }) {
    this.service = opts?.service || MsgServiceName;
    this.rpc = rpc;
    this.UpdateParams = this.UpdateParams.bind(this);
    this.CreateMintRequest = this.CreateMintRequest.bind(this);
    this.SubmitMintResponse = this.SubmitMintResponse.bind(this);
    this.CreateActionRequest = this.CreateActionRequest.bind(this);
    this.SubmitActionResponse = this.SubmitActionResponse.bind(this);
    this.CreateVerifyCollectionOwnerRequest = this.CreateVerifyCollectionOwnerRequest.bind(this);
    this.SubmitVerifyCollectionOwner = this.SubmitVerifyCollectionOwner.bind(this);
    this.SetMinimumConfirmation = this.SetMinimumConfirmation.bind(this);
    this.CreateActionSigner = this.CreateActionSigner.bind(this);
    this.UpdateActionSigner = this.UpdateActionSigner.bind(this);
    this.DeleteActionSigner = this.DeleteActionSigner.bind(this);
    this.CreateActionSignerConfig = this.CreateActionSignerConfig.bind(this);
    this.UpdateActionSignerConfig = this.UpdateActionSignerConfig.bind(this);
    this.DeleteActionSignerConfig = this.DeleteActionSignerConfig.bind(this);
    this.CreateSyncActionSigner = this.CreateSyncActionSigner.bind(this);
    this.SubmitSyncActionSigner = this.SubmitSyncActionSigner.bind(this);
  }
  UpdateParams(request: MsgUpdateParams): Promise<MsgUpdateParamsResponse> {
    const data = MsgUpdateParams.encode(request).finish();
    const promise = this.rpc.request(this.service, "UpdateParams", data);
    return promise.then((data) => MsgUpdateParamsResponse.decode(new BinaryReader(data)));
  }

  CreateMintRequest(request: MsgCreateMintRequest): Promise<MsgCreateMintRequestResponse> {
    const data = MsgCreateMintRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "CreateMintRequest", data);
    return promise.then((data) => MsgCreateMintRequestResponse.decode(new BinaryReader(data)));
  }

  SubmitMintResponse(request: MsgSubmitMintResponse): Promise<MsgSubmitMintResponseResponse> {
    const data = MsgSubmitMintResponse.encode(request).finish();
    const promise = this.rpc.request(this.service, "SubmitMintResponse", data);
    return promise.then((data) => MsgSubmitMintResponseResponse.decode(new BinaryReader(data)));
  }

  CreateActionRequest(request: MsgCreateActionRequest): Promise<MsgCreateActionRequestResponse> {
    const data = MsgCreateActionRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "CreateActionRequest", data);
    return promise.then((data) => MsgCreateActionRequestResponse.decode(new BinaryReader(data)));
  }

  SubmitActionResponse(request: MsgSubmitActionResponse): Promise<MsgSubmitActionResponseResponse> {
    const data = MsgSubmitActionResponse.encode(request).finish();
    const promise = this.rpc.request(this.service, "SubmitActionResponse", data);
    return promise.then((data) => MsgSubmitActionResponseResponse.decode(new BinaryReader(data)));
  }

  CreateVerifyCollectionOwnerRequest(
    request: MsgCreateVerifyCollectionOwnerRequest,
  ): Promise<MsgCreateVerifyCollectionOwnerRequestResponse> {
    const data = MsgCreateVerifyCollectionOwnerRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "CreateVerifyCollectionOwnerRequest", data);
    return promise.then((data) => MsgCreateVerifyCollectionOwnerRequestResponse.decode(new BinaryReader(data)));
  }

  SubmitVerifyCollectionOwner(
    request: MsgSubmitVerifyCollectionOwner,
  ): Promise<MsgSubmitVerifyCollectionOwnerResponse> {
    const data = MsgSubmitVerifyCollectionOwner.encode(request).finish();
    const promise = this.rpc.request(this.service, "SubmitVerifyCollectionOwner", data);
    return promise.then((data) => MsgSubmitVerifyCollectionOwnerResponse.decode(new BinaryReader(data)));
  }

  SetMinimumConfirmation(request: MsgSetMinimumConfirmation): Promise<MsgSetMinimumConfirmationResponse> {
    const data = MsgSetMinimumConfirmation.encode(request).finish();
    const promise = this.rpc.request(this.service, "SetMinimumConfirmation", data);
    return promise.then((data) => MsgSetMinimumConfirmationResponse.decode(new BinaryReader(data)));
  }

  CreateActionSigner(request: MsgCreateActionSigner): Promise<MsgCreateActionSignerResponse> {
    const data = MsgCreateActionSigner.encode(request).finish();
    const promise = this.rpc.request(this.service, "CreateActionSigner", data);
    return promise.then((data) => MsgCreateActionSignerResponse.decode(new BinaryReader(data)));
  }

  UpdateActionSigner(request: MsgUpdateActionSigner): Promise<MsgUpdateActionSignerResponse> {
    const data = MsgUpdateActionSigner.encode(request).finish();
    const promise = this.rpc.request(this.service, "UpdateActionSigner", data);
    return promise.then((data) => MsgUpdateActionSignerResponse.decode(new BinaryReader(data)));
  }

  DeleteActionSigner(request: MsgDeleteActionSigner): Promise<MsgDeleteActionSignerResponse> {
    const data = MsgDeleteActionSigner.encode(request).finish();
    const promise = this.rpc.request(this.service, "DeleteActionSigner", data);
    return promise.then((data) => MsgDeleteActionSignerResponse.decode(new BinaryReader(data)));
  }

  CreateActionSignerConfig(request: MsgCreateActionSignerConfig): Promise<MsgCreateActionSignerConfigResponse> {
    const data = MsgCreateActionSignerConfig.encode(request).finish();
    const promise = this.rpc.request(this.service, "CreateActionSignerConfig", data);
    return promise.then((data) => MsgCreateActionSignerConfigResponse.decode(new BinaryReader(data)));
  }

  UpdateActionSignerConfig(request: MsgUpdateActionSignerConfig): Promise<MsgUpdateActionSignerConfigResponse> {
    const data = MsgUpdateActionSignerConfig.encode(request).finish();
    const promise = this.rpc.request(this.service, "UpdateActionSignerConfig", data);
    return promise.then((data) => MsgUpdateActionSignerConfigResponse.decode(new BinaryReader(data)));
  }

  DeleteActionSignerConfig(request: MsgDeleteActionSignerConfig): Promise<MsgDeleteActionSignerConfigResponse> {
    const data = MsgDeleteActionSignerConfig.encode(request).finish();
    const promise = this.rpc.request(this.service, "DeleteActionSignerConfig", data);
    return promise.then((data) => MsgDeleteActionSignerConfigResponse.decode(new BinaryReader(data)));
  }

  CreateSyncActionSigner(request: MsgCreateSyncActionSigner): Promise<MsgCreateSyncActionSignerResponse> {
    const data = MsgCreateSyncActionSigner.encode(request).finish();
    const promise = this.rpc.request(this.service, "CreateSyncActionSigner", data);
    return promise.then((data) => MsgCreateSyncActionSignerResponse.decode(new BinaryReader(data)));
  }

  SubmitSyncActionSigner(request: MsgSubmitSyncActionSigner): Promise<MsgSubmitSyncActionSignerResponse> {
    const data = MsgSubmitSyncActionSigner.encode(request).finish();
    const promise = this.rpc.request(this.service, "SubmitSyncActionSigner", data);
    return promise.then((data) => MsgSubmitSyncActionSignerResponse.decode(new BinaryReader(data)));
  }
}

interface Rpc {
  request(service: string, method: string, data: Uint8Array): Promise<Uint8Array>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function longToNumber(int64: { toString(): string }): number {
  const num = globalThis.Number(int64.toString());
  if (num > globalThis.Number.MAX_SAFE_INTEGER) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (num < globalThis.Number.MIN_SAFE_INTEGER) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return num;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
